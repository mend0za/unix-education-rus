\chapter{System V IPC}

К семейству System V IPC относятся 3 метода взаимодействия:
\begin{itemize}
\item очереди сообщений
\item разделяемая память
\item семафоры
\end{itemize}

Характеризуются общим способом адресации и схожими системными вызовами для работы с ними.
Хранятся в пространстве ядра. После создания - не требуют существования создавшего процесса.

Область видимости структур IPC - вся система и не имеют счётчика ссылок. Не адресуются как имена на файловой системе, соотвественно не могут управлятся как файлы с помощью стандартных вызовов. Управляются только своими syscalls. Используют свои user-space утилиты для просмотра и удаления (ipcs, ipcrm).

Поскольку структуры System V IPC - не файлы, то к ним не может быть применено  мультиплексирование (\ref{select}, \ref{poll}). Это усложняет использование более чем 1 структуры одновременно или совместно с вводом/выводом из/в файл/устройтво. 

\section{Идентификаторы и ключи}

Каждая структура IPC (очереди, семафоры, разделяемая память) адресуется в ядре положительным целочисленным идентификатором. 

При создании структуры IPC ключ должен быть указан. 

Все три типа адресуются ключём типа \verb+key_t+. \verb+key_t+ определён в \verb+<sys/types.h>+ как целое (по меньшей мере - 32разрядное). Ключ переводится в идентификатор ядром.

Обычно генерируется функцией \verb+ftok+ по пути к файлу и произвольному идентификатору :
\begin{verbatim}
#include <sys/types.h>
key_t ftok(const char * pathname, int proj_id);
\end{verbatim}

Существуют различные пути для обеспечения встречи клиента и сервера в одной IPC структуре:
\begin{enumerate}
\item Сервер создаёт новую структуру IPC указывая \verb+IPC_PRIVATE+ и сохраняет ключ куда-либо для клиента (например в файл).  Также может использоваться при отношениях "предок-потомок", тогда ключ передаётся при fork порождённому процессу.
\item Через общий заголовочный файл, задав ключ как число. Сервер создаёт структуру IPC указывая этот ключ. Клиент получает доступ. Проблема - ключ уже может использоваться кем-то ещё.
\item Клиент и сервер могут согласится на путь к файлу и идентификатор проекта (от 0 до 255) и вызвать \verb+ftok()+ для перевода пути и идентификатора в ключ.
\end{enumerate}

\section{Права доступа}

System V IPC связывает структуру \verb+ipc_perm+ с каждой структурой IPC. Она определяет 
\emph{владельца и права доступа} (аналогично доступу к файлу).

\begin{verbatim}
struct ipc_perm {
	uid_t uid; // uid владельца
	gid_t gid; // uid группы
	uid_t cuid; // uid создателя 
	gid_t cgid; // gid создателя
	mode_t mode; // режимы доступа
	ulog seq; // число использований (TODO, неясный смысл)
	key_t key; // ключ
};
\end{verbatim}

Все поля кроме \verb+seq+ задаются при создании структуры IPC. С помощью вызовов \verb+msgctl, +\verb+semctl+, \verb+shmctl+ мы можем поменять \verb+uid+, \verb+gid+ и \verb+mode+ позднее.

\begin{table}[hbtp]
\caption{Права доступа System V IPC объектов}
\begin{tabular}{ l l l l  }
	Permission & Message Queue & Semaphore & Shared Memory \\
	\hline
	user-read  & \verb+MSG_R+ & \verb+SEM_R+ & \verb+SHM_R+ \\
	user-write & \verb+MSG_W+ & \verb+SEM_A+ & \verb+SHM_W+ \\
	\hline
	group-read  & \verb+MSG_R>>3+ & \verb+SEM_R>>3+ & \verb+SHM_R>>3+ \\
	group-write & \verb+MSG_W>>3+ & \verb+SEM_A>>3+ & \verb+SHM_W>>3+ \\
	\hline
	other-read  & \verb+MSG_R>>6+ & \verb+SEM_R>>6+ & \verb+SHM_R>>6+ \\
	other-write & \verb+MSG_W>>6+ & \verb+SEM_A>>6+ & \verb+SHM_W>>6+ \\
	\hline
\end{tabular}
\label{sysvipc_perm}
\end{table}

\section{Очереди сообщений}

\emph{Очередь сообщений} - это связанный список сообщений, хранящийся в ядре и определяемый идентификатором очереди (Queue ID).

Очередь можно создать или открыть уже существующую через \verb+msgget()+.

Новые сообщения добавляются в конец очереди через \verb+msgsnd()+. Каждое сообщение имеет тип (положительное целое число), длину, и данные этой длины, которые передаются в \verb+msgsnd()+ при добавлении в очередь.

Сообщения принимаются из очереди через \verb+msgrcv+. Мы можем принимать сообщения основываясь на их типе.

\subsection{Создание очереди}
\begin{verbatim}
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int flag);
\end{verbatim}
