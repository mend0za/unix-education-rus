\chapter{Регулярные выражения. sed}

\label{regexp}
\emph{Регулярные выражения (regular expression или regexp)} -  специальные строки символов, которые задаются для поиска совпадающих фрагментов. Иначе говоря это способ описания наборов букв. 

Простейшим набором является слово, но регулярное выражение может включать и глобальные символы, заменяющие другие символы. Все UNIX-программы, осуществляющие поиск в тексте, используют регулярные выражения. Если слово или фраза описаны регулярным выражением, говорят, что они соответствуют регулярному выражению. 

\emph{Регулярные выражения} - мощное, гибкое и эффективное средство обработки текстов. Универсальные шаблоны регулярных выражений сами по себе напоминают миниатюрный язык программирования, предназначенный для описания и анализа текста. При дополнительной поддержке со стороны конкретной утилиты или языка программирования регулярные выражения способны вставлять, удалять, выделять текстовые данные любого вида и выполнять практичяески любые операции над ними.

Регулярные выражения расширяют принципы \emph{метасимволов (шаблонов или wildcards)}. 

Некоторые программы используют регулярные выражения в чистом виде (grep, egrep). Но чаще всего регулярные выражения используются внутри специальных языковых конструкций, т. н. "оберток". 

\section{Структура регулярных выражений}

Регулярное выражение состоит из двух типов символов. Специальные символы называются \emph{метасимволами}. Все остальные символы (то есть обычный текст), называются \emph{литералами}.

Регулярные выражения можно рассматривать как самостоятельный язык, в котором литералы выполняют функции слов, а метасимволы - функции грамматических элементов. Слова по определенным правилам объединяются сграмматическими элементами и создают конструкции, выражающие некоторую мысль.

Для примера: существует утилита \verb+grep+\footnote{Утилиты семейства grep предназначены для поиска текста по шаблонам регулярных выражений}. При запуске программе \verb+grep+ передается регулярное выражение и список просматриваемых файлов. Она сопоставляет regexp с каждой строкой файла и выводит только те строки, в которых было найдено совпадение.
\begin{verbatim}
$ grep 'cat' file1.text 
\end{verbatim}
Если в нашем выражении ($\ulcorner cat \lrcorner$ \footnote{Для grep рекомендуется заключать regexp в кавычки, так как некоторые метасимволы имеют для оболочки специальные значения и выражение может работать некорректно}) не используются метасимволы, оно фактически превращается в стредство "простого поиска текста". Будут найдены и выведены все строки файла, содержащие три стоящие подряд буквы \verb+c, a+ и \verb+t+. Среди них будут выведены строки, в которых встречается слово (к примеру) \verb+vacation+. Даже если в строке нет слова \verb+cat+, последовательность букв \verb+c+ \verb+a+ \verb+t+ в слове \verb+vacation+ все равно считается успешно найденной. Необходимо только наличие указанных символов.

\section{Правила для регулярных выражений}

Существует всего два универсальных правила для регулярных выражений:
\begin{enumerate}
\item Предпочтение отдается тому совпадению, которое начинается раньше.
\item Квантификаторы (см. \ref{requant}) всегда работают максимально. Если некоторый элемент может совпадать переменное число раз, механизм всегда пытается найти максимальное число повторений.
\end{enumerate}

Признаки хорошо написанного регулярного выражения:
\begin{itemize}
\item регулярное выражение должно совпадать там где нужно и нигде более
\item регулярное выражение должно быть понятным и управляемым
\item оно должно быть эффективным ( быстро приводить к совпадению или несовпадению в зависимости от результатов поиска)
\end{itemize}

\section{Диалекты регулярных выражений}

В разных программах регулярные выражения выполняют разные функции, поэтому наборы метасимволов и другие возможности, поддерживаемые программами, также различаются.

К примеру, диалекты регулярных выражений в sed, perl и grep имеют значительное число отличий между собой. Более того, различные варианты grep тоже могут использовать разные диалекты. 

Далее изложение будет придерживаться диалекта \verb+sed+, с указанием отличий от других реализаций регулярных выражений.
 
\section{Метасимволы}

Существует несколько типов метасимволов, выполняющих разные функции. Значение некоторых из них различно в разных частях выражения (или зависит от контекста).

\subsection{Начало и конец строки}

$\ulcorner\verb+^+\lrcorner$ (крышка) и  $\ulcorner \$ \lrcorner$(доллар) представляют собой начало и конец проверяемой строки.

Примеры:
\begin{enumerate}
\item \(\ulcorner \verb+^cat+ \lrcorner\) находит все строки, в начале которых находиться \verb+cat+.
\item \(\ulcorner \verb+^cat$+ \lrcorner\) находит все строки, которые состоят только из \verb+cat+
\item \(\ulcorner \verb+^$+ \lrcorner\) пустая строка
\end{enumerate}

Особенность $\ulcorner \verb+^+ \lrcorner$ и $\ulcorner \$ \lrcorner$ в том, что они совпадают с определенной \emph{позицией} строки, а не с символами текста.

\subsection{Символьные классы}

\subsubsection{Совпадение с одним символом из нескольких возможных}

При помощи конструкции $\ulcorner[\ldots]\lrcorner$, называемой \emph{символьным классом} (character class), можно перечислить символы, которые могут находиться в данной позиции текста. 

Примеры:\label{examplegray}
\begin{enumerate}
\item $\ulcorner gr[ea]y\lrcorner$. Это обозначает "найти символ \verb+g+, за которым идет \verb+r+, за которым следуют \verb+e+ или \verb+a+ и все это завершается символом \verb+y+".
\item $\ulcorner[Ss]eparate\lrcorner$. возможная смена регистра в первой букве
\end{enumerate}

Количество символов в классе может быть любым. Например, класс $\ulcorner[123456]\lrcorner$ совпадает с любой из перечисленных цифр.

В контексте (внутри) символьного класса \emph{метасимвол символьного класса} \verb+-+ обозначает интервал символов; так выражение $\ulcorner[1-6]\lrcorner$ эквивалентно предыдущему примеру. Классы $\ulcorner[0-9]\lrcorner$ и $\ulcorner[a-z]\lrcorner$ обычно используются для поиска цифр и символов нижнего регистра соответственно.

Символьный класс может содержать несколько интервалов, поэтому класс $\ulcorner[0123456789abcdefABCDEF]\lrcorner$ записывается в виде $\ulcorner[0-9a-fA-F]\lrcorner$. Интервалы также можно записывать вместе с литералами: $\ulcorner[0-9\verb+_!.?+A-Z]\lrcorner$ (совпадет со всеми цифрами, буквами в верхнем регистре и знаками подчеркивания, точки, восклицательного и вопросительного знаков).

\emph{Примечание 1}. Дефис выполняет функции метасимвола только внутри символьного класса - в остальных случаях он совпадает с обычным дефисом в строке.

\emph{Примечание 2}. Правила, определяющие состав поддерживаемых метасимволов (и их функции) внутри класса и за его пределами, полностью различны.

\emph{Примечание 3}. Дефис не интерпретируется как метасимвол, если он находиться на первой позиции класса, например $\ulcorner [\verb+-./+] \lrcorner$.

\subsubsection{Инвертированые символьные классы}

Есле вместо $\ulcorner[\ldots]\lrcorner$ используется запись $\ulcorner[\verb+^+\ldots]\lrcorner$, класс совпадает с любыми символами \emph{не входящими} в приведенный список. Пример: $\ulcorner q[\verb+^+u]\lrcorner$.

Префикс  \verb+^+ инвертирует список - вместо того, чтобы перечислять символы, принадлежащие классу, перечисляются символы, не входящие в него.

\emph{Примечание}. Инвертированный класс означает "совпадение с символами не входящими в список", а не "несовпадение с символами, входящими в список". Поэтому инвертированный класс удобно рассматривать как сокращенную форму записи для обычного класса, включающего все символы, \emph{кроме} перечисленных.

\subsection{Один произвольный символ}

Метасимвол $\ulcorner . \lrcorner$ (точка) представляет собой сокращенную форму записи для символьного класса, содержащего \emph{все} символы. Применяется в тех случаях, когда в некоторых позициях регулярного выражения могут находиться произвольные символы.

Пример: пусть надо найти дату, которая может быть записана в формате \verb+07/04/76+, \verb+07-06-76+ или \verb+07.06.76+. Самый простой вариант - $\ulcorner 07.04.76 \lrcorner$. Но такое выражение будет совпадать и со строкой \verb+19 207304 7639+. Выражение $\ulcorner 07[-./]04[-./]76 \lrcorner$ обеспечевает более точное совпадение, но его труднее читать и записывать.

При построении регулярных выражений часто приходиться идти на компромис с точноcтья за счет знания текста. Если вы уверены, что в тексте $\ulcorner 07.04.76 \lrcorner$ наверняка не вызовет нежелательных совпадений, то этим вариантом вполне можно воспользоваться. 

Замечание. \emph{Знание целевого текста - важный фактор, обеспечивающий эффективное использование регулярных выражений}

\subsection{Выбор}
\subsubsection{Одно из нескольких выражений}

\label{reor}
Очень удобный символ $\ulcorner \verb+\|+ \lrcorner$ \footnote{Для Perl и egrep - $\mid$ } обозначает "или". Он позволяет объединить несколько регулярных выражений в одно, совпадающее с любым из выражений-компонентов. 

Например, $\ulcorner Erik \lrcorner$ и $\ulcorner Bobby \lrcorner$ - два разных выражения, а  $\ulcorner Erik\verb+\|+Bobby \lrcorner$ - одно выражение, совпадающее с любой из этих строк. Подвыражения, объединенные этим способом, называются \emph{альтернативами} (alternatives).

Конструкция выбора всегда является высокоуровневой (то есть обладающей очень низким приоритетом).

Вернемся к примеру 1 из \ref{examplegray} $\ulcorner gr[ae]y \lrcorner$. Это выражение можно записать также в виде $\ulcorner gray \backslash \mid grey \lrcorner$ или даже $\ulcorner \verb+gr\(a\|e\)y+ \lrcorner$\footnote{Для диалекта sed. Для egrep или perl это будет gr(a$\mid$e)y.}. Здесь круглые скобки \verb+\(+ и \verb+\)+ отделяют конструкцию выбора от остального выражения. Без скобок $\ulcorner gra\mid ey \lrcorner$ будет означать "$\ulcorner gra \lrcorner$ или $\ulcorner ey \lrcorner$".

Выражение внутри скобок может быть как угодно сложным, но "снаружи" оно воспринимается как единое целое.
 
\emph{Примечание}. Не путайте конструкцию выбора с символьным классом. Класс $\ulcorner abc \lrcorner$ и конструкция выбора $\ulcorner \verb+\(a\|b\|c\)+ \lrcorner$ фактически обозначают одно и то же, но это не для общего случая. Символьный класс совпадает ровно с одним символом, каким бы длинным или коротким не был список допустимых символов. С другой стороны, конструкция выбора может содержать альтернативы произвольной длинны, совершенно не связанные друг с другом длиной текста: $\ulcorner \verb+\(1.000.000\|million\|thousand*thousand\)+ \lrcorner$. В отличие от символьных классов, конструкции выбора не могут инвертироваться.

\subsection{Границы слов}

Одна из распространенных проблем заключается в том, что искомое слово встречается внутри других слов. Для явного указания начала и конца слова используются \emph{метапоследовательности} $\ulcorner \backslash< \lrcorner$ и $\ulcorner \backslash> \lrcorner$

Как и якоря \verb+^+ и \verb+$+, эти метапоследовательности не соотвествуют конкретным символам.

Примеры:
\begin{enumerate}
\item $\ulcorner \verb=\<cat\>= \lrcorner$ - найти отдельное слово \verb+cat+
\item $\ulcorner \verb=\<free= \lrcorner$ - найти слово, начинающееся с \verb+free+, к примеру \verb+freeware+
\item $\ulcorner \verb=ed\>= \lrcorner$- найти слова, заканчивающиеся на \verb+ed+
\end{enumerate}

\emph{Примечание} Сами по себе символы $\ulcorner < \lrcorner$ и $\ulcorner > \lrcorner$ метасимволами не являются. Они приобретают особый смысл только в сочетании с обратным слэшем \verb+\+.  

\section{Квантификаторы} 

\label{requant}
\emph{Квантификаторы} регулируют количество экземпляров повторяющегося элемента. Сами по себе, квантификаторы не являются щаблонами символов в тексте, но поставленные после символа или выражения в скобках, указывают, сколько раз может повторяться этот символ или выражение.

Квантификаторы руководствуются критерием максимального совпадения и пытаются найти совпадение как можно большей длины.

\subsection{Необязательные элементы}

Метасимвол $\ulcorner \verb+\?+ \lrcorner$ \footnote{Для Perl, egrep - ?.} (вопросительный знак) означает "необязательный символ". Он ставиться после символа, который может находиться в данной позиции текста, но наличие которого не требуется для успешного совпадения. Вопросительный знак относиться \emph{только} к символу, расположенному непосредственно перед ним.

Пример: $\ulcorner \verb+colou\?r+ \lrcorner$  

Пример2; Пусть нам надо найти дату, содержащую четвертый день месяца. На английском, это будет выглядеть так: \verb+4+ или \verb+4th+ или \verb+fourth+ - $\ulcorner fourth\mid 4\mid 4th \lrcorner$. Вторую половину выражения можно сократить до $\ulcorner \verb+4\(th\)\?+ \lrcorner$. Получим $\ulcorner \verb+fourth\|4\(th\)\?+ \lrcorner$.

Таким образом, квантификатор $\ulcorner \verb+\?+ \lrcorner$ может присоединяться и к выражениям в скобках.

\subsection{Повторение}

\begin{itemize}
\item Метасимвол $\ulcorner \verb=\+= \lrcorner$ \footnote{Для perl и egrep $+$}обозначает "один или несколько экземпляров непосредственно предшествуюших элементов".
\item Метасимвол $\ulcorner * \lrcorner$ обозначает "любое количество экземпляров элемента (в том числе и нулевое)".
\end{itemize}

Иначе говоря, $\ulcorner * \lrcorner$ означает "найти столько экземпляров сколько возможно, но при необходимости обойтись и без них". Конструкция $\ulcorner \verb=\+= \lrcorner$ имеет похожий смысл, но при отсутствии хотя бы одного экземпляра сопоставление завершается неудачей.

Примеры:
\begin{enumerate}
\item $\ulcorner \verb=^[0-9]\+= \lrcorner$ - строка, начинающаяся с одной или более цифр 
\item $\ulcorner \verb=^[0-9]*=\$ \lrcorner$ -  строка, содержащая в себе только цифры(может быть и пустой) 
\item $\ulcorner .* \lrcorner$ - любое количество любых символов
\item $\ulcorner * \lrcorner$ и $\ulcorner + \lrcorner$ могут следовать за скобками: $\ulcorner \verb=\(th\)i\+= \lrcorner$ - одно и более сочетаний букв \verb+th+ подряд
\item $\ulcorner _\sqcup \verb=\+= \lrcorner$ - один или более пробелов
\end{enumerate} 

\subsection{Интервал}

Конструкция вида $\ulcorner \ldots \verb+\{min,max\}+ \lrcorner$\footnote{В egrep и perl она выглядит как \dots\{min,max\}} называется \emph{интервальным} квантификатором.

Например, выражение $\ulcorner \ldots \verb+\{3,12\}+ \lrcorner$ совпадает до 12 раз, если это возможно, но может ограничиться и всего 3 совпадениями. Запись \verb+\{0,1\}+ эквивалентна метасимволу \verb+\?+, \verb+\{1,\}+ - \verb=+=.

\section{Круглые скобки и обратные сcылки}

Мы уже знакомы с двумя применениями круглых скобок:
\begin{itemize}
\item ограничение области действия \verb+|+ (см. \ref{reor})
\item группировка символов для применения квантификаторов (см. \ref{requant})
\end{itemize}

Существует еще одно применение круглых скобок. Круглые скобки могут "запоминать" текст, который совпал с подходящим в них подвыражением.

\emph{Обратные ссылки} позволяют искать новый текст, который совпадает с другим текстом в предшествующей части регулярного выражения, причем на момент написания выражения этот текст \emph{неизвестен}.

Круглые скобки "запоминают" текст, а специальный метасимвол $\ulcorner \backslash 1 \lrcorner$ представляет этот текст (каким он бы не был) в оставшейся части регулярного выражения.

В выражение можно включить несколько пар круглых скобок и ссылаться на совпавший текст с помощью $\ulcorner \backslash 1 \lrcorner$ , $\ulcorner \backslash 2 \lrcorner$, $\ulcorner \backslash 3 \lrcorner$ и т.д. Пары скобок нумеруются в соответствии с порядковым номером открывающей скобки справа налево.

Пример. Пусть нам надо найти повторяющиеся слова. Если известно конкретное слово, то можно включить его в шаблон, например, $\ulcorner the\ the \lrcorner$. Но все пары слов проверить таким образом невозможно. Нам надо найти одно "обобщенное" слово, а потом указать искать то же самое. Заменим $\ulcorner the \lrcorner$ регулярным выражением для обобщенного слова - $\ulcorner \verb=[A-Za-z]\+= \lrcorner$ и запомним его в круглых скобках -  $\ulcorner \verb=\([A-Za-z]\+\)= \lrcorner$. Добавим выражение для пробелов - $\ulcorner _\sqcup \verb=\+= \lrcorner$. Теперь объединим полученные выражения и добавим обратную ссылку  $\ulcorner \verb=\([A-Za-z]\+\)= _\sqcup \verb=\+\1= \lrcorner$. И последнее - обозначим границы слов\footnote{Иначе будут найдены не только повторяющиеся слова, но и сочетания, когда буква, завершающая слово, является первой для следующего.} -  $\ulcorner \verb=\<\([A-Za-z]\+\)= _\sqcup \verb=\+\1\>= \lrcorner$.

\section{Экранирование}

Чтобы включить в выражение символ, который совпадает с метасимволом, необходимо выполнить \emph{экранирование}. Экранирование выполняется с помощью символа \verb+\+.

Например: метасимвол "точка" $\ulcorner . \lrcorner$ совпадает с любым символом. Чтобы получить обычную точку, надо записать $\ulcorner \verb+\.+ \lrcorner$, которая называется "экранированной" (escaped) точкой.

Экранирование может выполняться со всеми стандартными метасимволами, кроме метасимволов символьных классов.



\section{sed}

\emph{sed (sequential или stream editor)  неинтерактивный (поточный) редактор текста}. Он служит для выполнение анализа и преобразования текста. Фактически sed - это продвинутый текстовый фильтр. Имеет свой входной язык, тесно связанный с регулярными выражениями.

Очень удобен для использования в скриптах оболочек как средство обработки текстов.

Далее будет описываться GNU sed.

sed можно использовать двумя основными способами:
\begin{verbatim}
sed [-n] [-e] 'команды редактирования' входной_файл
\end{verbatim}
\begin{center}и\end{center}
\begin{verbatim}
sed [-n] -f сценарий входные_файлы
\end{verbatim}

Чаще используется первый способ.

Параметры:
\begin{itemize}
\item -f cmdfile  прочитать сценарий из файла
\item -n  блокирование вывода, кроме явно задаваемого из сценария 
\end{itemize}

Если команд несколько, то они разделяются \verb+;+.

Входные файлы: редактируемый входной поток. Если не указывать имя файла, то sed будет работать со стандартным вводом. Результат выводится в стандартный вывод и обычно перенаправляется в файл или конвейер. Если входных файлов несколько, то они объединяются в один буфер, с которым и идет потом работа. 

Строки в буфере пронумерованы. Если sed применяется к нескольким файлам, то номера строк будут продолжаться. Если первый файл содержит 200 строк, то адресом первой строки следующего файла будет 201. 

\emph{Примечание}. входные файлы \emph{не изменяются}.

\begin{center}
Схема работы:
\end{center}
Входные файлы (stdin) считываются в область шаблонов (pettern buffer), после этого к буферу последовательно применяются команды, и затем результат выводится для сохранения или дальнейшей обработки.

\emph{Внимание:} крайне не рекомендуется перенапрвлять результат в исходные файлы. Это приводит к непредсказуемым результатам.

\subsection{Общий вид команды}

\verb+[адрес1[, адрес2]] функция [аргументы]+

\emph{Функция}: представляет собой букву команды. Единственный обязательный параметр. Например \verb+'p'+.

\emph{Адрес}: может быть номер строки, регулярное выражение, \$ (последняя строка).

Если в адресе задается регулярное выражение, то оно задает все строки, соответствующие регулярному выражению. Регулярное выражение берется в \verb+/+ (прямой слэш), то есть \verb+/regexp/+.

Если не заданы адреса, то обрабатываются все строки буфера.

\emph{Адресный интервал} - это пара адресов, разделенная \verb+","+ и включающая все строки, начиная со строки, соответствующей первому адресу, до строки, соответствующей второму адресу включительно. Если второй адрес  раньше первого, то обрабатывается только первая строка, соответствующая первому адресу.

При добавлении символа \verb+!+ после адреса смысл меняется на противоположный: обрабатываются все строки, не лежащие в интервале.

Примеры: \verb+1,4; 1,$; 2,6!+.

\subsection{Команды sed}

Описаны только часто используемые команды.

\subsubsection{Замена} 

\verb+s/regexp/replacement/flags+. 

\verb+s+ - буква команды (замена, подстановка - substitute), \verb+regexp+ - строка поиска, то есть то, что заменится на \verb+replacement+. 

Флаги:
\begin{itemize}
\item \verb+g+  заменить все вхождения
\item \verb+w+ file  записать изменения в файл
\item \verb+p+  после замены вывести строку на экран (обычно используется с ключом sed \verb+-n+).      
\end{itemize}
\begin{verbatim}
Примеры: 
1. $ sed 's/sun/moon/g' myfile
2. $ sed '1,4 !s/sun/moon/g' myfile
3. $ echo Жужжали бабочки | sed -n 's/\(жж\)\(али\)/Гуж<&>\2\1/p'
# Результат: ЖуГуж<жжали>алижж бабочки
4. $ sed '/^Example/,/ED$/s/first/second/g' 
# если несколько совпадающих строк, то редактируются все вхождения.
5. $ sed 's/Sunday/Monday/gw' changes
# все Sunday заменяются
\end{verbatim}

\subsubsection{Удаление строк}
\verb+d+
\begin{verbatim}
Примеры: 
1. $ sed '4,5 d' file
2. $ sed '/sun/ !d' file.txt 
# удаление всех строк, кроме содержащих sun.
3. $ sed '/sun/,/moon/ d' myfile
# удаляется диапазон от первой строки, содержащей sun
до первой строки, содержащей moon
\end{verbatim}

\subsubsection{Вывод на экран}
\verb=p=  

Обычно используется с \verb+sed -n+ (иначе строки будут выводиться два раза).
\begin{verbatim}
Примеры: 
$ sed -n '/stroka/i !p'.
$ sed -n ' 1,4 p'
# вывести строки с 1 по 4 включительно
\end{verbatim}

\subsubsection{Трансляция символов} 

\verb+y/source_chars/dest_chars/+  

Замена символов по принципу "один к одному" (строки должны быть одной длины).
Пример:\verb+ $ sed 'y/abc/ABC/' file+

\subsubsection{Запись в файл} \verb+w file+ - пишет буфер в файл.

\subsubsection{Вставка файла} \verb+r file+ - вставка в выходной поток файла. Если его нет, то вставляется файл нулевой длины (без ошибки).

\subsubsection{Вставка строк} 
\begin{itemize}
\item \verb+адрес a+  помещает за обрабатываемой строкой
\item \verb+адрес i+  выводит до указанной строки
\end{itemize}

\emph{Примечание}: a и i разрешают использовать только один адрес.
\begin{verbatim}
Пример:
$ cat script
  3 a\
	Здесь добавлена\
	строка
$ who | sed -f script
 root
 stud1
 stud10
        Здесь добавлена
        строка
 stud11
\end{verbatim}                    

Символ экранирования \verb+"\"+ необходим, чтобы скрыть все символы конца строки кроме последнего.

