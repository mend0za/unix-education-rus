\chapter{Инструментальные средства разработчика}

\section{Компилятор Си}

Компилятор языка Си (C compliler или cc) - неотъемлемая часть системы. С него начинается разработка любой версии Unix или перенос на новую платформу существующей. Ядро и базовые утилиты системы написаны на Си\footnote{Более того, сам язык Си был создан для разработки ядра Unix. Авторы языка Си являются также первыми разработчиками Unix.}.

Компилятор реализован как утилита командной строки. Он вызывается командой \verb+cc+. Существует большое количество системных компиляторов Cи \footnote{В SUSv3(POSIX) опредено общее подмножество ключей и параметров, которые должен поддерживать компилятор Cи. Этому набору следуют все системные компиляторы. Естественно, что каждый из них имеет и свои дополнительные параметры.} (gcc в Linux и FreeBSD, собственные компиляторы в большинстве коммерческих версий Unix), поэтому \verb+cc+ будет указывать на компилятор по умолчанию для нашей системы. 

\begin{verbatim}
типовые ключи компилятора
$сс foo.c
компилирование и сборка (линковка) программы из 'foo.c' 
создаётся исполняемый файл 'a.out'

$cc -c foo.c
только компилировать. Будет получен объектный модуль 'foo.o'

$cc -o exec_foo foo.c
создается исполняемый файл 'exec_foo' (вместо 'a.out')

$cс foo.c bar.o
слинковать 2 объектных файла в исполняемый ('a.out')
\end{verbatim}


\section{make}

\emph{Make} - стандартное средство, применяемое для сборки программных проектов. Является универсальной программой для решения задач автоматической генерации и изменения файлов с учетом зависимостей.

Схема работы: make читает файл с описанием проекта (makefile) и, интерпретируя его содержание, выполняет определенные действия.

Makefile - текстовый файл, описывает отношения между файлами проекта и действия, необходимые для его сборки.

\subsection{Запуск}

Make является утилитой командной строки и запускается командой \verb+make+. При запуске \verb+make+ проверяет наличие файлов \verb+makefile+, \verb+Makefile+ и если и запускает на обработку первый из найденных Make-файлов. Можно явно указать какой Makefile использовать ключом \verb+-f+.

\subsection{Формат и использование make-файлов.}

Основной элемент - \emph{правила (rules)}.

\begin{verbatim}
Общий вид:
<цель 1> <цель 2> ?<цель n>:<зависимость 1> <завис-ть 2>?<завис-ть n>
        <команда 1>
        <команда 2>
        ?
        <команда n>
\end{verbatim}

\emph{Цель (target)} - некий желаемый результат, способ достижения которого описан в правиле. Цель может быть именем файла.

\emph{Примечание}. Перед командами вставляется табуляция, чтобы \verb+make+ отличал их от целей.

\begin{verbatim}
Пример1: цель как имя файла
iEdit: main.o Editor.o
         gcc main.o Editor.o -o iEdit
Пример описывает, как можно получить исполняемый файл из объектных модулей.
\end{verbatim}

Цель может быть именем некоторого действия, тогда правило описывает, как совершается указанное действие.
\begin{verbatim}
Пример2: цель как имя действия
clean:
        rm *.o iEdit
\end{verbatim}

Такие цели называют \emph{абстрактными} (phony targets) или псевдоцелями (pseudo targets).

\emph{Зависимость (dependency)} - это 'исходные данные', необходимые для достижения указанной в правиле цели. Это предварительные условия достижения цели. Зависимостью может быть имя файла или имя действия. В примере1 main.o и Editor.o - зависимости. Файлы должны существовать, чтобы можно было собрать iEdit.
\begin{verbatim}
Пример3:
clean_all: clean_obj
        rm iEdit
clean_obj:
        rm *.o
 Для достижения сlean_all необходимо выполнить действие clean_obj.
\end{verbatim}

\emph{Команда} - действия, которые надо выполнить для обновления или достижения цели. Перед командой должен быть символ табуляции (код 9). Так make определяет команды.

Типичный makefile, который содержит несколько правил, у каждого правила есть некоторая цель и зависимости.
\begin{verbatim}
Пример4: 
1. 	iEdit: main.o Editor.o
2.              gcc main.o Editor.o -o iEdit
3.       main.o: main.cpp
4. 	        gcc -c main.cpp
5.	Editor.o: Editor.cpp
6.	        gcc - Editor.cpp
7.	clean:
8.	        rm *.c
\end{verbatim}

Смысл работы - достижение главной цели (default goal). Если  цель - имя действия (абстрактная), то выполняется действие. Если главная цель - имя файла, то make строит самую свежую версию. Главная цель обычно задается как параметр make: make iEdit, make clean. Если make вызывается без параметров, то в качестве главной берется первая встреченная цель. (В примере  это iEdit). Обычно задают цель \emph{all} как цель по умолчанию.

Алгоритм работы:
\begin{enumerate}
	\item выбор главной цели
	\item достижение цели
	\item обработка правил
	\item обработка зависимостей
\end{enumerate}

Достижение цели - проверяет зависимости и потом определяет, надо ли запускать команды.
При вызове make iEdit определяет, что главная цель - iEdit. Правило ее достижения - строки 1,2. Обрабатывая правило iEdit, определяем, что зависит от main.o и Editor.o. Для этих зависимостей существуют правила (3,4) и (5,6). main.o зависит от main.cpp. Если нет еще объектного файла, но существует файл .срр, то запускается компиляция. Аналогично и для Editor.o. Для clean зависимостей нет и make сразу переходит к выполнению.

\emph{Инкрементная сборка} - перекомпилируется только то, что было изменено. Для файлов .с и .срр обычно указываются как зависимости .h файлы.

\subsection{Переменные make.}

Присвоение: \verb+имя = строка+ (можно с пробелами). 

Получение значения переменной: \verb+$(имя)+. Значение - текстовая строка, может содержать ссылки на другие переменные.
\begin{verbatim}
Пример: 
obj_list = main.o Editor.o 
# присвоение; 

$(obj_list) 
# получение значения

1)dir_list = . .. src/include
all:
        echo $(dir_list) 
2)optimize_flags  = -03
compile_flags = $(optimize_flags) -pipe
all:
        echo $(compile_flags)
Результат: -03 -pipe
3)program_name = iEdit
obj_list = main.o Editor.o TextLine.o
$(program_name) : $(obj_list)
        gcc $(obj_list) -o $(program_name)
\end{verbatim}

\emph{Примечание}. Значение переменной вычисляется в момент использования.

Часто используемые переменные:
\begin{enumerate}
\item \verb+CC+ - указать компилятор по умолчанию.
\item \verb+CFLAGS+ - параметры компиляции
\item \verb+LDFLAGS+ - параметры линковки объектных файлов
\end{enumerate}

\subsubsection{Автоматические переменные}

\emph{}
\begin{itemize}
\item \verb+$^+ - список зависимостей, разделённых пробелами
\item \verb+$@+ - имя цели (файла). Если у нас несколько целей (см \ref{PatternRules}), эта переменная принимает значение той цели, для которой выполняется шаблон в конкетный запуск
\item \verb+$<+ - имя первой зависимости
\end{itemize}
\begin{verbatim}
Пример:
$(program_name):$(obj_name)
        gcc $^ -o $@
\end{verbatim}

\subsection{Шаблонные правила}
\label{PatternRules}
Шаблонные правила (implicit или pattern rules) применяются к группе файлов.

Синтаксис: 
\begin{verbatim}
.<расширение_файлов_завис.> .<расширение_файлов_целей>:
        <команда 1>
        <команда 2>
        ?
        <команда n>	
\end{verbatim}
\begin{verbatim}
Пример:
.cpp .o:
      gcc -c $^
\end{verbatim}


\section{Системы управления версиями. CVS}

Очень часто над программой работает больше одного человека. Выходят различные версии программ.  И существует потребность как то упорядочивать внесение изменений и дополнений. Для этого служат системы управления версиями. Из используемых сейчас можно назвать CVS, Subversion, RCS, Monotone, Arch, GIT и SourceSafe. 

\verb+CVS+ - \emph{Conhurent Versions Systems} (система управления конкурирующими версиями). 

\subsection{Репозиторий}

\emph{Репозиторий CVS (или хранилище)} хранит полную копию всех файлов и каталогов под управлением CVS,  включая все сделанные

Обычно Вы никогда не получаете доступ к файлам в CVS напрямую. Используются команды CVS для получения копии в "рабочий каталог" и далее работа идёт над копией. 
После внесения изменений - юзер вносит изменения в репозиторий. После этого, в хранилище сохраняется информация о сделанных изменениях, времени внесения изменений и другая подобная информация.

Для указания, какой из репозиторев используется - применяется переменная окружения CVSROOT, либо явно указывается с помощью ключа -d.

Примеры:
\begin{verbatim}
$ CVSROOT=/var/cvs; export CVSROOT
$ cvs checkout module/project
или
$ cvs -d /var/cvs module/project
\end{verbatim}

Кроме локальных репозиториев - очень часто используются удалённые (сетевые). Для них необходимо указать адрес и (иногда) - способ доступа.
\begin{verbatim}
$ cvs -d server1:/root checkout sdir1
\end{verbatim}

Подробнее об этом - в \ref{cvsbook} или в её русском переводе на http://opennet.ru

\subsection{Получение рабочей копии исходников}


\subsection{Сохранение результатов и версионирование}

\subsection{Коллективная работа над проектом}



\section{Библиотека Си (libc)}

libc содержит 2 части: \emph{системные вызовы} и \emph{библиотечные функции}. 

Системные вызовы определены, как функции языка Си (независимы от фактической реализации в ядре). В UNIX каждый системный вызов имеет соответствующую функцию (или функции) с тем же именем, хранящуюся в стандартной библиотеке Си. Функции из библиотеки выполняют преобразования аргументов и вызов соответствующего кода ядра. Таким образом, библиотечный код - только оболочка, фактические инструкции находятся в ядре.

Функции общего значения - также часть библиотеки, но не являются системными вызовами. Функции общего назначения и системные вызовы - основа среды программирования UNIX.

В отличие от других библиотек, libc линкуется с каждым приложением, написанном на Си.

Информация о системных вызовах и функциях содержится в 2 и 3 разделах \verb+man+ соотвественно. В различных системах различный набор системных вызовов, поэтому некоторые функции могут быть реализованы как библиотечные в одной системе и как системные вызовы в другой. 

libc полностью включает в себя библиотеки, определенные в ANSI C (stdio, math, assert). Как следствие: один из основных методов сделать программу переносимой - это написать ее на ANSI C. Такая программа будет компилироваться и работать на всех unix-системах.

Подробнее интерфейсы libc будут рассмотрены в главах, посвященных архитектуре и межпроцессному взаимодействию.
