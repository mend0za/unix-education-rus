\chapter{Среда программирования Unix}

\section{Unix-way программирования}

\section{Unix как единая среда разработки (IDE)}
Из высказывания в ru.unix.prog  Алексея Махоткина из ru.unix.prog FAQ :
\begin{quote}
 >> Q: Какие есть IDE (integrated development environments) под Unix?  Hу\\
 >> чтобы компилятор, среда редактирования, отладчик и прочее - были все\\
 >> вместе?\\
 
\dots

UNIX сам по себе является Integrated Development Environment.

В "обычных" IDE есть бинарник-интегратор, который вызывает в лучшем случае
внешние утилиты, а в худшем случае -- свою реализацию каждой функцию из DLL
или прямо зашитую в бинарник.

В UNIX таким бинарником-интегратором является shell (Emacs считается
shell'ом в данном случае).  Для выполнения каждой функции вызываются
специально написанные динамически выполняемые модули, такие как make, cc,
ld, и т. д.

Преимущество в этом такое же, как преимущество математических функций
высшего порядка перед "обычными" функциями.

Hапример, функция "отслеживать зависимости" чаще всего реализуется с
помощью make, но можно также легко использовать, скажем, cook, или же
переключаться между GNU Make и BSD Make по вкусу.  Точно такая ситуация с
используемыми редактором, компилятором, etc.  Более того, сам по себе shell
является "функцией высшего порядка", и легко может быть заменен.

Кроме того, так как пространство функций практически неограниченно, то IDE
"Unix" обеспечивает также заранее не предусмотренные функции высшего
порядка, например, различную автогенерацию кода, поддержку тестирования и
т. п.
\end{quote}

Другими словами, командная строка Unix (shell) и является IDE для Unix. Подобный подход позволяет не зацикливаться на програмных решениях одного производителя (разработчика). Любой компонент, воспринимаемый как часть IDE (компилятор, отладчик, компоновщик, редактор, ассемблер, утилиты сборки и тестирования проекта, система контроля версий) может быть заменен на другой. Эти компоненты мы условно можем назвать \emph{Инструментальные средства Unix}.

\section{Низкоуровневый доступ к системе}

Базой UNIX-системы является компилятор Си (сс), библиотека libc  и ядро.

Все версии UNIX предоставляют строго определенный, ограниченный набор входов в ядро ОС, через которые прикладные задачи получают доступ к базовым услугам UNIX. Эти точки входа называются \emph{системными вызовами (system calls)}.

Системный вызов определяет функцию, выполняемую ядром ОС от имени процесса, выполнившего вызов. Syscall является интерфейсом самого низкого уровня взаимодействия прикладных процессов с ядром.

Язык системного программирования - Си. Характерная особенность Unix - ассемблер практически не используется. Более того, часть прерываний и регистров просто недоступна из program space. Ассемблер применяется только для написания драйверов устройств и ядра (платформенно-зависимые их части). 

Библиотека \emph{libc} - это набор интерфейсов к системным вызовам и различных функций, работающих поверх системных вызовов. Для программиста различие между \emph{системным вызовом} и \emph{библиотечной функцией} лишь в том, как они взаимодействуют с ядром. Системный вызов сразу уходит в пространство ядра и там выполняется. Библиотечная функция выполняется в пространстве процесса (хотя конечно может и делать системные вызовы в ходе выполнения).


\section{Принципы разработки программ для Unix}
\begin{quote}
Чтобы плавать, надо плавать. Мао Цзе Дун (из красных книжечек председателя Мао)
\end{quote}
За 30 лет существования вокруг Unix сформировалась своя культура: слэнг, традиции и опыт, передаваемый между поколениями программистов. Принципы - это набор философских высказываний, подводящий итоги и суммирующий опыт тысяч человеко-лет разработки.

Из Tao Of The Unix Programming (by Eric S. Raymond):
\begin{itemize}
\item Правило модульности: Пишите простые части, соединяемые ясными интерфейсами.
\item Правило ясности: Ясность лучше чем изощренность.
\item Правило соединения: Проектируйте программы чтобы они могли взаимодействовать с другими программами.
\item Правило разделения: Отделяйте алгоритмы от механизмов и интерфейсы от движков.
\item Правило простоты: Разрабатывайте просто. Используйте сложные конструкции только тогда, когда без этого не обойтись.
\item Правило умеренности: Пишите большую программу, только если ясно, что больше ничего не поможет.
\item Правило прозрачности: Пишите наглядно, чтобы сделать просмотр и отладку программы легче.
\item Правило надежности: Надежность - следствие ясности и простоты.
\item Правило представления: Храните знания в данных, а программная логика должна быть надежной и тупой.
\item Правило наименьшего удивления: Когда разрабатываете интерфейсы, делайте их как можно более предсказуемыми.
\item Правило тишины: Когда программе нечего сказать нового, она должна молчать.
\item Правило восстановления: Когда программа должна ошибиться, она должна шумно и долго об этом вопить. Настолько часто, насколько это возможно.
\item Правило экономии: Время программиста - дорогое, экономьте его, взваливая как можно больше задач на компьютер (автоматизация).
\item Правило генерации кода: Избегайте ручного кодирования. Пишите программы для генерации других программ всегда, когда возможно.
\item Правило оптимизации: Делайте прототипы перед полировкой кода. Заставьте код работать, прежде чем оптимизировать.
\item Правило многообразия: Не доверяйте всем претензиям на "единственно верное решение"
\item Правило рамширяемости: Проектируйте с прицелом на будущее. Оно может наступить быстрее чем вы думаете.
\end{itemize}

Философия Unix в одном уроке.

\emph{keep It Simple, Stupid - оставь это простым, тупица.}

