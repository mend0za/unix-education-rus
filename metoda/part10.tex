\chapter{Процессы и сигналы.IPC}

В UNIX процессы выполняются в собственном адресном пространстве и
изолированы друг от друга, таким образом сведены к минимуму
возможности влияния процессов друг на друга.

Но существует необходимость взаимодействия процессов. Для этого
требуется:
\begin{itemize}
\item обеспечить средства взаимодействия
\item исключить нежелательное влияние одного процесса на другой
\end{itemize}

Взаимодействие решает следующие задачи:
\begin{enumerate}
\item передача данных
\item совместное использование данных
\item извещения
\end{enumerate}

Решать проблему взаимодействия средствами процессов в рамках
многозадачной системы опасно.

\subsection{Типы IPC}
\begin{itemize}
 \item сигналы
 \item каналы
 \item FIFO (именованные каналы)
 \item 0x08 graphic
 \item 0x08 graphic
 \item сообщения (очереди сообщений)
 \item семафоры
 \item разделяемая память
 \item сокеты
\end{itemize}
       
\subsection{Сигналы}

Простейший вид IPC. Позволяют уведомлять процесс или группу процессов
о наступлении некоторого события.

Группа процессов - любой процесс принадлежит определенной группе
процессов. У каждой группы есть свой уникальный идентификатор. Лидер
группы - процесс, PID которого совпадает с ID группы. Обычно группа
наследуется процессом от родителя.

Процесс может покинуть группу и создать свою.

Управляющий терминал - процесс может быть связан с терминалом, который
называется управляющим. Все процессы группы имеют один и тот же
управляющий терминал.

Специальный файл устройства /dev/tty- связан с управляющим терминалом
процесса. Драйвер для этого псевдоустройства перенаправляет запросы на
фактический терминальный драйвер, который может быть различным для
разных процессов.

Сигнал - механизм вызова определенной процедуры при наступлении
некоторого события.

Есть две фазы в использовании сигналов: генерация (отправление),
доставка и обработка. В промежутке - ожидание доставки.

Примечание: сигналы не могут накапливаться, то есть в любой конкретный
момент времени дожидаться обработки могут только разнотипные сигналы.

Причины оправления сигналов:

  * особые ситуации (например, деление на 0)
  * терминальные прерывания (нажатия клавиш Del, Ctrl+Z, Ctrl+C,
    отключение терминала)
  * другие процессы
  * управление заданиями (для командных интерпретаторов)
  * квоты (превышение процессом квот)
  * уведомления (процесс запрашивает информацию о готовности
    устройства)
  * алармы.

Над сигналами можно выполнить три действия:

 1. изменение реакции на сигнал (обработка)
 2. блокирование сигнала - откладывание обработки на время выполнения
    критических участков кода
 3. посылка сигнала.

Примечание: сигналы не могут непосредственно переносить информацию.

Каждому сигналу присвоено мнемоническое имя (например, SIGINT),
которое указывает, для чего обычно используется сигнал этого типа.
Имена сигналов определены в <signal.h>.

Посылка сигналов:

#include<sys/types.h>

#include<signal.h>

int kill (pid_t pid, int sig);

Пример: kill (7421, SIGTERM).

Процесс может посылать сигналы самому себе.

Получение своего PID - pid=getpid();

Получение своего PPID - ppid=getppid();

Ограничения: EUID или RID процесса, посылающего сигнал, должны
совпадать с EUID и RID процесса-адресата. Для администратора таких
ограничений нет.

При неудачном вызове kill возвращает -1 и переменной errno
присваивается значения: EPERM (нельзя послать чужому процессу), ESRCH
(такого процесса нет) , EINVAL (sig содержит неверный номер сигнала).

Смысл параметра PID:

Pid==0 - сигнал посылается всем процессам группы, к которой
принадлежит процесс, пославший сигнал;

Pid==-1 и если EUID не администратора, то посылается всем процессам,
RID которых равен EUID посылающего процесса, включая и его (если его
RID=EUID);

Pid==-1 и EUID администратора, то сигнал посылается всем процессам,
кроме некоторых системных;

Pid<0 и не равен -1 - посылается всем процессам, идентификатор группы
которых равен по модулю PID, включая пославший процесс, если он также
входит в эту группу.

Посылка самому себе:

#include<signal.h>

int raise (int sig) - вызывающему процессу посылается сигнал. В случае
успеха возвращает 0. Например, raise (SIGKILL).

setitimer - установка разных таймеров (3 вида).

#include<unistd.h>

unsigned int alarm (unsigned int secs);

secs - время в секундах, на которое устанавливается таймер. После
истечения времени процессу посылается SIGALRM.

Пример: alarm(60).

Выключение таймера alarm(0).

Вызов таймера не накапливается. Вызов следующего отменяет предыдущий.

#include<unistd.h>

int pause (void) - приостанавливает выполнение процесса до получения
любого сигнала, часто используется вместе с alarm.

                  Нормальное и аварийное завершение.

Большинство сигналов вызывают нормальное завершение (normal
termination). Похоже на вызов процессом функции exit.

Некоторые сигналы ( SIGABRT, SIGBUS, SIGQUIT, SIGILL и другие)
инициируют аварийное завершение со сбросом значения переменных,
регистров и т.д. в core (dump).

                    Имена сигналов (по алфавиту).

<signal.h>

SIGABRT - прерывание процесса (abort), посылается процессу при вызове
системного вызова abort. Core dump.

SIGALRM - сигнал таймера.

SIGBUS - аппаратная ошибка на шине. Аварийное завершение.

SIGCHLD - останов или завершение дочернего процесса. Игнорируется.

SIGCONT - продолжение работы остановленного процесса (обратный для
SIGSTOP).

SIGHUP - освобождение линии, посылается процессам, подключенным к
терминальной линии, при отключении терминала или при завершении работы
лидера сеанса членам группы.

SIGILL - недопустимая команда процессора. Core dump.

SIGINT - нормальное прерывание программы (Сtrl+C). Посылается всем
процессам сеанса.

SIGKILL - немедленное уничтожение процесса. Не перехватывается.

SIGPIPE - попытка записи в канал или сокет, для которого принимающий
процесс уже завершил работу.

SIGPROF - сигнал профилирующего таймера.

SIGQUIT - завершение программы. Похож на SIGINT, но завершение
аварийное.

SIGSEGV - некорректный адрес памяти. Аварийный сброс.

SIGSTOP - сигнал останова. Управление заданиями. Нельзя перехватить.

SIGSYS - ошибочный системный вызов.

SIGTERM - программный сигнал завершения. Используется для корректного
завершения процесса.

SIGTSTP - терминальный сигнал остановки (Сtrl+Z). Похож на SIGSTOP, но
можно перехватить.

SIGTTIN - попытка ввода с терминала фоновым процессом. Остановка
процесса.

SIGTTOU - попытка вывода на терминал фоновым процессом. Остановка
процесса.

SIGURG - поступление в буфер сокета срочных внеочередных данных.

0x08 graphic
0x08 graphic
SIGUBR1

SIGUBR2

SIGVTALRM - виртуальный таймер.

SIGXCPU - превышение лимита процессорного времени. Core dump.

SIGXFSZ - превышение лимита на размер файла.

                           Наборы сигналов.

Набор сигналов - это список сигналов, которые необходимо передать
системному вызову.

Тип sigset_t в <signal.h>, его размер позволяет поместиться всем
сигналам, определенным в системе.

Выбор сигналов - либо из полного, удаляя ненужные, либо из пустого
набора, добавляя необходимые.

Инициализация набора:

#include <signal.h>

int sigemptyset(sigset_t *set);

int sigfillset(sigset_t *set);

Добавление и удаление сигналов:

int sigaddset(sigset_t *set, int signo);

int sigdelset(sigset_t *set, int signo);

Пример:

sigset_t mask1, mask2;

sigemptyset(&mask1);

sigaddset(&mask1, SIGINT);

sigaddset(&mask1, SIGQUIT);

sigfillset(&mask2);

sigdekset(&mask2, SIGCHLD);

                         Обработчик сигналов.

После определения списка можно задать обработку сигналов:

#include<signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction
*oact);

signo - сигнал, для которого задается действие.

act - определяем обработчик.

oact - если не NULL, то в эту структуру сохранится старый обработчик.

struct sigaction {

void (*sa_handler)(int); //функция обработчика

sigset_t sa_mask; //сигналы, блокируемые во время обработки данного

int sa_flags; //флаги, влияющие на поведение сигнала

viod (*sa_sigaction)(int, siginfo_t*, void*);

};

Толкование:

- sa_handler:

 1. SIG_DFL - константа обработки по умолчанию.
 2. SIG_IGN - константа игнорирования. Не может применятся для SIGSTOP
    и SIGKILL.
 3. Адрес функции, принимающей аргумент типа int (sa_handler=f1). Она
    будет вызываться при получении сигнала, а signo передается как
    параметр.

Управление передается функции из любого места программы, а после
возврата из нее выполнение будет продолжено с точки, в которой было
прервано.

  * sa_mask - сигналы из этого набора будут игнорироваться во время
    выполнения функции-обработчика (sa_handler).
  * sa_flags - изменение характера реакции:

 1. SA_RESETHAND - после возврата из обработчика вернуть обработчик по
    умолчанию SIG_DFL.
 2. SA_SIGINFO - обработчику передается дополнительная информация и
    вместо sa_handler используется sa_sigaction.
 3. SA_RESTART - повтор прерванного сигналом системного вызова.

               Ненадежные сигналы (устаревшая версия).

#include<signal.h>

void (*signal(int sig, void(*disp)(int))) (int);

sig - номер сигнала.

disp - SIG_DFL, SIG_IGN или функция-обработчик.

Пример: signal(SIGINT, SIG_IGN);

                        Блокирование сигналов.

int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

- how - указывается, какое действие надо выполнить:

 1. SIG_MASK - установить блокирование сигналов по списку;
 2. SIG_UNBLOCK - отмена блокирования сигналов по списку;
 3. SIG_BLOCK - добавление списка к текущим блокируемым.

  * set - набор сигналов.
  * oset - старый набор. Если не равен NULL, то в него заносится
    значение.

Пример:

sigset_t set1;

sigfillset(&set1);

sigprocmask(SIG_SETMASK, &set1, NULL);

//критический участок - непрерываемый

sigprocmask(SIG_UNBLOCK, &set, NULL);

Примечание: можно варьировать наборы и степень защищенности кода.

