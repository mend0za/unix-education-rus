\chapter{Процессы и сигналы.IPC}

В UNIX процессы выполняются в собственном адресном пространстве и изолированы друг от друга, таким образом сведены к минимуму
возможности влияния процессов друг на друга.

Но существует необходимость взаимодействия процессов. Для этого требуется:
\begin{itemize}
\item обеспечить средства взаимодействия
\item исключить нежелательное влияние одного процесса на другой
\end{itemize}

Взаимодействие решает следующие задачи:
\begin{enumerate}
\item передача данных
\item совместное использование данных
\item извещения
\end{enumerate}

Решать проблему взаимодействия средствами процессов в рамках многозадачной системы опасно.

\section{Типы IPC}
\begin{itemize}
 \item сигналы
 \item каналы
 \item FIFO (именованные каналы)
 \item сообщения (очереди сообщений)
 \item семафоры
 \item разделяемая память
 \item сокеты
\end{itemize}
       
\section{Сигналы}

Простейший вид IPC. Позволяют уведомлять процесс или группу процессов о наступлении некоторого события.

\emph{Группа процессов} - любой процесс принадлежит определенной группе процессов. У каждой группы есть свой уникальный идентификатор. Лидер группы - процесс, PID которого совпадает с ID группы. Обычно группа наследуется процессом от родителя.

Процесс может покинуть группу и создать свою.

\emph{Управляющий терминал} - процесс может быть связан с терминалом, который называется управляющим. Все процессы группы имеют один и тот же управляющий терминал.

Специальный файл устройства \verb+/dev/tty+ связан с управляющим терминалом процесса. Драйвер для этого псевдоустройства перенаправляет запросы на фактический терминальный драйвер, который может быть различным для разных процессов.

\emph{Сигнал} - механизм вызова определенной процедуры при наступлении некоторого события.

Есть две фазы в использовании сигналов: генерация (отправление), доставка и обработка. В промежутке - ожидание доставки.

\emph{Примечание}: сигналы не могут накапливаться, то есть в любой конкретный момент времени дожидаться обработки могут только разнотипные сигналы.

Причины оправления сигналов:
\begin{itemize}
\item особые ситуации (например, деление на 0)
\item терминальные прерывания (нажатия клавиш Del, Ctrl+Z, Ctrl+C, отключение терминала)
\item другие процессы
\item управление заданиями (для командных интерпретаторов)
\item квоты (превышение процессом квот)
\item уведомления (процесс запрашивает информацию о готовности устройства)
\item алармы.
\end{itemize}

Над сигналами можно выполнить три действия:
\begin{enumerate}
\item изменение реакции на сигнал (обработка)
\item блокирование сигнала - откладывание обработки на время выполнения критических участков кода
\item посылка сигнала.
\end{enumerate}

\emph{Примечание:} сигналы не могут непосредственно переносить информацию.

Каждому сигналу присвоено мнемоническое имя (например, SIGINT), которое указывает, для чего обычно используется сигнал этого типа.  Имена сигналов определены в \verb+<signal.h>+.

\subsection{Посылка сигналов}

\begin{verbatim}
#include<sys/types.h>
#include<signal.h>

int kill (pid_t pid, int sig);
\end{verbatim}

\verb+Пример: kill (7421, SIGTERM)+.

Процесс может посылать сигналы самому себе.

Получение своего PID (\ref{pid}) - \verb+pid=getpid();+ 

Получение своего PPID (\ref{ppid}) - \verb+ppid=getppid();+

Ограничения: EUID (\ref{euid}) или RID (\ref{rid}) процесса, посылающего сигнал, должны совпадать с EUID и RID процесса-адресата. Для администратора таких ограничений нет.

При неудачном вызове kill возвращает -1 и переменной errno присваивается значения: EPERM (нельзя послать чужому процессу), ESRCH (такого процесса нет) , EINVAL (sig содержит неверный номер сигнала).

\subsubsection{Смысл параметра PID}

Pid==0 - сигнал посылается всем процессам группы, к которой принадлежит процесс, пославший сигнал;

Pid==-1 и если EUID не администратора, то посылается всем процессам, RID которых равен EUID посылающего процесса, включая и его (если его RID=EUID);

Pid==-1 и EUID администратора, то сигнал посылается всем процессам, кроме некоторых системных;

Pid<0 и не равен -1 - посылается всем процессам, идентификатор группы которых равен по модулю PID, включая пославший процесс, если он также входит в эту группу.

\subsubsection{Посылка сигнала самому себе}

\begin{verbatim}
#include<signal.h>

int raise (int sig)
\end{verbatim}
вызывающему процессу посылается сигнал. В случае успеха возвращает 0. Например, \verb+raise (SIGKILL)+.

\subsection{Таймеры}

\verb+setitimer+ - установка разных таймеров (3 вида).

\begin{verbatim}
#include<unistd.h>

unsigned int alarm (unsigned int secs);
\end{verbatim}

\verb+secs+ - время в секундах, на которое устанавливается таймер. После истечения времени процессу посылается \verb+SIGALRM+.

\verb+Пример: alarm(60).+

\emph{Выключение таймера} \verb+alarm(0).+

Вызов таймера не накапливается. Вызов следующего отменяет предыдущий.

\begin{verbatim}
#include<unistd.h>

int pause (void);
\end{verbatim} 
приостанавливает выполнение процесса до получения любого сигнала, часто используется вместе с \verb+alarm+.

\subsection{Нормальное и аварийное завершение}

Большинство сигналов вызывают нормальное завершение (normal termination). Похоже на вызов процессом функции \verb+exit+.

Некоторые сигналы ( SIGABRT, SIGBUS, SIGQUIT, SIGILL и другие) инициируют аварийное завершение со сбросом значения переменных, регистров и т.д. в core (dump).

\subsection{Имена сигналов (по алфавиту, выборочно)}

Определены в \verb+<signal.h>+
\begin{itemize}
\item SIGABRT - прерывание процесса (abort), посылается процессу при вызове системного вызова abort. Core dump.
\item SIGALRM - сигнал таймера.
\item SIGBUS - аппаратная ошибка на шине. Аварийное завершение.
\item SIGCHLD - останов или завершение дочернего процесса. Игнорируется.
\item SIGCONT - продолжение работы остановленного процесса (обратный для SIGSTOP).
\item SIGHUP - освобождение линии, посылается процессам, подключенным к терминальной линии, при отключении терминала или при завершении работы лидера сеанса членам группы.
\item SIGILL - недопустимая команда процессора. Core dump.
\item SIGINT - нормальное прерывание программы (Сtrl+C). Посылается всем процессам сеанса.
\item SIGKILL - немедленное уничтожение процесса. Не перехватывается.
\item SIGPIPE - попытка записи в канал или сокет, для которого принимающий процесс уже завершил работу.
\item SIGPROF - сигнал профилирующего таймера.
\item SIGQUIT - завершение программы. Похож на SIGINT, но завершение аварийное.
\item SIGSEGV - некорректный адрес памяти. Аварийный сброс.
\item SIGSTOP - сигнал останова. Управление заданиями. Нельзя перехватить.
\item SIGSYS - ошибочный системный вызов.
\item SIGTERM - программный сигнал завершения. Используется для корректного завершения процесса.
\item SIGTSTP - терминальный сигнал остановки (Сtrl+Z). Похож на SIGSTOP, но можно перехватить.
\item SIGTTIN - попытка ввода с терминала фоновым процессом. Остановка процесса.
\item SIGTTOU - попытка вывода на терминал фоновым процессом. Остановка процесса.
\item SIGURG - поступление в буфер сокета срочных внеочередных данных.
\item SIGUSR1, SIGUSR2 - зарезервированы для пользовательских задач. По умолчанию - ничего не происходит.
\item SIGVTALRM - виртуальный таймер.
\item SIGXCPU - превышение лимита процессорного времени. Core dump.
\item SIGXFSZ - превышение лимита на размер файла.
\end{itemize}
            
\subsection{Наборы сигналов}
\label{sigset}
\emph{Набор сигналов} - это список сигналов, которые необходимо передать системному вызову.

Тип \verb+sigset_t+ в \verb+<signal.h>+, его размер позволяет поместиться всем сигналам, определенным в системе.

Выбор сигналов - либо из полного, удаляя ненужные, либо из пустого набора, добавляя необходимые.

\subsubsection{Инициализация набора}

\begin{verbatim}
#include <signal.h>

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
\end{verbatim}

\subsubsection{Добавление и удаление сигналов}

\begin{verbatim}
int sigaddset(sigset_t *set, int signo);

int sigdelset(sigset_t *set, int signo);
\end{verbatim}

\subsubsection{Типовой сценарий работы с набором}
\begin{verbatim}
sigset_t mask1, mask2;

sigemptyset(&mask1);

sigaddset(&mask1, SIGINT);
sigaddset(&mask1, SIGQUIT);

sigfillset(&mask2);
sigdelset(&mask2, SIGCHLD);
\end{verbatim}

\subsection{Обработчик сигналов}

После определения списка можно задать обработку сигналов:

\begin{verbatim}
#include<signal.h>

int sigaction(int signo, const struct sigaction *act, struct sigaction
*oact);
\end{verbatim}

\verb+signo+ - сигнал, для которого задается действие.

\verb+act+ - определяем обработчик.

\verb+oact+ - если не NULL, то в эту структуру сохранится старый обработчик.

\subsection{Разбор структуры sigaction}

\begin{verbatim}
struct sigaction {
void (*sa_handler)(int); //функция обработчика
sigset_t sa_mask; //сигналы, блокируемые во время обработки данного
int sa_flags; //флаги, влияющие на поведение сигнала
viod (*sa_sigaction)(int, siginfo_t*, void*);
};
\end{verbatim}

Толкование:

\verb+sa_handler:+
\begin{enumerate}
\item \verb+SIG_DFL+ - константа обработки по умолчанию.
\item \verb+SIG_IGN+ - константа игнорирования. Не может применятся для SIGSTOP и SIGKILL.
\item Адрес функции, принимающей аргумент типа \verb+int+ (\verb+sa_handler=f1+). Она будет вызываться при получении сигнала, а signo передается как параметр.
\end{enumerate}

Управление передается функции из любого места программы, а после возврата из нее выполнение будет продолжено с точки, в которой было прервано.
\begin{itemize}
\item \verb+sa_mask+ - сигналы из этого набора будут игнорироваться во время выполнения функции-обработчика (\verb+sa_handler+).
\item \verb+sa_flags+ - изменение характера реакции:
\end{itemize}

\begin{enumerate}
\item \verb+SA_RESETHAND+ - после возврата из обработчика вернуть обработчик по умолчанию \verb+SIG_DFL+.
\item \verb+SA_SIGINFO+ - обработчику передается дополнительная информация и вместо \verb+sa_handler+ используется \verb+sa_sigaction+.
\item \verb+SA_RESTART+ - повтор прерванного сигналом системного вызова.
\end{enumerate}

\subsection{Ненадежные сигналы (устаревшая версия)}

\begin{verbatim}
#include<signal.h>

void (*signal(int sig, void(*disp)(int))) (int);
\end{verbatim}
\verb+sig+ - номер сигнала.

\verb+disp+ - \verb+SIG_DFL, SIG_IGN+ или функция-обработчик.

\verb+Пример: signal(SIGINT, SIG_IGN);+

\subsection{Блокирование сигналов}

\verb+int sigprocmask(int how, const sigset_t *set, sigset_t *oset);+
\begin{itemize}
\item \verb+how+ - указывается, какое действие надо выполнить:
	\begin{enumerate}
		\item \verb+SIG_MASK+ - установить блокирование сигналов по списку;
		\item \verb+SIG_UNBLOCK+ - отмена блокирования сигналов по списку;
		\item \verb+SIG_BLOCK+ - добавление списка к текущим блокируемым.
	\end{enumerate}
\item \verb+set+ - набор сигналов.
%\item \verb+oset+ - старый набор. Если не равен NULL, то в него заносится значение.
\end{itemize}

\begin{verbatim}
Пример:

sigset_t set1;

sigfillset(&set1);

sigprocmask(SIG_SETMASK, &set1, NULL);

//критический участок - непрерываемый

sigprocmask(SIG_UNBLOCK, &set, NULL);
\end{verbatim}

\emph{Примечание:} можно варьировать наборы и степень защищенности кода.

