\chapter{Процессы}

\emph{Процесс} - это экземпляр выполняющейся программы.

Программа - совокупность файлов, будь то исходники, объектные файлы либо выполняемый файл.

Для запуска программы  на выполнение ОС  должна создать \emph{окружение} или среду выполнения задачи, куда относится ресурсы памяти, возможность доступа к устройствам ввода/вывода и различным системным ресурсам.

Процесс состоит из инструкций, выполняемых процессором, данных и информации о выполняемой задаче, такой, как размещенная память, открытые файлы и статус процесса.

Программа может породить более одного процесса. Пользователи могут запускать несколько экземпляров одной программы. Например, количество BASH - эквивалентно числу пользователей. Таким образом UNIX - многозадачная ОС.

Выполнение процесса заключается в точном следовании набору инструкций, который никогда не передает управление набору инструкций другого процесса. Процесс взаимодействует со своими данными и стеком, но ему не доступны чужие данные и стек. 

Процессы изолированы друг от друга. В то же время, процессы имеют возможность обмениваться друг с другом данными с помощью системы межпроцессного взаимодействия \emph{(IPC)}.

Виды IPC:
\begin{enumerate}
\item сигналы
\item каналы
\item разделяемая память
\item семафоры
\item сообщения
\item файлы.
\end{enumerate}

\section{Типы процессов}

\subsection{Системные процессы}

\emph{Системные процессы} являются частью ядра и всегда расположены в оперативной памяти. Системные процессы не имеют соответствующих им программ в виде исполняемых файлов и запускаются особым образом при инициализации ядра системы.

\begin{verbatim}
Примеры:
1)диспетчер свопинга
2)диспетчер памяти
и другие.
\end{verbatim}

Выполняемые инструкции и данные системных процессов находятся в ядре, таким образом, они могут обращаться к функциям и данным, не доступным извне (ядра). 

Процесс \verb+init+ можно также отнести к системным, хотя он запускается из файла. Он прародитель всех процессов системы. \verb+init+ запускается первым после загрузки ядра и запускает все остальные инициализационные задачи на выполнение.

\subsection{Демоны}

\emph{Демоны} - неинтерактивные процессы, запускаемые обычным образом, и выполняются в фоновом режиме. Они не связаны ни с одним пользовательским сеансом и не могут непосредственно управляться пользователем. Обеспечивают работу различных подсистем: \begin{itemize}
\item печати
\item сетевого доступа
\item терминального доступа
\item почта
\item web-сервера
\item СУБД.
\end{itemize}

\subsection{Прикладные процессы}

\emph{Прикладные процессы} - все остальные процессы. Как правило, порождаются в рамках пользовательского сеанса. 

\verb+Пример: ls, BASH.+

Пользовательские процессы могут выполняться как в интерактивном, так и в фоновом режиме, но время из жизни (выполнения) ограничено сеансом работы пользователя. При выходе из системы все пользовательские процессы будут уничтожены.

\emph{Примечание}: интерактивные процессы монопольно владеют терминалом, и, пока такой процесс не завершит выполнение, пользователь не может работать с другими приложениями. (Кроме случаев, когда есть режим запуска других процессов из этого интерактивного процесса.)

\section{Атрибуты процессов}

Атрибуты позволяют ОС эффективно управлять работой процесса.

Просмотр атрибутов процесса: \verb+ps -ef+.

\subsection{Идентификатор процесса}
\label{pid}
Идентификатор процесса - \emph{Process ID (PID)} - каждый процесс имеет уникальный идентификатор, позволяющий ядру системы различать процессы.
При создании нового процесса, ядро присваивает ему следующий свободный идентификатор. Присвоение PID - по возрастающей, то есть PID нового процесса больше, чем PID процесса, созданного перед ним. 

Если  PID достиг максимального значения, следующий процесс получит минимальный свободный и цикл повторяется.

Когда процесс завершает работу - ядро освобождает занятый им PID.

\subsection{Родительский процесс}
\label{ppid}
Идентификатор родительского процеcса -Parent Process ID (PPID) -  PID процесса, породившего данный.

\subsection{Приоритет процесса}
Приоритет процесса (nice number) - относительный приоритет процесса, учитываемый планировщиком при определении очередности запуска. Чем меньше число, тем больше приоритет (nice - приятный, то есть чем более "приятный" процесс, тем меньше он загружает CPU).

Фактическое распределение ресурсов - приоритет выполнения: динамически изменяется ядром во время выполнения. Относительный - постоянен, но может изменяться администратором или пользователем с помощью nice.

\subsection{Терминальная линия}
Терминальная линия (TTY) - терминал или псевдотерминал, ассоциированный с процессом. 

\emph{Примечание}. Демоны не имеют ассоциированного терминала. 

\subsection{Идентификаторы пользователей}
\label{euid} \label{rid}
Реальный (RID) и  эффективный (EUID) идентификаторы пользователя. RID - идентификатор пользователя, запустившего этот процесс. EUID служит для определения прав доступа процессак системным ресурсам (в первую очередь к файловой системе.)
Обычно RID=EUID, то есть процесс имеет те же права, что и пользователь, запустивший его. RID!=EUID, когда на программе установлен бит SUID. Тогда EUID=UID, то есть процесс получает те же права, что и у владельца исполняемого файла (например, администратор).

\subsection{Идентификаторы групп}

Реальный (RGID) и эффективный (EGID) идентификаторы группы. RGID=GID первичной группы пользователя, запустившего процесс. EGID служит для определения прав доступа пользователя по классу доступа группы. По умолчанию RGID=EGID, кроме SGID, установленного на команду, тогда EGID=GID группы-владельца команды.

\section{Жизненный путь процессов}

Процесс в UNIX создается системным вызовом \verb+fork(2)+. 

Процесс, сделавший вызов fork(2), называется \emph{родительским}, а вновь созданный - \emph{дочерним}. Новый процесс является точной копией породившего его процесса. 

\emph{Примечание}. новый процесс имеет те же инструкции и данные, что и родитель. Более того, выполнение родительского и дочернего начнется с одной и той же инструкцией, следующей за системным вызовом fork. Единственное их отличие - идентификатор PID.

Каждый процесс имеет одного родителя, но может иметь несколько потомков.

Для запуска задачи, то есть загрузки новой программы, процесс должен сделать вызов \verb+exec(3)+. При этом новый процесс не порождается, а исполняемый код нового процесса полностью замещается кодом запускаемой программы. Тем не менее сохраняются значения переменных окружения, назначение стандартных потоков ввода/вывода и ошибок, а также приоритет процесса.

В UNIX запуск на выполнение новой программы часто связан с порождением нового процесса. Таким образом, процесс сначала выполняет fork, порождая дочерний процесс, который затем выполняет exec, полностью замещая родительский процесс. Такая процедура запуска называется fork-and-exec. 

Бывают ситуации, когда достаточно одного вызова fork без последующего exec. В этом случае исполняемый код родительского и дочернего процессов должен содержать логическое ветвление для родительского и дочернего процессов. (fork возвращает PID порожденного процесса в родительский и ноль - в дочерний.)

Все процессы создаются через вызов fork. Запуск осуществляется либо по fork-and-exec, либо с помощью exec.
Прародителем всех процессов является init или распределитель процессов.


\section{Сигналы}

Сигналы являются способом передачи уведомления о возникновении какого-либо события. Сигнал может идти от одного процесса другому или от ядра ОС какому-либо процессу.
 
Сигналы - простейшая форма IPC. 

Например, при делении на ноль процессу посылается сигнал SIGFPE, а при нажатии Ctrl+C на терминале текущему процессу посылается сигнал SIGINT.

Для отправки сигналов используется команда \verb+kill+: \\
\verb+$ kill sig_no pid+, где \\
sig\_no - номер или символьное название сигнала;\\
pid - идентификатор процесса, которому посылается сигнал.

Пользователь может посылать сигналы только тем процессам, владельцем которых он является, то есть RID и EUID совпадают с UID пользователя. Администратор (root) может посылать сигналы всем процессам.

\begin{verbatim}
Пример: посылка сигнала процессу, только что запущенному в фоновом режиме
$ back_fone_prog &
$ kill $! (по умолчанию посылается SIGTERM, номер 15).
\end{verbatim}

При получении сигнала процесс может реагировать следующим образом:
\begin{enumerate}
\item игнорировать сигнал.\newline
	\emph{Замечание:} не следует игнорировать аппаратно вызванные сигналы, например, SIGFPE.
\item действие по умолчанию. Обычно это завершение работы.
\item перехватить сигнал и самостоятельно обработать его. Например, перехват SIGINT позволит удалить все tmp-файлы и корректно завершить выполнение.
\end{enumerate}

\emph{Исключение:} SIGKILL и SIGSTOP нельзя ни перехватить, ни игнорировать.

Возможны ситуации, когда процесс не реагирует на SIGKILL:
\begin{enumerate}
\item процессы-зомби. Фактически он завершился, но осталась запись в системной таблице процессов.
\item процессы, ожидающие недоступные ресурсы NFS. Например, процессы пишущие данные в файл удаленного компьютера, который уже отключился. Проблему решают посылкой SIGINT или SIGQUIT. 
\item процесс, ожидающий завершения операции с устройством, например, перемотка ленты или перепозиционирование головки CD-ROM на порченном диске.
\end{enumerate}

Сигналы используются не только для завершения работы процессов, но и могут иметь специфическое значение для приложения. (Это не относится к SIGKILL и SIGSTOP, потому что их нельзя перехватить.)
К примеру, системные демоны - proxy servers, smtp (pop, imap), СУБД, bind при получении сигнала SIGHUP должны перечитать свои конфигурационные файлы и рестартовать. 
