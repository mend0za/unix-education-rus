<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>

<TITLE>Учебное пособие по курсу ОСиС</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=cp1251">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>

<BODY >
<!--HEVEA command line is: /usr/bin/hevea -charset cp1251 -exec /bin/date -o metoda.html metoda.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->

<BR>
<TABLE CLASS="title">
<TR><TD>
<H1 CLASS="titlemain">Учебное пособие по курсу ОСиС</H1>
<H3 CLASS="titlerest">Шахов Владимир Владимирович</H3>
<H3 CLASS="titlerest">последнее обновление - </H3></TD>
</TR></TABLE><BR>
Copyright ©Владимир 'mend0za' Шахов, 2002-2006
<BR>
<BR>
<BR>
<BR>
Каждый имеет право воспроизводить, распространять и/или вносить изменения в настоящий Документ в соответствии с условиями GNU Free Documentation License, Версией 1.2 или любой более поздней версией, опубликованной Free Software Foundation;<BR>
<BR>
данный документ содержит следующий Текст, помещаемый на первой странице обложки "Учебное пособие по курсу ОСиС";<BR>
<BR>
данный документ не содержит неизменяемых секций;<BR>
<BR>
Копия настоящей Лицензии включена в раздел под названием "GNU Free Documentation License".<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<!--TOC chapter Contents-->

<H1 CLASS="chapter">Contents</H1><!--SEC END -->

<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&nbsp;1&nbsp;&nbsp;Общие сведения о ОС UNIX</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&nbsp;&nbsp;Вместо предисловия</A>
<LI CLASS="li-toc"><A HREF="#htoc3">1.2&nbsp;&nbsp;Введение</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc4">1.2.1&nbsp;&nbsp;Основные черты</A>
<LI CLASS="li-toc"><A HREF="#htoc5">1.2.2&nbsp;&nbsp;Структура системы</A>
<LI CLASS="li-toc"><A HREF="#htoc6">1.2.3&nbsp;&nbsp;ОС UNIX для пользователя</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc7">Chapter&nbsp;2&nbsp;&nbsp;Командная строка</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc8">2.1&nbsp;&nbsp;Основные принципы и команды</A>
<LI CLASS="li-toc"><A HREF="#htoc9">2.2&nbsp;&nbsp;Встроенная справка</A>
<LI CLASS="li-toc"><A HREF="#htoc10">2.3&nbsp;&nbsp;Перемещение по файловой системе</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc11">2.3.1&nbsp;&nbsp;Команды перемещения</A>
<LI CLASS="li-toc"><A HREF="#htoc12">2.3.2&nbsp;&nbsp;Подключение других устройств(дисковода, CD-ROM)</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc13">2.4&nbsp;&nbsp;Копирование, удаление, перемещение файлов и каталогов</A>
<LI CLASS="li-toc"><A HREF="#htoc14">2.5&nbsp;&nbsp;Информация о системе</A>
<LI CLASS="li-toc"><A HREF="#htoc15">2.6&nbsp;&nbsp;Общение между пользователями</A>
<LI CLASS="li-toc"><A HREF="#htoc16">2.7&nbsp;&nbsp;Просмотр, создание, объединение файлов</A>
<LI CLASS="li-toc"><A HREF="#htoc17">2.8&nbsp;&nbsp;Объединение команд</A>
<LI CLASS="li-toc"><A HREF="#htoc18">2.9&nbsp;&nbsp;Приемы эффективной работы</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc19">Chapter&nbsp;3&nbsp;&nbsp;Shell (оболочка)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc20">3.1&nbsp;&nbsp;Понятие оболочки</A>
<LI CLASS="li-toc"><A HREF="#htoc21">3.2&nbsp;&nbsp;Bourne Shell</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc22">3.2.1&nbsp;&nbsp;Структура скриптов</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc23">3.3&nbsp;&nbsp;Переменные</A>
<LI CLASS="li-toc"><A HREF="#htoc24">3.4&nbsp;&nbsp;Перенаправление ввода/вывода</A>
<LI CLASS="li-toc"><A HREF="#htoc25">3.5&nbsp;&nbsp;Шаблоны(wildcard's, подстановочные символы)</A>
<LI CLASS="li-toc"><A HREF="#htoc26">3.6&nbsp;&nbsp;Условное выполнение команд</A>
<LI CLASS="li-toc"><A HREF="#htoc27">3.7&nbsp;&nbsp;Условные выражения</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc28">3.7.1&nbsp;&nbsp;Сравнение строк</A>
<LI CLASS="li-toc"><A HREF="#htoc29">3.7.2&nbsp;&nbsp;Сравнение чисел</A>
<LI CLASS="li-toc"><A HREF="#htoc30">3.7.3&nbsp;&nbsp;Сложные выражения</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc31">3.8&nbsp;&nbsp;Циклы</A>
<LI CLASS="li-toc"><A HREF="#htoc32">3.9&nbsp;&nbsp;Функции</A>
<LI CLASS="li-toc"><A HREF="#htoc33">3.10&nbsp;&nbsp;Выполнение арифметических операций</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc34">Chapter&nbsp;4&nbsp;&nbsp;Текстовый редактор VI</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc35">4.1&nbsp;&nbsp;Режимы работы</A>
<LI CLASS="li-toc"><A HREF="#htoc36">4.2&nbsp;&nbsp;Получение помощи</A>
<LI CLASS="li-toc"><A HREF="#htoc37">4.3&nbsp;&nbsp;Запуск и остановка редактора</A>
<LI CLASS="li-toc"><A HREF="#htoc38">4.4&nbsp;&nbsp;Перемещение по тексту</A>
<LI CLASS="li-toc"><A HREF="#htoc39">4.5&nbsp;&nbsp;Ввод и редактирование текста</A>
<LI CLASS="li-toc"><A HREF="#htoc40">4.6&nbsp;&nbsp;Копирование и вставка</A>
<LI CLASS="li-toc"><A HREF="#htoc41">4.7&nbsp;&nbsp;Откат действий</A>
<LI CLASS="li-toc"><A HREF="#htoc42">4.8&nbsp;&nbsp;Поиск и замена</A>
<LI CLASS="li-toc"><A HREF="#htoc43">4.9&nbsp;&nbsp;Вызов внешних команд</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc44">Chapter&nbsp;5&nbsp;&nbsp;Регулярные выражения. sed</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc45">5.1&nbsp;&nbsp;Структура регулярных выражений</A>
<LI CLASS="li-toc"><A HREF="#htoc46">5.2&nbsp;&nbsp;Правила для регулярных выражений</A>
<LI CLASS="li-toc"><A HREF="#htoc47">5.3&nbsp;&nbsp;Диалекты регулярных выражений</A>
<LI CLASS="li-toc"><A HREF="#htoc48">5.4&nbsp;&nbsp;Метасимволы</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">5.4.1&nbsp;&nbsp;Начало и конец строки</A>
<LI CLASS="li-toc"><A HREF="#htoc50">5.4.2&nbsp;&nbsp;Символьные классы</A>
<LI CLASS="li-toc"><A HREF="#htoc51">5.4.3&nbsp;&nbsp;Один произвольный символ</A>
<LI CLASS="li-toc"><A HREF="#htoc52">5.4.4&nbsp;&nbsp;Выбор</A>
<LI CLASS="li-toc"><A HREF="#htoc53">5.4.5&nbsp;&nbsp;Границы слов</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc54">5.5&nbsp;&nbsp;Квантификаторы</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc55">5.5.1&nbsp;&nbsp;Необязательные элементы</A>
<LI CLASS="li-toc"><A HREF="#htoc56">5.5.2&nbsp;&nbsp;Повторение</A>
<LI CLASS="li-toc"><A HREF="#htoc57">5.5.3&nbsp;&nbsp;Интервал</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc58">5.6&nbsp;&nbsp;Круглые скобки и обратные сcылки</A>
<LI CLASS="li-toc"><A HREF="#htoc59">5.7&nbsp;&nbsp;Экранирование</A>
<LI CLASS="li-toc"><A HREF="#htoc60">5.8&nbsp;&nbsp;sed</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc61">5.8.1&nbsp;&nbsp;Общий вид команды</A>
<LI CLASS="li-toc"><A HREF="#htoc62">5.8.2&nbsp;&nbsp;Команды sed</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc63">Chapter&nbsp;6&nbsp;&nbsp;Файловая система ОС UNIX</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc64">6.1&nbsp;&nbsp;Базовые сведения о файловой системе</A>
<LI CLASS="li-toc"><A HREF="#htoc65">6.2&nbsp;&nbsp;Типы файлов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc66">6.2.1&nbsp;&nbsp;Обычный файл (regular file)</A>
<LI CLASS="li-toc"><A HREF="#htoc67">6.2.2&nbsp;&nbsp;Каталог (directory)</A>
<LI CLASS="li-toc"><A HREF="#htoc68">6.2.3&nbsp;&nbsp;Специальный файл устройства (special device file)</A>
<LI CLASS="li-toc"><A HREF="#htoc69">6.2.4&nbsp;&nbsp;FIFO или именованный канал (named pipe)</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc70">6.3&nbsp;&nbsp;Связь (ссылка)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc71">6.3.1&nbsp;&nbsp;Жесткая ссылка</A>
<LI CLASS="li-toc"><A HREF="#htoc72">6.3.2&nbsp;&nbsp;Символическая ссылка</A>
<LI CLASS="li-toc"><A HREF="#htoc73">6.3.3&nbsp;&nbsp;Сокет (socket)</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc74">6.4&nbsp;&nbsp;Структура файловой системы</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc75">6.4.1&nbsp;&nbsp;Основные каталоги</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc76">6.5&nbsp;&nbsp;Атрибуты файлов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc77">6.5.1&nbsp;&nbsp;Владельцы файлов</A>
<LI CLASS="li-toc"><A HREF="#htoc78">6.5.2&nbsp;&nbsp;Права доступа к файлам</A>
<LI CLASS="li-toc"><A HREF="#htoc79">6.5.3&nbsp;&nbsp;Значение прав доступа</A>
<LI CLASS="li-toc"><A HREF="#htoc80">6.5.4&nbsp;&nbsp;Последовательность проверки прав</A>
<LI CLASS="li-toc"><A HREF="#htoc81">6.5.5&nbsp;&nbsp;Дополнительные атрибуты файла</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc82">Chapter&nbsp;7&nbsp;&nbsp;Процессы</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc83">7.1&nbsp;&nbsp;Типы процессов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc84">7.1.1&nbsp;&nbsp;Системные процессы</A>
<LI CLASS="li-toc"><A HREF="#htoc85">7.1.2&nbsp;&nbsp;Демоны</A>
<LI CLASS="li-toc"><A HREF="#htoc86">7.1.3&nbsp;&nbsp;Прикладные процессы</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc87">7.2&nbsp;&nbsp;Атрибуты процессов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc88">7.2.1&nbsp;&nbsp;Идентификатор процесса</A>
<LI CLASS="li-toc"><A HREF="#htoc89">7.2.2&nbsp;&nbsp;Родительский процесс</A>
<LI CLASS="li-toc"><A HREF="#htoc90">7.2.3&nbsp;&nbsp;Приоритет процесса</A>
<LI CLASS="li-toc"><A HREF="#htoc91">7.2.4&nbsp;&nbsp;Терминальная линия</A>
<LI CLASS="li-toc"><A HREF="#htoc92">7.2.5&nbsp;&nbsp;Идентификаторы пользователей</A>
<LI CLASS="li-toc"><A HREF="#htoc93">7.2.6&nbsp;&nbsp;Идентификаторы групп</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc94">7.3&nbsp;&nbsp;Жизненный путь процессов</A>
<LI CLASS="li-toc"><A HREF="#htoc95">7.4&nbsp;&nbsp;Сигналы</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc96">Chapter&nbsp;8&nbsp;&nbsp;Среда программирования Unix</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc97">8.1&nbsp;&nbsp;Unix-way программирования</A>
<LI CLASS="li-toc"><A HREF="#htoc98">8.2&nbsp;&nbsp;Unix как единая среда разработки (IDE)</A>
<LI CLASS="li-toc"><A HREF="#htoc99">8.3&nbsp;&nbsp;Низкоуровневый доступ к системе</A>
<LI CLASS="li-toc"><A HREF="#htoc100">8.4&nbsp;&nbsp;Принципы разработки программ для Unix</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc101">Chapter&nbsp;9&nbsp;&nbsp;Инструментальные средства разработчика</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc102">9.1&nbsp;&nbsp;Компилятор Си</A>
<LI CLASS="li-toc"><A HREF="#htoc103">9.2&nbsp;&nbsp;make</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc104">9.2.1&nbsp;&nbsp;Запуск</A>
<LI CLASS="li-toc"><A HREF="#htoc105">9.2.2&nbsp;&nbsp;Формат и использование make-файлов.</A>
<LI CLASS="li-toc"><A HREF="#htoc106">9.2.3&nbsp;&nbsp;Переменные make.</A>
<LI CLASS="li-toc"><A HREF="#htoc107">9.2.4&nbsp;&nbsp;Шаблонные правила</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc108">9.3&nbsp;&nbsp;Системы управления версиями. CVS</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc109">9.3.1&nbsp;&nbsp;Репозиторий</A>
<LI CLASS="li-toc"><A HREF="#htoc110">9.3.2&nbsp;&nbsp;Получение рабочей копии исходников</A>
<LI CLASS="li-toc"><A HREF="#htoc111">9.3.3&nbsp;&nbsp;Сохранение результатов и версионирование</A>
<LI CLASS="li-toc"><A HREF="#htoc112">9.3.4&nbsp;&nbsp;Коллективная работа над проектом</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc113">9.4&nbsp;&nbsp;Библиотека Си (libc)</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc114">Chapter&nbsp;10&nbsp;&nbsp;Процессы и сигналы.IPC</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc115">10.1&nbsp;&nbsp;Типы IPC</A>
<LI CLASS="li-toc"><A HREF="#htoc116">10.2&nbsp;&nbsp;Сигналы</A>
<LI CLASS="li-toc"><A HREF="#htoc117">10.3&nbsp;&nbsp;Посылка сигналов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc118">10.3.1&nbsp;&nbsp;Смысл параметра PID</A>
<LI CLASS="li-toc"><A HREF="#htoc119">10.3.2&nbsp;&nbsp;Посылка сигнала самому себе</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc120">10.4&nbsp;&nbsp;Таймеры</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc121">10.4.1&nbsp;&nbsp;Нормальное и аварийное завершение</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc122">10.5&nbsp;&nbsp;Имена сигналов (по алфавиту, выборочно)</A>
<LI CLASS="li-toc"><A HREF="#htoc123">10.6&nbsp;&nbsp;Наборы сигналов</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc124">10.6.1&nbsp;&nbsp;Инициализация набора</A>
<LI CLASS="li-toc"><A HREF="#htoc125">10.6.2&nbsp;&nbsp;Добавление и удаление сигналов</A>
<LI CLASS="li-toc"><A HREF="#htoc126">10.6.3&nbsp;&nbsp;Типовой сценарий работы с набором</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc127">10.7&nbsp;&nbsp;Обработчик сигналов</A>
<LI CLASS="li-toc"><A HREF="#htoc128">10.8&nbsp;&nbsp;Разбор структуры sigaction</A>
<LI CLASS="li-toc"><A HREF="#htoc129">10.9&nbsp;&nbsp;Ненадежные сигналы (устаревшая версия)</A>
<LI CLASS="li-toc"><A HREF="#htoc130">10.10&nbsp;&nbsp;Блокирование сигналов</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc131">Chapter&nbsp;11&nbsp;&nbsp;GNU Free Documentation License</A>
<UL CLASS="toc"><LI CLASS="li-toc">
1. APPLICABILITY AND DEFINITIONS
<LI CLASS="li-toc">2. VERBATIM COPYING
<LI CLASS="li-toc">3. COPYING IN QUANTITY
<LI CLASS="li-toc">4. MODIFICATIONS
<LI CLASS="li-toc">5. COMBINING DOCUMENTS
<LI CLASS="li-toc">6. COLLECTIONS OF DOCUMENTS
<LI CLASS="li-toc">7. AGGREGATION WITH INDEPENDENT WORKS
<LI CLASS="li-toc">8. TRANSLATION
<LI CLASS="li-toc">9. TERMINATION
<LI CLASS="li-toc">10. FUTURE REVISIONS OF THIS LICENSE
<LI CLASS="li-toc">ADDENDUM: How to use this License for your documents
</UL>
</UL>

<!--TOC chapter Общие сведения о ОС UNIX-->

<H1 CLASS="chapter"><A NAME="htoc1">Chapter&nbsp;1</A>&nbsp;&nbsp;Общие сведения о ОС UNIX</H1><!--SEC END -->

<!--TOC section Вместо предисловия-->

<H2 CLASS="section"><A NAME="htoc2">1.1</A>&nbsp;&nbsp;Вместо предисловия</H2><!--SEC END -->

Это пособие - почти 100% плагиат. Многие главы почти не содержат авторского текста. Это связано с тем, что автор трезво оценивает свои знания и навыки и считает, что гораздо полезнее собрать весь этот материал в одно издание из разрозненных источников, чем заново писать его. Тем более что самописная версия пособия будет заведомо хуже.<BR>
<BR>
Это учебное пособие предназначено для студентов 3 курса специальности информатика. Курс Операционные Системы и Среды (далее ОСиС) базируется на материале курсов ОАиП и КПиЯП и требует знаний языка Си и основ алгоритмизации.<BR>
<BR>
Основная задача курса ОСиС - подготовка специалистов, овладевших пользовательским интерфейсом, архитектурой и программированием Unix-систем (факультативно - элементы администрирования). <BR>
<BR>
<!--TOC section Введение-->

<H2 CLASS="section"><A NAME="htoc3">1.2</A>&nbsp;&nbsp;Введение</H2><!--SEC END -->

Что такое Unix? Это семейство операционных систем (ОС), обладающих сходной архитектурой и интерфесом с пользователем. <BR>
<BR>
Unix как явление зародилось в начале 70-х годов и развивается до сих пор.<BR>
<BR>
Основные современные варианты UNIX: Linux, BSD (FreeBSD, NetBSD, OpenBSD), AIX, HPUX, Solaris, SCO. <BR>
<BR>
Важнейшие современные стандарты, обеспечивающие целостность семейства UNIX:
<UL CLASS="itemize"><LI CLASS="li-itemize">
- POSIX - Portable Operating System Interface
<LI CLASS="li-itemize">- ANSI C (c89 и с99) 
<LI CLASS="li-itemize">- Opengroup<SUP><A NAME="text1" HREF="#note1">1</A></SUP> Single Unix Specification Version 3 (далее SUSv3). 
</UL>
Примечание. Далее под словом Unix мы будем подразумевать все Unix-подобные операционные системы, если не названа конкретная система.<BR>
<BR>
<!--TOC subsection Основные черты-->

<H3 CLASS="subsection"><A NAME="htoc4">1.2.1</A>&nbsp;&nbsp;Основные черты</H3><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
Код на Си - позволяет переносить и изменять ОС.
<LI CLASS="li-itemize">Многозадачная многопользовательская ОС.
<LI CLASS="li-itemize">Наличие стандартов - основой всего семейства являются одинаковая структура и ряд стандартных интерфейсов.
<LI CLASS="li-itemize">Простой, но мощный пользовательский интерфейс (командная строка).
<LI CLASS="li-itemize">Eдиная древовидная файловая система. Через интерфейс файловой системы осуществляется доступ к данным, терминалам, принтерам, дискам, сети и даже к оперативной памяти.
<LI CLASS="li-itemize">Большое количество программного обеспечения.
</UL>
<!--TOC subsection Структура системы-->

<H3 CLASS="subsection"><A NAME="htoc5">1.2.2</A>&nbsp;&nbsp;Структура системы</H3><!--SEC END -->

Классическая архитектура UNIX двухуровневая:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Ядро - управляет ресурсами компьютера и предлагает программам базовый набор услуг (системные вызовы).
<LI CLASS="li-enumerate">Системные программы (управление сетью, терминалами, печатью), прикладные программы (редакторы, утилиты, компиляторы и т.д.). 
</OL>
<!--TOC subsubsection Функции ядра-->

<H4 CLASS="subsubsection">Функции ядра</H4><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<EM>инициализация системы</EM> - загрузка и запуск ОС
<LI CLASS="li-itemize"><EM>управление процессами и потоками</EM> 
<LI CLASS="li-itemize"><EM>управление памятью</EM> - отображение адресного пространства на физическую память, совместное использование памяти процессами
<LI CLASS="li-itemize"><EM>управление файлами</EM> - реализует понятие файловой системы, дерева каталогов и файлов 
<LI CLASS="li-itemize"><EM>обмен данными между процессами</EM> 
	<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	выполняющимися внутри одного компьютера
 	<LI CLASS="li-enumerate">в разных узлах сетей передачи данных
 	<LI CLASS="li-enumerate">а также между процессами и драйверами внешних устройств
	</OL>
<LI CLASS="li-itemize"><EM>программный интерфейс (API)</EM> - обеспечивает доступ к возможностям ядра со стороны процессов пользователя через системные вызовы, оформленных в виде библиотеки функций на Си.
</UL>
<!--TOC subsubsection Системные вызовы-->

<H4 CLASS="subsubsection">Системные вызовы</H4><!--SEC END -->

Ядро изолирует программы пользователя от аппаратуры. Все части системы, не считая небольшой части ядра, полностью независимы от архитектуры компьютера и написаны на Си.<BR>
<BR>
<EM>Системные вызовы</EM> - это уровень, скрывающий особенности конкретного механизма выполнения на уровне аппаратуры от программ пользователя. Для программиста, системный вызов - это функция (определенная на Си), которую он вызывает в своей программе. Все низкоуровневые операции осуществляются через системные вызовы.<BR>
<BR>
<!--TOC subsubsection Подсистемы ядра-->

<H4 CLASS="subsubsection">Подсистемы ядра</H4><!--SEC END -->

<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Файловая подсистема. Обеспечивает унифицированный доступ к файлам:
	<UL CLASS="itemize"><LI CLASS="li-itemize">
	контроль прав доступа к файлу;
	<LI CLASS="li-itemize">чтение/запись файла;
	<LI CLASS="li-itemize">размещение и удаление файла;
	<LI CLASS="li-itemize">перенаправление запросов к периферийным устройствам, соответствующим модулям подсистемы ввода/вывода.
	</UL>
<LI CLASS="li-enumerate">Подсистема управления процессами.<BR>
<BR>
	Запущенная на выполнение программа порождает один или несколько процессов (задач).<BR>
Подсистема контролирует:
	<UL CLASS="itemize"><LI CLASS="li-itemize">
	создание и удаление процессов
	<LI CLASS="li-itemize">распределение системных ресурсов (памяти, вычислительных ресурсов) между процессами
	<LI CLASS="li-itemize">синхронизация процессов
	<LI CLASS="li-itemize">межпроцессное взаимодействие
	</UL><BR>
Специальная задача ядра <EM>планировщик процессов</EM> разрешает конфликты процессов в конкуренции за ресурсы. 
<LI CLASS="li-enumerate">Подсистема ввода/вывода. Выполняет запросы файловой системы и подсистемы управления процессами для доступа к периферийным устройствам (дискам, лентам, терминалам). Обеспечивает буферизацию данных и взаимодействует с драйверами устройств.
</OL>
<!--TOC subsection ОС UNIX для пользователя-->

<H3 CLASS="subsection"><A NAME="htoc6">1.2.3</A>&nbsp;&nbsp;ОС UNIX для пользователя</H3><!--SEC END -->

<!--TOC subsubsection Пользователь-->

<H4 CLASS="subsubsection">Пользователь</H4><!--SEC END -->

С самого начала ОС UNIX разрабатывалась как интерактивная система. Чтобы начать работу, нужно войти в систему, введя со свободного терминала (консоли) свое <EM>имя</EM> (account name, логин) и <EM>пароль</EM> (password).<BR>
<BR>
Человек, зарегистрированный в системе и, следовательно, имеющий учетное имя, называется <EM>зарегистрированным пользователем системы</EM>.<BR>
<BR>
Регистрацию новых пользователей обычно выполняет администратор системы. Пользователь не может изменить свое учетное имя, но может установить или изменить пароль. Пароли находятся в отдельном файле в закодированном виде.<BR>
<BR>
Все пользователи так или иначе работают с файлами. Файловая система имеет древовидную структуру. У каждого зарегистрированного пользователя есть <EM>домашний каталог</EM>. К нему он имеет полный доступ. К другим каталогам доступ обычно ограничен.<BR>
<BR>
<!--TOC subsubsection Интерфейс пользователя-->

<H4 CLASS="subsubsection">Интерфейс пользователя</H4><!--SEC END -->

Традиционный интерфейс - <EM>командная строка</EM>. После входа в систему для пользователя осуществляется запуск одной из <EM>командных оболочек</EM>. Общее название <EM>shell (eng. - оболочка)</EM>, так как они являются внешним окружением ядра системы. Оболочка - это интерпретатор комманд (встроенных и внешних) и обладает мощным встроенным языком shell scripts, позволяющим писать сложные программы. <BR>
<BR>
<!--TOC subsubsection GUI и Unix-->

<H4 CLASS="subsubsection">GUI и Unix</H4><!--SEC END -->

Графический интерфейс (GUI) не является необходимым в Unix и рассматриваться не будет. Подавляющее большинство обычных операций выполняется без его участия.

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Opengroup - организация, занятая выработкой единых стандартов на Unix-системы (www.opengroup.org). Владелец торговой марки Unix.
</DL>
<!--END NOTES-->
<!--TOC chapter Командная строка-->

<H1 CLASS="chapter"><A NAME="htoc7">Chapter&nbsp;2</A>&nbsp;&nbsp;Командная строка</H1><!--SEC END -->

<!--TOC section Основные принципы и команды-->

<H2 CLASS="section"><A NAME="htoc8">2.1</A>&nbsp;&nbsp;Основные принципы и команды</H2><!--SEC END -->

Как следует из названия, основное назначение командной оболочки - ввод и исполнение команд. Для ввода команд служит т.н. <EM>командная строка</EM>, содержащая приглашение к вводу.<BR>
<BR>
В примерах приглашение командной строки будем обозначать <CODE>$</CODE>.<BR>
<BR>
После ввода имени и пароля, пользователь получает приглашение на ввод. После окончания работы, он выходит, набирая <CODE>exit</CODE> или <CODE>logout</CODE>. <BR>
<BR>
Большинству команд можно передавать дополнительную информацию. Это делается с помощью <EM>аргументов и ключей</EM>.<BR>
Общий вид команды:
<CODE>команда [-ключи] аргумент1 ... аргументN</CODE><BR>
<BR>
Простейшая команда - <CODE>echo</CODE>. Она просто выводит на экран свои параметры.<BR>
<BR>
<EM>Ключ</EM> - 1 или более букв, перед которой ставится <CODE>-</CODE>(минус или дефис). Обычно ключи управляют режимами работы команды.<BR>
<BR>
<EM>Аргумент</EM> - строка, передаваемая команде.
<PRE CLASS="verbatim">
Пример 
$kill -9 1023
kill имя команды (завершение процесса)
-9  режим (безусловное завершение процесса)
1023 номер процесса (завершаемый процесс) 
$ - символ приглашения ввода (в разных системах - разный)
</PRE>
После ввода команды, система производит поиск в каталогах программ, заданных переменной <EM>PATH</EM> <A NAME="path"></A>. Если команда найдена, то она будет запущена. Иногда, если PATH не содержит нужного каталога, нужно указать полный путь (см. <A HREF="#fullpath">2.3</A>) к программе.<BR>
<BR>
<EM>Примечание.</EM> Текущий каталог НЕ ВХОДИТ в PATH. Программы из него запускаютсяь следующим образом:<BR>
<CODE>./program</CODE><BR>
<BR>
<!--TOC section Встроенная справка-->

<H2 CLASS="section"><A NAME="htoc9">2.2</A>&nbsp;&nbsp;Встроенная справка</H2><!--SEC END -->

Любая Unix система обладает развитой системой справки. Она называется <CODE>man</CODE> (от англ. слова manual). <BR>
<BR>
Справка запускается следующим образом: <CODE>man статья</CODE><SUP><A NAME="text2" HREF="#note2">1</A></SUP>. Для перемещения используются клавиши <CODE>"вверх", "вниз"</CODE>. Для выхода нажмите <CODE>q</CODE>.<BR>
<BR>
<CODE>man</CODE> делится на несколько разделов, которые пронумерованы<SUP><A NAME="text3" HREF="#note3">2</A></SUP>:
<UL CLASS="itemize"><LI CLASS="li-itemize">
1 - Команды, которые могут быть запущены пользователем
<LI CLASS="li-itemize">2 - Системные вызовы (функции, исполняемые ядром)
<LI CLASS="li-itemize">3 - Библиотечные вызовы (функции из библиотек различных языков программирования)
<LI CLASS="li-itemize">5 - Форматы файлов и соглашения
</UL>
Запись типа <CODE>bash(1)</CODE> обозначает, что справка о команде <CODE>bash</CODE> находиться в разделе 1 (команды). Бывает что справки в различных разделах называются одинаково. Тогда для получения нужной надо явно указать раздел.
<PRE CLASS="verbatim">
Примеры использования man
$ man echo
 
Получение справки по самой команде man
$ man man

Справка из конкретного раздела
$ man 2 open

Все статьи с таким названием из всех разделов
$ man -a mount
</PRE>
Некоторые команды содержат свою собственную систему помощи<SUP><A NAME="text4" HREF="#note4">3</A></SUP>, Она вызывается с помощью ключа <CODE>--help</CODE> или вызовом без параметров
<PRE CLASS="verbatim">
Примеры
$ file
Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...
Usage: file -C [-m magic]

$ split --help
Usage: split [OPTION] [INPUT [PREFIX]]
Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default
PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.

  -b, --bytes=SIZE        put SIZE bytes per output file
  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file
  -l, --lines=NUMBER      put NUMBER lines per output file
  -NUMBER                 same as -l NUMBER
      --verbose           print a diagnostic to standard error just
                            before each output file is opened
      --help              display this help and exit
      --version           output version information and exit

SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.

Report bugs to &lt;bug-textutils@gnu.org&gt;.

</PRE>
<!--TOC section Перемещение по файловой системе-->

<H2 CLASS="section"><A NAME="htoc10">2.3</A>&nbsp;&nbsp;Перемещение по файловой системе</H2><!--SEC END -->
 
Файл в Unix - это основа всего. Существует высказывание "Unix - это файлы".<BR>
<BR>
Имя файла может состоять из любых символов, которые можно ввести с клавиатуры. Точка не имеет особого значения - имя файла может содержать ее или нет<SUP><A NAME="text5" HREF="#note5">4</A></SUP>. Обычно пользователи присваивают расширения своим файлам, чтобы различать их тип. Система <EM>не связывает типы файлов с их расширениями</EM>. Например файл <CODE>example.txt</CODE> может быть исполняемым (программой), а может и не быть. А <CODE>/bin/sh</CODE> как правило исполняемый.<BR>
<BR>
Однако у точки есть специальные значения 
<UL CLASS="itemize"><LI CLASS="li-itemize">
точка в начале файла указывает на то, что файл - скрытый, например <CODE>.profile</CODE>
<LI CLASS="li-itemize">файл <CODE>.</CODE> - ссылка на текущий каталог (см. пример относительных путей)
<LI CLASS="li-itemize">файл <CODE>..</CODE> - ссылка на родительский каталог
</UL>
Если вы не знаете тип файла, примените команду <CODE>file</CODE>.
<PRE CLASS="verbatim">
$ file /home/work/OSIS/LAB/RUsak/demon1.c 
/home/work/OSIS/LAB/RUsak/demon1.c: ASCII C program text, with very long lines

$ file /bin/bash
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked
</PRE>
Unix различает строчные и заглавные буквы в именах. Например <CODE>name1.txt.125</CODE> и <CODE>NAME1.TXT.125</CODE> - это разные файлы.<BR>
<BR>
Файловая система ОС Unix является единой. Это значит что, все файлы находятся в рамках одной логической структуры - <EM>дерева каталогов</EM>. В Unix отсутствует понятие "диск" и "буква устройства". <BR>
<BR>
Например - файлы с дискеты обычно находятся в <CODE>/mnt/floppy</CODE>, но могут быть и в любом другом месте.<BR>
<BR>
Началом дерева является корневой каталог (корень), обозначаемый <CODE>/</CODE> . <BR>
<BR>
Разделителем каталогов является прямой слэш <CODE>/</CODE> .<BR>
<BR>
<EM>Путь</EM> - последовательный список каталогов, который нужно пройти, чтобы достигнуть файла или каталога.<BR>
<BR>
Есть 2 вида путей: <EM>абсолютный</EM> и <EM>относительный</EM>.<BR>
<EM>Абсолютный</EM><A NAME="fullpath"></A> - полный путь относительно корневого каталога.
<PRE CLASS="verbatim">
Примеры абсолютных путей:
/etc/init.d/apache
/bin/sh
/usr/local/share
</PRE><EM>относительный</EM> - путь относительно текущего каталога <A NAME="relativepath"></A>
<PRE CLASS="verbatim">
Примеры относительных путей:
./a.out
laba1/text.cpp
../index.html
</PRE>
<!--TOC subsection Команды перемещения-->

<H3 CLASS="subsection"><A NAME="htoc11">2.3.1</A>&nbsp;&nbsp;Команды перемещения</H3><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>cd</CODE> - перемещение между каталогами. Может использоваться в 2-х вариантах:
<PRE CLASS="verbatim">
перемещение по указанному пути
$cd  /usr/local 

вернуться в домашний каталог
$cd
</PRE><BR>
<BR>
<LI CLASS="li-itemize"><CODE>pwd</CODE> - показать текущий каталог
<PRE CLASS="verbatim">
$pwd 
/home/user/OSiS/metoda
</PRE><BR>
<BR>
<LI CLASS="li-itemize"><CODE>ls</CODE> - показать содержимое каталога(файлы и подкаталоги). Имеет множество ключей и режимов работы
<PRE CLASS="verbatim">
Без параметров - вывод содержимого текущего каталога
$ ls
literatura.aux  Makefile    metoda.dvi  metoda.tex  part1.aux  part2.aux
literatura.tex  metoda.aux  metoda.log  metoda.toc  part1.tex  part2.tex

C аргументом - вывод содержимого этого каталога
$ ls /usr
bin   doc  games    kerberos  libexec  man                sbin   src  X11R6
dict  etc  include  lib       local    OpenOffice.org1.0  share  tmp

С ключом "-l" - полный формат вывода (с доп информацией)
$ ls -l /home/user/OSiS
итого 710
drwxrwxr-x    2 user     user         1024 Июн 11 14:11 Lectures
-rw-rw-r--    1 user     user       123686 Июн 12 12:53 lectures.rar
-rw-rw-rw-    1 user     user         1789 Июн 11 15:44 lhr10.log
-rw-r--r--    1 user     user            0 Июн 11 15:44 lkypc.pdf
-rw-rw-r--    1 user     user       438112 Апр 20  1999 lshort.dvi
-rw-r--r--    1 user     user       112747 Июн 12 12:53 lshrtdvi.zip
drwxrwxr-x    2 user     user         1024 Июн 14 18:50 metoda
-rw-rw-r--    1 user     user        40960 Июн 11 14:06 metoda.doc
</PRE></UL>
<!--TOC subsection Подключение других устройств(дисковода, CD-ROM)-->

<H3 CLASS="subsection"><A NAME="htoc12">2.3.2</A>&nbsp;&nbsp;Подключение других устройств(дисковода, CD-ROM)</H3><!--SEC END -->

Чтобы подключить устройство (дисковод, CD-ROM, раздел вичестера, сетевой диск), нужно указать место, куда будет отображаться его содержимое. Это место называется <EM>точка монтирования</EM>. Точка монтирования - это обычный каталог. После подключения (в терминах Unix - <EM>монтирования</EM>) каталог будет содержать файлы, расположенные на устройстве. Список подключенных устройств и монтирование - команда <CODE>mount(8)</CODE>.<BR>
<BR>
Обычно поключаемые устройства отображаются на каталог <CODE>/mnt</CODE>. Например <CODE>/mnt/cdrom</CODE>, <CODE>/mnt/floppy</CODE>.<BR>
<BR>
Отключение (<EM>размонтирование</EM>) производит отсоединение устройства от дерева каталогов. Команда <CODE>umount(8)</CODE>.<BR>
<BR>
<!--TOC section Копирование, удаление, перемещение файлов и каталогов-->

<H2 CLASS="section"><A NAME="htoc13">2.4</A>&nbsp;&nbsp;Копирование, удаление, перемещение файлов и каталогов</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>cp</CODE> - копирование
<PRE CLASS="verbatim">
копирование одного файла в другой
$ cp src.file /tmp/dest.file1

копирование нескольких файлов в другой каталог
$ cp *.tex metoda.dvi /mnt/floppy

копирование каталогов
$ cp -r metoda /archive/old.Docs
</PRE><BR>
<BR>
<LI CLASS="li-itemize"><CODE>rm</CODE> - удаление файлов и <CODE>rmdir</CODE> - удаление каталогов<SUP><A NAME="text6" HREF="#note6">5</A></SUP>
<PRE CLASS="verbatim">
простое удаление
$ rm part1.aux intro.temp

удаление всех файлов из каталога 
$ rm /tmp/*

удаление каталога
$ rmdir oLD.stupid.dir
</PRE><BR>
<BR>
<LI CLASS="li-itemize"><CODE>mv</CODE> - переместить(переименовать)
<PRE CLASS="verbatim">
переместить один файл в другой
$ mv src.file /tmp/dest.file1

перемещение нескольких файлов в другой каталог
$ mv *.tex metoda.dvi /mnt/floppy

перемещение каталогов
$ mv metoda /archive/old.Docs
</PRE><BR>
<BR>
<LI CLASS="li-itemize"><CODE>mkdir</CODE> - создать каталог
<PRE CLASS="verbatim">
cоздать 1 или более каталогов
$ mkdir /tmp/dir.12345
$ mkdir empty.DIR DiRecTorY
</PRE></UL>
<!--TOC section Информация о системе-->

<H2 CLASS="section"><A NAME="htoc14">2.5</A>&nbsp;&nbsp;Информация о системе</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>ps</CODE> - список запущенных процессов
<LI CLASS="li-itemize"><CODE>who</CODE> - список пользователей, работающих в системе 
<LI CLASS="li-itemize"><CODE>date</CODE> - текущая дата и время
<LI CLASS="li-itemize"><CODE>w</CODE> - общая информация о системе
</UL>
<PRE CLASS="verbatim">
Примеры:
Процессы на текущей консоли
$ ps
 3642 pts/1    00:00:00 bash
 4548 pts/1    00:00:00 ps

Процессы конкретного пользователя
$ ps -u user
 1766 ?        00:00:04 xterm
 1853 pts/2    00:00:13 vim
 3642 pts/1    00:00:00 bash
 4553 pts/1    00:00:00 ps

Все процессы
$ ps -ef (для BSD и Linux - ps ax )
UID        PID  PPID  C STIME TTY          TIME CMD
user      1766  1176  0 06:45 ?        00:00:04 xterm -title Terminal
user      1768  1766  0 06:45 pts/2    00:00:00 bash
user      1853  1768  0 06:56 pts/2    00:00:13 vim part2.tex
 &lt;пропущено - список 52 строки&gt;

$ date
Сбт Июн 15 10:34:17 EEST 2002

$ who
root     tty1     Jun 15 10:24
work     tty2     Jun 15 10:24
user     pts/1    Jun 15 09:18

$ w
 10:35am  up  4:14,  3 users,  load average: 0.09, 0.04, 0.01
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU  WHAT
root     tty1     -                10:24am 11:25   0.02s  0.02s  -bash 
work     tty2     -                10:24am 11:11   0.03s  0.03s  -bash 
user     pts/1    -                 9:18am  1.00s  0.14s  0.01s  w 
</PRE>
<!--TOC section Общение между пользователями-->

<H2 CLASS="section"><A NAME="htoc15">2.6</A>&nbsp;&nbsp;Общение между пользователями</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>write пользователь</CODE> - послать сообщение<SUP><A NAME="text7" HREF="#note7">6</A></SUP>
<PRE CLASS="verbatim">
$ write stud11
набрать текст сообщения
нажать &lt;ctrl+d&gt;
</PRE><LI CLASS="li-itemize"><CODE>talk пользователь</CODE> - двухсторонний чат 
<LI CLASS="li-itemize"><CODE>mail</CODE> - электронная почта
<PRE CLASS="verbatim">
Послать письмо
$  mail stud7 //локальному пользователю
Subject: test
набрать текст сообщения
нажать &lt;ctrl+d&gt;

$ mail user@tut.by //удаленному пользователю
.....

$ mail // просмотреть свою почту
.....
</PRE></UL>
<!--TOC section Просмотр, создание, объединение файлов-->

<H2 CLASS="section"><A NAME="htoc16">2.7</A>&nbsp;&nbsp;Просмотр, создание, объединение файлов</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>cat</CODE> - вывод содержимого файла на экран 
<LI CLASS="li-itemize"><CODE>more</CODE> - разбиение входного файла на страницы
<LI CLASS="li-itemize"><CODE>less</CODE> - просмотр файлов (выход по клавише <CODE>q</CODE>)
</UL>
<PRE CLASS="verbatim">
Примеры
Вывод на экран файла
$ cat file

Копирование файла
$ cat file &gt;file2

Объединение 2-х файлов в третий
$ cat file1 file2 &gt;end.file

Постраничный вывод файла на экран
$ cat large.file |more 

Ввод файла с клавиатуры
$ cat &gt;new.text
&lt;набирается текст&gt;
&lt;ctrl+d&gt;

</PRE>
<!--TOC section Объединение команд-->

<H2 CLASS="section"><A NAME="htoc17">2.8</A>&nbsp;&nbsp;Объединение команд</H2><!--SEC END -->
 
Идеологически, Unix - это собрание большого количества небольших утилит, выполняющих какую-то одну локальную задачу. Но делающими свою задачу лучше всего, во всех возможных вариантах и режимах. <BR>
<BR>
<EM>Фильтры</EM> - это программы, предназначенные для обработки текста тем или иным способом.<BR>
<BR>
Часто они применяются в связке с другими командами, образуя <EM>конвейеры</EM>. Конвейер обозначается символом <CODE>|</CODE>. Его значение следующее: програма слева от конвейера передает свой вывод на вход программы справа от конвейера<SUP><A NAME="text8" HREF="#note8">7</A></SUP>. Простейший пример: <CODE>$ cat myFILE|more</CODE><SUP><A NAME="text9" HREF="#note9">8</A></SUP>. В Unix этот метод называют <EM>перенаправление</EM>. Подробнее о перенаправлении - в <A HREF="#redirect">3.4</A>.<BR>
<BR>
В общем случае, фильтры читают свой <EM>стандартный ввод</EM> и пишут на <EM>стандартный вывод</EM>. Если не было перенаправления, то вводом считается клавиатура, а выводом - экран.
<DIV CLASS="center">
Часто употребимые фильтры
</DIV>
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>grep</CODE><SUP><A NAME="text10" HREF="#note10">9</A></SUP> - поиск в файле по образцу<BR>
<CODE>Пример: $ ls /usr/include | grep "stdlib.h" </CODE>
<LI CLASS="li-itemize"><CODE>sort</CODE> - сортировка содержимого
<LI CLASS="li-itemize"><CODE>wc</CODE> - статистика по файлу (кол-во букв, байт, строк и т.п.)
<LI CLASS="li-itemize"><CODE>head</CODE> и <CODE>tail</CODE> - показать начало(head) и конец(tail) файла
<LI CLASS="li-itemize"><CODE>tee</CODE> - одновременный вывод в файл и на экран<BR>
<CODE>Пример: $ ls -1 /tmp | tee all.tempfiles</CODE>
</UL>
<!--TOC section Приемы эффективной работы-->

<H2 CLASS="section"><A NAME="htoc18">2.9</A>&nbsp;&nbsp;Приемы эффективной работы</H2><!--SEC END -->

Оболочка <CODE>bash</CODE> обладает 3 базовыми средствами автоматизации<SUP><A NAME="text11" HREF="#note11">10</A></SUP>, делающими работу в командной строке простой и легкой:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Автодополнение путей и команд<BR>
<BR>
<EM>Использование</EM>: набрать 1 или более начальных символов команды и нажать <CODE>TAB</CODE>. Если символов хватает для определения команды, то недостающие будут добавлены автоматически. Если существует более 1 подходящей команды, то при повторном нажатиии <CODE>TAB</CODE> на экран высветиться список возможных команд. Можно тогда добавить несколько букв и однозначно определить команду.
<PRE CLASS="verbatim">
$ la&lt;TAB&gt;
lambda      last        lastb       lastlog     latex       latex2html
$ last&lt;TAB&gt;
last     lastb    lastlog  
$ lastb&lt;ENTER&gt;
lastb: /var/log/btmp: No such file or directory
Perhaps this file was removed by the operator to prevent logging lastb info.
</PRE>Для поиска комманд используется переменная PATH (см. <A HREF="#path">2.1</A>). <BR>
<BR>
Точно так же работает автодополнение для путей: вводиться кусочек пути и после нажатия &lt;TAB&gt; происходит дополнение пути.<BR>
<EM>Примечание</EM>. Автодополнение не работает для ключей комманд (<CODE>ls --he&lt;TAB&gt;</CODE> - будет безрезультатным) и для аргументов комманды <CODE>man</CODE>.
<LI CLASS="li-enumerate">История команд<BR>
<BR>
Для просмотра истории - <CODE>history</CODE>. Для обращения к конкретному пункту истории - <CODE>!номер</CODE>. Можно прокручивать историю с помощью клавиш <CODE>"вверх"</CODE> и <CODE>"вниз"</CODE>. 
<LI CLASS="li-enumerate">Редактирование командной строки<BR>
<BR>
Возможно с помощью клавиш <CODE>"вправо"</CODE> и <CODE>"влево"</CODE>. На начало строки - <CODE>ctrl+a</CODE>, на конец - <CODE>ctrl+e</CODE>.
</OL>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note2" HREF="#text2"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Будет показана <EM>только первая</EM> доступная статья
<DT CLASS="dt-list"><A NAME="note3" HREF="#text3"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Здесь приведены только те разделы, которые будут активно использоватьсяв рамках курса ОСиС. Описания других разделов вы сможете найти в книгах [<A HREF="#Rob"><CITE>1</CITE></A>] и [<A HREF="#Pet"><CITE>9</CITE></A>]
<DT CLASS="dt-list"><A NAME="note4" HREF="#text4"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">в основном это касается команд написанных проектом GNU
<DT CLASS="dt-list"><A NAME="note5" HREF="#text5"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">можно создать файл или каталог с именем из одних точек
<DT CLASS="dt-list"><A NAME="note6" HREF="#text6"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">работает только для <EM>пустых</EM> каталогов
<DT CLASS="dt-list"><A NAME="note7" HREF="#text7"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list"> ctrl+d воспринимается системой как конец ввода
<DT CLASS="dt-list"><A NAME="note8" HREF="#text8"><FONT SIZE=5>7</FONT></A><DD CLASS="dd-list">конвейер может применяться несколько раз
<DT CLASS="dt-list"><A NAME="note9" HREF="#text9"><FONT SIZE=5>8</FONT></A><DD CLASS="dd-list">То что выводит cat посылается на вход more. А more выступает здесь в качестве простого фильтра.
<DT CLASS="dt-list"><A NAME="note10" HREF="#text10"><FONT SIZE=5>9</FONT></A><DD CLASS="dd-list">Существует целое семейство grep-команд : grep, egrep, fgrep
<DT CLASS="dt-list"><A NAME="note11" HREF="#text11"><FONT SIZE=5>10</FONT></A><DD CLASS="dd-list">Подробнее об автоматизации BASH - в [<A HREF="#Asp"><CITE>12</CITE></A>], [<A HREF="#Pet"><CITE>9</CITE></A>], man bash
</DL>
<!--END NOTES-->
<!--TOC chapter Shell (оболочка)-->

<H1 CLASS="chapter"><A NAME="htoc19">Chapter&nbsp;3</A>&nbsp;&nbsp;Shell (оболочка)</H1><!--SEC END -->

<!--TOC section Понятие оболочки-->

<H2 CLASS="section"><A NAME="htoc20">3.1</A>&nbsp;&nbsp;Понятие оболочки</H2><!--SEC END -->

<EM>Оболочки (командные интерпретаторы, процессоры, shells)</EM> представляют собой промежуточные уровень между пользователем и ОС. Они анализируют командную строку, выполняют преобразования аргументов команд, находя и выполняя команды.<BR>
<BR>
Shell это обычная прикладная программа. Она не является частью ядра, и поэтому может быть заменена на любую другую, например, на игрушку или текстовый редактор. Из оболочки может быть запущена другая оболочка (или такая же), что дает дополнительные возможности.<BR>
<BR>
Виды shell: sh, csh, ksh, zsh, tcsh, ash и другие.<BR>
<BR>
В курсе будет рассматриваться <EM>Bourne Shell - sh</EM>. Оболочки, совместимые с Bourne Shell существуют для все версий Unix. На лабораторных работах будет использоваться <CODE>bash</CODE> (Bourne Again SHell).<BR>
<BR>
<!--TOC section Bourne Shell-->

<H2 CLASS="section"><A NAME="htoc21">3.2</A>&nbsp;&nbsp;Bourne Shell</H2><!--SEC END -->

<EM>Сценарий (скрипт)</EM> оболочки представляет собой текстовый файл, который задает выполнение последовательности действий. Сценарий может содержать любую последовательность команд (как внутренних команд оболочки, так и внешних команд UNIX, с аргументами или без них), вызовов программ или других написанных ранее сценариев.<BR>
<BR>
Про Shell можно сказать, что это и программа и язык программирования.<BR>
<BR>
Работа пользователя в командной сроке ничем не отличается от выполнения длинного запутанного скрипта.<BR>
<BR>
Механизм работы скрипта: при запуске скрипта из командной строки запускается копия интерпретатора, для которого вводом служит скрипт (как-будто пользователь сам вводил эти команды).<BR>
<BR>
<EM>Способы запуска</EM>: по имени, bash имя.<BR>
Для запуска по имени, файл скрипта должнен иметь атрибут X (eXecutable - исполняемый). Подробнее об атрибутах будет расказано в <A HREF="#attrib">??</A> <BR>
<BR>
<!--TOC subsection Структура скриптов-->

<H3 CLASS="subsection"><A NAME="htoc22">3.2.1</A>&nbsp;&nbsp;Структура скриптов</H3><!--SEC END -->
<BR>
<BR>
<CODE>#</CODE> - то, что следует за ним(в том числе и другие <CODE>#</CODE>), является комментарием. Комментарии могут занимать всю строку или следовать за командой.<BR>
<CODE>\</CODE> - обозначает, что строка продолжится на следующей строке файла.<BR>
<BR>
Можно записать несколько команд в 1 строку, разделенных <CODE>;</CODE> <A NAME="tz"></A>.<BR>
<BR>
<!--TOC section Переменные-->

<H2 CLASS="section"><A NAME="htoc23">3.3</A>&nbsp;&nbsp;Переменные</H2><!--SEC END -->

Значение переменной - строка, которая передается присваиванием.<BR>
<CODE>V1 = 5; v2 = "string"</CODE> <SUP><A NAME="text12" HREF="#note12">1</A></SUP><BR>
Переменной также можно присваивать значение, которое возвращается командой.<BR>
<CODE>V3 = `pwd`</CODE><BR>
<BR>
<DIV CLASS="center">
Получение значения
</DIV> 
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$имя_переменной</CODE> - в это место подставляется значение переменной.
<LI CLASS="li-itemize"><CODE>$(имя_переменной)</CODE> - отделяем переменную от последующих символов.
<PRE CLASS="verbatim">
Пример: 
$ echo result = $(v1)2 +
result = 52+
</PRE></UL>
В shell существует ряд <EM>предопределенных</EM> переменных<SUP><A NAME="text13" HREF="#note13">2</A></SUP>:
<UL CLASS="itemize"><LI CLASS="li-itemize">
	<CODE>HOME</CODE> - домашний каталог пользователя
	<LI CLASS="li-itemize"><CODE>PATH</CODE> - путь поиска исполняемых программ 
	<LI CLASS="li-itemize"><CODE>MAIL</CODE> - полное имя файла с почтой пользователя
	<LI CLASS="li-itemize"><CODE>PS1,PS2</CODE> - первичное и вторичное приглашение shell (Значок <CODE>$</CODE>, который пишется в примерах - это первичное приглашение).
</UL>
В shell существует ряд переменных, которые определяются оболочкой по ходу выполнения скриптов. Это так называемые <EM>встроенные</EM> переменные:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	<CODE>$0, $1, $2, ... ,$9</CODE> значения параметров, передаваемых скрипту из командной строки. 
	<LI CLASS="li-enumerate"><CODE>$0</CODE> - имя самого скрипта.<BR>
		<EM>Примечание</EM>: хороший стиль программирования выдавать имя скрипта по <CODE>$0</CODE> в выдаваемом скриптом сообщении.
	<LI CLASS="li-enumerate"><CODE>$#</CODE> - число параметров, переданных скрипту;
	<LI CLASS="li-enumerate"><CODE>$*</CODE> - все параметры, переданные скрипту. Представляют собой единое слово, заключенное в кавычки.
</OL>
Существуют три вида кавычек при присваивании переменных:
<UL CLASS="itemize"><LI CLASS="li-itemize">
	<CODE>' '</CODE> - непосредственная подстановка, например: <CODE>v4='$v1'</CODE> присвоит <CODE>$v1</CODE>, а не 5.
	<LI CLASS="li-itemize"><CODE>" "</CODE> - подстановка после интерпретации символов <CODE>\</CODE> и <CODE>$</CODE>. Например: <CODE>v5=$v1</CODE>. Переменной <CODE>v5</CODE> присвоится 5.
		Записи без подстановочных символов эквивалентны. 
		<PRE CLASS="verbatim">
  Например присваивание
          v6=string
          v7="string"
          v8='string'
  даст одинаковый результат. Кавычки одного вида экранируют другие.
  </PRE>	<LI CLASS="li-itemize"><CODE>` `</CODE> - выполнение команды внутри скобок. Результат выполнения команды будет присвоен переменной.<BR>
	<CODE>Пример: $list=`ls -a`</CODE>
</UL>
По умолчанию все переменные локальны, то есть существуют, пока выполняется скрипт. Чтобы сделать их глобальными (для данного shell), надо задать их при помощи export. <CODE>например: export v1</CODE><BR>
<BR>
При выводе неопределенных переменных результатом будет пустая строка.<BR>
<BR>
Для удаления переменной используется <CODE>unset список_переменных</CODE>. <CODE>Пример: $ unset $v1 $v3 $v4</CODE><BR>
<BR>
Команда <CODE>set</CODE> выводит список всех установленных переменных shell.<BR>
<BR>
<!--TOC section Перенаправление ввода/вывода-->

<H2 CLASS="section"><A NAME="htoc24">3.4</A>&nbsp;&nbsp;Перенаправление ввода/вывода</H2><!--SEC END -->
.<BR>
<BR>
<A NAME="redirect"></A>Каждая программы, запущенная из shell, получает три открытых потока ввода/вывода, которые по умолчанию ассоциируются с терминалом. Потоки задаются номерами(<EM>дескрипторы</EM>):
<UL CLASS="itemize"><LI CLASS="li-itemize">
0 стандартный поток ввода, ассоциируется с клавиатурой
<LI CLASS="li-itemize">1 стандартный поток вывода, ассоциируется с экраном
<LI CLASS="li-itemize">2 стандартный поток ошибок, ассоциируется с экраном
</UL>
Большинство утилит Unix используют только стандартные потоки, поэтому для этих утилит можно осуществлять перенаправление.
<DIV CLASS="center">
Виды перенаправления
</DIV>
<UL CLASS="itemize"><LI CLASS="li-itemize">
	<CODE>&gt;file</CODE> - поток вывода перенаправляется в файл. <CODE>Пример: cat file1&gt;file2</CODE>
	<LI CLASS="li-itemize"><CODE>&gt;&gt;file</CODE> - данные из потока вывода добавляются в файл.
	<LI CLASS="li-itemize"><CODE>&lt;file</CODE> - получение данных для стандартного ввода из файла.
	<LI CLASS="li-itemize"><CODE>p1|p2</CODE> - передача вывода программы р1 на ввод программы р2 (<EM>конвейер или неименованный канал</EM>). <CODE>Пример: cat spisok | wc l</CODE>
	<LI CLASS="li-itemize"><CODE>n&gt;file</CODE> - переключение потока с номером <CODE>n</CODE> в файл.
	<LI CLASS="li-itemize"><CODE>n&gt;&gt;file</CODE> - переключение потока с дескриптором <CODE>n</CODE> в файл, но данные добавляются в конец файла.
	<LI CLASS="li-itemize"><CODE>n&gt;&amp;m</CODE> - объединить потоки с дескрипторами <CODE>n</CODE> и <CODE>m</CODE>. 
	<LI CLASS="li-itemize"><CODE>&lt;&lt;str</CODE> - конструкция <EM>"Ввод здесь"</EM>. Использует стандартный поток ввода до появления строки <CODE>str</CODE> во вводе и потом передает его на вход программе.
</UL>
<PRE CLASS="verbatim">
Примеры: 
1)ls -al | wc 1&gt;&amp;2 1&gt;&gt;wc.out
2)run 2&gt;/dev/null  подавление вывода ошибок.
</PRE>
<!--TOC section Шаблоны(wildcard's, подстановочные символы)-->

<H2 CLASS="section"><A NAME="htoc25">3.5</A>&nbsp;&nbsp;Шаблоны(wildcard's, подстановочные символы)</H2><!--SEC END -->

Оболочка позволяет делать подстановку имен. <EM>Подстановочный символ</EM> заменяется оболочкой на имена файлов, если что-то в каталоге подходит под шаблон. Это полезно в случаях, когда файлов много или необходимо выбрать несколько файлов по определенному правилу.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>*</CODE> - заменяет любое количество символов (может быть и 0) , в имени файла.
<LI CLASS="li-itemize"><CODE>?</CODE> - заменяет любой символ в имени файла.
<LI CLASS="li-itemize"><CODE>[символы]</CODE> - задает любой символ из диапазона.<CODE>[a-c1-3]</CODE> тоже что и <CODE>[abc123]</CODE>
<LI CLASS="li-itemize"><CODE>\с</CODE> - задает символ с буквально (<EM>экранирует</EM>) <A NAME="slash"></A>, если с это спецсимвол(<CODE>\,',",`,# и т.д.</CODE>).
</UL>
<PRE CLASS="verbatim">
Примеры: 
$ ls [a-d]* //все файлы, начинающиеся на a,b,c,d
$ ls x*y // все, начинающиеся на x и кончающиеся на y
$ ls *\ ? // предпоследний символ - пробел
</PRE>
<!--TOC section Условное выполнение команд-->

<H2 CLASS="section"><A NAME="htoc26">3.6</A>&nbsp;&nbsp;Условное выполнение команд</H2><!--SEC END -->

Следующая удобная возможность - <EM>условное выполнение</EM>. Его суть такова: пусть ваши действия зависят от результата выполнения предыдущих. Выше уже упоминался разделитель команд <CODE>';'</CODE> (см. <A HREF="#tz">3.2.1</A>). Но при использовании <CODE>';'</CODE> последовательность команд всегда выполниться, вне зависимости от результатов работы отдельных команд (ошибок в них). <BR>
<BR>
Для повышения гибкости работы, в Bourne Shell существуют следующие конструкции: 
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>p1&amp;&amp;p2</CODE> выполняется р1, если удачно (код возврата 0<SUP><A NAME="text14" HREF="#note14">3</A></SUP>), то запускается р2
<LI CLASS="li-itemize"><CODE>p1||p2</CODE> - выполняется р1, если неудачно (код возврата не 0), то запускается р2
<LI CLASS="li-itemize"><CODE>p1&amp;</CODE> - р1 выполняется в фоновом режиме, и shell не ждет окончания работы р1 (см. <A HREF="#jobcontrol">??</A>, Контроль заданий). Оболочка сразу выводит приглашение на ввод.
<LI CLASS="li-itemize"><CODE>(p1;p2;)</CODE> - команды выполняются последовательно в новой оболочке. 
<LI CLASS="li-itemize"><CODE>{p1;p2;}</CODE> - команды выполняются последовательно в текущей shell.
</UL>
<PRE CLASS="verbatim">
Примеры: 
1)(ps; who) | more
2)mount | wc -l &gt; mounts.number &amp;
</PRE>
<EM>Примечание</EM>: процессы в фоновом режиме не могут использовать стандартный ввод и вывод, поэтому их надо перенаправлять. Поток ошибок работает без изменений.<BR>
<BR>
<!--TOC section Условные выражения-->

<H2 CLASS="section"><A NAME="htoc27">3.7</A>&nbsp;&nbsp;Условные выражения</H2><!--SEC END -->

Синтаксис
<PRE CLASS="verbatim">
if   условие   
then 
else  
fi       
</PRE>
В shell true (0) и false (не 0) имеют обратные значения по сравнению с Си.<A NAME="shellreturncode"></A>. <SUP><A NAME="text15" HREF="#note15">4</A></SUP><BR>
<BR>
Условные выражения можно записывать в строчку, разделяя ;.<BR>
<BR>
Условием может быть результат команды. Часто используется <CODE>test</CODE> с параметрами. Наиболее употребимые значения:
<UL CLASS="itemize"><LI CLASS="li-itemize">
test s файл - является ли размер файла отличным от 0
<LI CLASS="li-itemize">test r файл - доступен ли файл для чтения
<LI CLASS="li-itemize">test f файл - существует ли файл и является ли он обычным
<LI CLASS="li-itemize">test d файл - существует ли файл и является ли он каталогом
</UL>
Можно записывать без <CODE>test</CODE>, используя то же значение в <CODE>[ ... ]</CODE>.<BR>
<BR>
<EM>Примечание</EM>. Между <CODE>[, ], if</CODE> обязательно должны стоять пробелы!
<PRE CLASS="verbatim">
Пример: следующие записи эквивалентны:
1)if test f $HOME/file.txt
then
            echo Он есть!
     fi
2)if [ -f $HOME/file.txt]
then
            echo Он есть!
     fi
3)  test f $HOME/file.txt &amp;&amp; echo Он есть!
</PRE>
<!--TOC subsection Сравнение строк-->

<H3 CLASS="subsection"><A NAME="htoc28">3.7.1</A>&nbsp;&nbsp;Сравнение строк</H3><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>строка1 = строка2</CODE> проверка на равенство
<LI CLASS="li-itemize"><CODE>строка1 != строка2</CODE> проверка на не равно
<LI CLASS="li-itemize"><CODE>-n $переменная</CODE> true, если строка имеет ненулевую длину
</UL>
<PRE CLASS="verbatim">
Примеры:
1)if [ $v1 = abc ]; then; echo Потрясающе!
2)if [ -n $empty ]; then; echo Действительно
</PRE>
<!--TOC subsection Сравнение чисел-->

<H3 CLASS="subsection"><A NAME="htoc29">3.7.2</A>&nbsp;&nbsp;Сравнение чисел</H3><!--SEC END -->

Аргументами являются <CODE>$x</CODE>(значение переменной) или число<SUP><A NAME="text16" HREF="#note16">5</A></SUP>:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>$x eq $y</CODE> true, если аргументы равны
<LI CLASS="li-enumerate"><CODE>$x ne $y</CODE> true, если аргументы не равны
<LI CLASS="li-enumerate"><CODE>$x gt $y</CODE> true, если значение x больше значения y 
<LI CLASS="li-enumerate"><CODE>$x ge $y</CODE> true, если значение x больше либо равно значению y
</OL><BR>
<BR>
<CODE>Пример:  if [ $# eq 2 ]; then; echo 2 аргумента </CODE><BR>
<BR>
<!--TOC subsection Сложные выражения-->

<H3 CLASS="subsection"><A NAME="htoc30">3.7.3</A>&nbsp;&nbsp;Сложные выражения</H3><!--SEC END -->

<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>!выражение</CODE>	- отрицание
<LI CLASS="li-enumerate"><CODE>выражение1 a выражение2</CODE>	- логическое И
<LI CLASS="li-enumerate"><CODE>выражение1 o выражение2</CODE>	- логическое ИЛИ
</OL>
<PRE CLASS="verbatim">
Пример: 
1)if [ !\( $x eq $y\) ]
2)if [ $a ne 3 a $b lt $c ]
3)if [ $x = $y a \( $n lt 0 o $m gt 30\) ]
</PRE><EM>Примечание</EM>: Скобки экранируются (см. <A HREF="#slash">3.5</A>), так как они имеют специальный смысл для команд (последовательное выполнение в новом экземпляре shell).<BR>
<BR>
<!--TOC section Циклы-->

<H2 CLASS="section"><A NAME="htoc31">3.8</A>&nbsp;&nbsp;Циклы</H2><!--SEC END -->

В языке shell есть несколько видов циклов. Часто употребимые из них:<CODE>for</CODE>, <CODE>while</CODE> .
<UL CLASS="itemize"><LI CLASS="li-itemize">
Цикл <CODE>for</CODE><SUP><A NAME="text17" HREF="#note17">6</A></SUP> выполниться столько раз, сколько слов в списке. var последовательно принимает значения из списка. Список может формироваться вручную, как вывод команды (`команда`) или с помощью шаблонов.
<PRE CLASS="verbatim">
for переменная in список
do
....
done
</PRE><LI CLASS="li-itemize">Цикл <CODE>while</CODE> выполняется, пока условие не станет ложным.
<PRE CLASS="verbatim">
while условие
do
...
done
</PRE></UL>
<PRE CLASS="verbatim">
Примеры:
while sleep 60
do
 who | grep mary
done

for user in `who`
do
  echo и этот $user здесь!
done

for i in * ; do echo $i; done  #эквивалент ls.
</PRE>
Элементы цикла можно записывать на отдельных строках или разделяя ';'. Эти формы записи эквивалентны.<BR>
<BR>
<EM>Примечание</EM>. Если вводить в командной строке цикл, условное выражение или просто не закрыть скобку (кавычки) то при нажатии <CODE>ENTER</CODE> оболочка предложит вводить окончание команды на следующей строке.<BR>
<BR>
Существует <EM>встроенная</EM>(см. <A HREF="#internalcmd">3.9</A>) команда <CODE>break</CODE> для выхода из цикла.<BR>
<BR>
<!--TOC section Функции-->

<H2 CLASS="section"><A NAME="htoc32">3.9</A>&nbsp;&nbsp;Функции</H2><!--SEC END -->

Для упорядочивания скрипта пользователь может определить функцию:
<PRE CLASS="verbatim">
имя_функции ()
{
   команды
}
</PRE>Синтаксис и передача аргументов - как у скрипта.
<PRE CLASS="verbatim">
Пример: отображает в приглашении имя каталога
mcd ()
{
  cd $*
  PS1 = `pwd`
}
</PRE>
Команды разделяются на <EM>встроенные</EM> (в оболочку) <A NAME="internalcmd"></A> и <EM>внешние</EM>. Запуск встроенной команды не требует создания нового процесса.<BR>
<BR>
Распространенные встроенные команды: <CODE>cd</CODE>, <CODE>pwd</CODE>, <CODE>echo</CODE>, <CODE>exit</CODE>, <CODE>set</CODE>, <CODE>unset</CODE>.<BR>
<BR>
<!--TOC section Выполнение арифметических операций-->

<H2 CLASS="section"><A NAME="htoc33">3.10</A>&nbsp;&nbsp;Выполнение арифметических операций</H2><!--SEC END -->

<EM>Важное замечание</EM>. В shell выполняется только целочисленная арифметика<SUP><A NAME="text18" HREF="#note18">7</A></SUP>!<BR>
<BR>
<CODE>еxpr строка</CODE> преобразует строку в число. <CODE>Например: expr 23</CODE>.<BR>
<BR>
Выполняются операции: <CODE>+, -, *, /, %</CODE> (деление по модулю). Их приоритет обычный.
<PRE CLASS="verbatim">
Примеры: 
1)a = `expr $a + 3`
2)b = `expr 2 \* 3` - символ \ отменяет специальное значение *.
</PRE><EM>Примечание</EM>. Числа и операции разделяются пробелами.

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note12" HREF="#text12"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Значения переменных будут переходить из примера в пример
<DT CLASS="dt-list"><A NAME="note13" HREF="#text13"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Полный список встроенных и предопределенных переменных можно найти в man bash
<DT CLASS="dt-list"><A NAME="note14" HREF="#text14"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Коды возврата для shell - противоположны Си (см. <A HREF="#shellreturncode">3.7</A>)
<DT CLASS="dt-list"><A NAME="note15" HREF="#text15"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Более подробно коды возврата отдельных команд описаны в man в пункте EXIT STATUS или DIAGNOSTIC или RETURN CODE
<DT CLASS="dt-list"><A NAME="note16" HREF="#text16"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Тут наблюдается некоторое сходство с ассемблером
<DT CLASS="dt-list"><A NAME="note17" HREF="#text17"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">BASH поддерживает также циклы в стиле Си: for ((i=1; <I>i</I>&lt;10; i++)) - c 2 открывающими и закрывающими скобками. 
<DT CLASS="dt-list"><A NAME="note18" HREF="#text18"><FONT SIZE=5>7</FONT></A><DD CLASS="dd-list">Для плавающей точки и сложных вычислений можно использовать программу bc
</DL>
<!--END NOTES-->
<!--TOC chapter Текстовый редактор VI-->

<H1 CLASS="chapter"><A NAME="htoc34">Chapter&nbsp;4</A>&nbsp;&nbsp;Текстовый редактор VI</H1><!--SEC END -->

Редакторы для Unix делятся на 2 группы - редакторы командного стиля(vi, emacs, joe, ed) и меню-ориентированные (mcedit, kwriter, kword).<BR>
<BR>
Редакторы командного стиля обычно работают в <EM>консольном (текстовом)</EM> режиме. Все действия в них выполняются подачей прямых управляющих команд, закрепленных за определенными сочетаниями клавиш. Мышь и меню в них, как правило, не используются.<BR>
<BR>
Редактор <CODE>vi</CODE> присутствует как стандартный в любой Unix-подобной системе<SUP><A NAME="text19" HREF="#note19">1</A></SUP>. Существует несколько редакторов основанных на vi: vim, elvis. <BR>
<BR>
Современные клоны vi (vim к примеру) обладают очень большой функциональностью, скрытой за аскетичным интерфейсом. Редактор vi изначально создавался как кросс-платформенный, который обязан работать на любых типах терминалов и виртуальных консолей. Все действия в нем можно осуществить не покидая основной, алфавитно-цифровой, части клавиатуры.<BR>
<BR>
<EM>Примечание</EM>. Далее мы будем рассматривать редактор vim. Однако все описанные команды можно будет применить в любом vi-совместимом редакторе.<BR>
<BR>
<!--TOC section Режимы работы-->

<H2 CLASS="section"><A NAME="htoc35">4.1</A>&nbsp;&nbsp;Режимы работы</H2><!--SEC END -->

В vi существует три принципиально различных режима работы:
<UL CLASS="itemize"><LI CLASS="li-itemize">
- Командный режим (command mode)
<LI CLASS="li-itemize">- Режим ввода (edit mode)
<LI CLASS="li-itemize">- Режим построчного редактирования (ex mode)
</UL>
<EM>Командный режим</EM> включается по умолчанию при запуске vi. В этом режиме нажатия клавиш <EM>не приводят</EM> к вводу символов, а интерпретируются как внутренние команды перемещения по тексту и редактирования. Поэтому попытка немедленно начать ввод текста (как в DOS/Windows) ни к чему не приведет.<BR>
<BR>
<EM>Примечание</EM>. Если вы не знаете, в каком режиме находитесь, то нажмите клавишу <CODE>ESC</CODE> для перехода в командный режим.<BR>
<BR>
Создание текста в командном режиме невозможно. Для этого нужно перейти в <EM>режим ввода</EM>. Для этого служат команды (командного режима!) <CODE>a</CODE> (от append - после текущей позиции курсора) и <CODE>i</CODE> (от insert - перед текущей позицией курсора). В режиме ввода нажатия клавиш приводят к вводу обычных символов, позволяя создавать новый текст или редактировать существующий.<BR>
<BR>
Возврат в командный режим осуществляется нажатием клавиши <CODE>escape</CODE>.<BR>
<BR>
Для операций с документами (файлами) предназначен <EM>ex-режим</EM>. Он вызывается командой <CODE>:</CODE> командного режима. После этого дается команда ex-режима. Например:
<UL CLASS="itemize"><LI CLASS="li-itemize">
открыть существующий файл (<CODE>:e имя_файла</CODE>) 
<LI CLASS="li-itemize">вставить файл в позицию курсора (<CODE>:r имя_файла</CODE>)
<LI CLASS="li-itemize">записать файл (<CODE>:w</CODE>), в том числе под другим именем (<CODE>:w имя_файла</CODE>)
<LI CLASS="li-itemize">выход из сохраненного файла (<CODE>:q</CODE>)<A NAME="viexit"></A>
<LI CLASS="li-itemize">выход с предварительным сохранением файла (<CODE>:x</CODE>)
</UL>
Когда вы находитесь в ex-режиме, то в нижнем левом углу экрана появляется <CODE>:</CODE>.<BR>
<BR>
Возможно совмещение команд ex-режима. Например <CODE>:wq</CODE>. <BR>
<BR>
Команда ex-режима отправляется на выполнение нажатием клавиши <CODE>Enter</CODE> после чего происходит возврат в командный режим.<BR>
<BR>
<EM>Примечание</EM>. Попытка загрузить новый файл (командой <CODE>:e</CODE>) или завершить работу редактора (командой <CODE>:q</CODE>) при несохраненном старом файле вызовет ошибку.<BR>
<BR>
<!--TOC section Получение помощи-->

<H2 CLASS="section"><A NAME="htoc36">4.2</A>&nbsp;&nbsp;Получение помощи</H2><!--SEC END -->

Получить справку можно используя ex-команду <CODE>:help</CODE>.<BR>
<BR>
Подразделы справки выделены значками <CODE>|раздел|</CODE>. Справку по ним вызывается через <CODE>:help раздел</CODE>.<BR>
<BR>
Очень полезным является учебник по vim - <CODE>vimtutor</CODE>. С его помощью можно освоить основные навыки использования vim.<BR>
<BR>
<!--TOC section Запуск и остановка редактора-->

<H2 CLASS="section"><A NAME="htoc37">4.3</A>&nbsp;&nbsp;Запуск и остановка редактора</H2><!--SEC END -->
<BR>
<BR>
<CODE>Vi (vim)</CODE> может быть запущен из командной строки, с именем файла или без такового. Если указано имя файла, то редактор открывает его<SUP><A NAME="text20" HREF="#note20">2</A></SUP>.<BR>
<BR>
<CODE>Пример: $ vi ~/texts/newtext.txt</CODE><BR>
<BR>
Команда vim без имени файла откроет редактор vim и выведет заставку.<BR>
<BR>
Для выхода из редактора нажмите <CODE>:q</CODE> или <CODE>:wq</CODE> (см. "Режимы работы" <A HREF="#viexit">4.1</A>). <BR>
<BR>
<!--TOC section Перемещение по тексту-->

<H2 CLASS="section"><A NAME="htoc38">4.4</A>&nbsp;&nbsp;Перемещение по тексту</H2><!--SEC END -->

В командном режиме существуют следующие команды<SUP><A NAME="text21" HREF="#note21">3</A></SUP>:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>h</CODE> - курсор влево на 1 символ
<LI CLASS="li-itemize"><CODE>l</CODE> - курсор вправо на 1 символ
<LI CLASS="li-itemize"><CODE>j</CODE> - курсор вниз на 1 строку
<LI CLASS="li-itemize"><CODE>l</CODE> - курсор вверх на 1 строку
</UL>
Также, есть расширенные команды, действующие с блоками текста.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>w и W</CODE> - перемещение вперед на "маленькое слово"<SUP><A NAME="text22" HREF="#note22">4</A></SUP> и т.н. "большое слово"<SUP><A NAME="text23" HREF="#note23">5</A></SUP> 
<LI CLASS="li-itemize"><CODE>b и B</CODE> - перемещение назад на "маленькое слово" и "большое слово" 
<LI CLASS="li-itemize"><CODE>0 и $</CODE> - на начало и на конец строки
<LI CLASS="li-itemize"><CODE>( и )</CODE> - на начало предложения и его конец 
</UL>
Вообще, для многих команд vi характерно наличие парных элементов - в нижнем и верхнем регистрах одной клавиши (<CODE>e</CODE> и <CODE>E</CODE>, <CODE>w</CODE> и <CODE>W</CODE>); действие второй команды из пары как бы расширяет действие первой.<BR>
<BR>
Команды навигации vi могут использоваться с численными аргументами.<BR>
<BR>
Например команда <CODE>5h</CODE> переместит курсор на 5 символов влево (считая символ в позиции курсора), а команда <CODE>3B</CODE> на 3 "больших" слова назад. <BR>
<BR>
Для перемещения на конкретную строку, можно использовать следующую команду ex-режима: <CODE>:N</CODE>, где N - номер строки.<BR>
<BR>
<!--TOC section Ввод и редактирование текста-->

<H2 CLASS="section"><A NAME="htoc39">4.5</A>&nbsp;&nbsp;Ввод и редактирование текста</H2><!--SEC END -->

Для создания текста необходимо перейти в режим ввода.<BR>
<BR>
Для этого служат следующие команды:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>i и I</CODE> - ввод в позиции курсора или в начале строки
<LI CLASS="li-itemize"><CODE>a и A</CODE> - ввод после курсора или в конце строки
</UL>
Текст можно изменять и в режиме ввода, используя <CODE>DEL</CODE> и <CODE>BACKSPACE</CODE>, но часто удобнее использовать команды редактирования.<BR>
<BR>
Команды редактирования предназначены для изменения существующего текста без перехода в режим ввода:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>x</CODE> - удаление одиночного символа
<LI CLASS="li-itemize"><CODE>dd</CODE> - удаление строки
<LI CLASS="li-itemize"><CODE>dw</CODE> - удаление слова
<LI CLASS="li-itemize"><CODE>d)</CODE> - удаление предложения
</UL>
Как и команды перемещения, команды редактирования можно использовать с численными аргументами. Так команда <CODE>5dd</CODE> удалит текущую строку и еще 4 строки ниже ее, а <CODE>3dw</CODE> удалит три слова считая текущее.<BR>
<BR>
<!--TOC section Копирование и вставка-->

<H2 CLASS="section"><A NAME="htoc40">4.6</A>&nbsp;&nbsp;Копирование и вставка</H2><!--SEC END -->

В vim для этих целей существует отдельный режим - выделения, Visual Selection (см. <CODE>man vim</CODE>). Однако в большинстве случаев мы можем обойтись стандартными командами:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>p</CODE> - вставить из буфера.
<LI CLASS="li-itemize"><CODE>yy</CODE> - скопировать строку в буфер
<LI CLASS="li-itemize"><CODE>yw</CODE> - скопировать текущее слово в буфер
<LI CLASS="li-itemize"><CODE>y)</CODE> - скопировать предложение
<LI CLASS="li-itemize"><CODE>y}</CODE> - скопировать абзац
</UL>
<EM>Примечание</EM>.В буфер также попадает все удаленное с помощью команд x, dd, dw и им подобных. Таким образом эти команды могут служить для копирования с удалением.<BR>
<BR>
Все вышеперечисленные команды могут использоваться с численным аргументом. Например: <CODE>3p</CODE> - 3 раза вставить содержимое буфера.<BR>
<BR>
<!--TOC section Откат действий-->

<H2 CLASS="section"><A NAME="htoc41">4.7</A>&nbsp;&nbsp;Откат действий</H2><!--SEC END -->

Действие ошибочно введенных команд редактирования может быть отменено командой <CODE>u</CODE> (сокращенно от undo). Повторное нажатие - отмена предыдущего действия, и так далее. Для возврата (redo) ошибочно отмененной операции используется <CODE>control+r</CODE>.<BR>
<BR>
<!--TOC section Поиск и замена-->

<H2 CLASS="section"><A NAME="htoc42">4.8</A>&nbsp;&nbsp;Поиск и замена</H2><!--SEC END -->

Для поиска по тексту служит команда <CODE>/</CODE> (прямой слэш). При вводе этого символа в командном режиме в нижней строке появляется символ <CODE>/</CODE>, после которого вы можете ввести образец для поиска. Это может быть текстовая строка или <EM>регулярное выражение</EM> (см. <A HREF="#regexp">5</A> ). После нажатия <CODE>ENTER</CODE> в тексте будут подсвечены <SUP><A NAME="text24" HREF="#note24">6</A></SUP> все возможные вхождения строки поиска и курсор перейдет к первому доступному найденому фрагменту вниз по тексту.<BR>
<BR>
Для поиска следующих вхождений строки поиска, существует команды <CODE>n</CODE> (вниз по тексту) и <CODE>N</CODE> (вверх по тексту).<BR>
<BR>
Для поиска и замены текстовых фрагментов, в том числе и с использованием регулярных выражений, предназначена команда ex-режима <CODE>:s</CODE>(substitute). Формат команды: <BR>
<CODE>:#s/pattern/string/опция</CODE><BR>
где <CODE>#</CODE> - интервал строк (через <CODE>,</CODE> или <CODE>;</CODE> - см. <CODE>:help cmdline-ranges</CODE>).<BR>
<BR>
<EM>Примечание</EM>. опции в стандартном vi не поддерживаются.<BR>
<BR>
Часто употребимые опции: <CODE>c</CODE> - подтверждение каждой замены, <CODE>g</CODE> - замена всех вхождений в строке.<BR>
<BR>
<EM>Примечание</EM>. Поиск и замена в vi возможны только для последовательности символов, составляющих 1 строку. Заменяющая последовательность символов тоже должна образовывать 1 строку.<BR>
<BR>
<!--TOC section Вызов внешних команд-->

<H2 CLASS="section"><A NAME="htoc43">4.9</A>&nbsp;&nbsp;Вызов внешних команд</H2><!--SEC END -->

Редактор vim часто назывют средой, так как он позволяет полноценнно работать в системе, не выходя из редактора.<BR>
<BR>
Из vi можно запускать внешние программы с помощью команды ex-режима <CODE>:! cmdlline</CODE>:
<PRE CLASS="verbatim">
Пример
:! ls -l

:! man bash
</PRE>
Так работать гораздо удобнее, так как нет надобности постоянно входить и выходить из редактора. При запуске командной строки ее вывод будет сохранен на экране до нажатия пользователем клавиши <CODE>ENTER</CODE>.<BR>
<BR>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note19" HREF="#text19"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">В этом качестве он внесен в стандарт Single Unix Specification
<DT CLASS="dt-list"><A NAME="note20" HREF="#text20"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Если файл не существует, то создается новый
<DT CLASS="dt-list"><A NAME="note21" HREF="#text21"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Обычно работают и стрелки на клавиатуре, но не стоит полагаться на них
<DT CLASS="dt-list"><A NAME="note22" HREF="#text22"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Отдельное слово, отделенное пробелом, знаками препинания, +, -
<DT CLASS="dt-list"><A NAME="note23" HREF="#text23"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Обязательно отделенное пробелом
<DT CLASS="dt-list"><A NAME="note24" HREF="#text24"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">Это справедливо только для vim
</DL>
<!--END NOTES-->
<!--TOC chapter Регулярные выражения. sed-->

<H1 CLASS="chapter"><A NAME="htoc44">Chapter&nbsp;5</A>&nbsp;&nbsp;Регулярные выражения. sed</H1><!--SEC END -->

<A NAME="regexp"></A>
<EM>Регулярные выражения (regular expression или regexp)</EM> - специальные строки символов, которые задаются для поиска совпадающих фрагментов. Иначе говоря это способ описания наборов букв. <BR>
<BR>
Простейшим набором является слово, но регулярное выражение может включать и глобальные символы, заменяющие другие символы. Все UNIX-программы, осуществляющие поиск в тексте, используют регулярные выражения. Если слово или фраза описаны регулярным выражением, говорят, что они соответствуют регулярному выражению. <BR>
<BR>
<EM>Регулярные выражения</EM> - мощное, гибкое и эффективное средство обработки текстов. Универсальные шаблоны регулярных выражений сами по себе напоминают миниатюрный язык программирования, предназначенный для описания и анализа текста. При дополнительной поддержке со стороны конкретной утилиты или языка программирования регулярные выражения способны вставлять, удалять, выделять текстовые данные любого вида и выполнять практичяески любые операции над ними.<BR>
<BR>
Регулярные выражения расширяют принципы <EM>метасимволов (шаблонов или wildcards)</EM>. <BR>
<BR>
Некоторые программы используют регулярные выражения в чистом виде (grep, egrep). Но чаще всего регулярные выражения используются внутри специальных языковых конструкций, т. н. "оберток". <BR>
<BR>
<!--TOC section Структура регулярных выражений-->

<H2 CLASS="section"><A NAME="htoc45">5.1</A>&nbsp;&nbsp;Структура регулярных выражений</H2><!--SEC END -->

Регулярное выражение состоит из двух типов символов. Специальные символы называются <EM>метасимволами</EM>. Все остальные символы (то есть обычный текст), называются <EM>литералами</EM>.<BR>
<BR>
Регулярные выражения можно рассматривать как самостоятельный язык, в котором литералы выполняют функции слов, а метасимволы - функции грамматических элементов. Слова по определенным правилам объединяются сграмматическими элементами и создают конструкции, выражающие некоторую мысль.<BR>
<BR>
Для примера: существует утилита <CODE>grep</CODE><SUP><A NAME="text25" HREF="#note25">1</A></SUP>. При запуске программе <CODE>grep</CODE> передается регулярное выражение и список просматриваемых файлов. Она сопоставляет regexp с каждой строкой файла и выводит только те строки, в которых было найдено совпадение.
<PRE CLASS="verbatim">
$ grep 'cat' file1.text 
</PRE>Если в нашем выражении (&#8988; <I>cat</I> &#8991; <SUP><A NAME="text26" HREF="#note26">2</A></SUP>) не используются метасимволы, оно фактически превращается в стредство "простого поиска текста". Будут найдены и выведены все строки файла, содержащие три стоящие подряд буквы <CODE>c, a</CODE> и <CODE>t</CODE>. Среди них будут выведены строки, в которых встречается слово (к примеру) <CODE>vacation</CODE>. Даже если в строке нет слова <CODE>cat</CODE>, последовательность букв <CODE>c</CODE> <CODE>a</CODE> <CODE>t</CODE> в слове <CODE>vacation</CODE> все равно считается успешно найденной. Необходимо только наличие указанных символов.<BR>
<BR>
<!--TOC section Правила для регулярных выражений-->

<H2 CLASS="section"><A NAME="htoc46">5.2</A>&nbsp;&nbsp;Правила для регулярных выражений</H2><!--SEC END -->

Существует всего два универсальных правила для регулярных выражений:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Предпочтение отдается тому совпадению, которое начинается раньше.
<LI CLASS="li-enumerate">Квантификаторы (см. <A HREF="#requant">5.5</A>) всегда работают максимально. Если некоторый элемент может совпадать переменное число раз, механизм всегда пытается найти максимальное число повторений.
</OL>
Признаки хорошо написанного регулярного выражения:
<UL CLASS="itemize"><LI CLASS="li-itemize">
регулярное выражение должно совпадать там где нужно и нигде более
<LI CLASS="li-itemize">регулярное выражение должно быть понятным и управляемым
<LI CLASS="li-itemize">оно должно быть эффективным ( быстро приводить к совпадению или несовпадению в зависимости от результатов поиска)
</UL>
<!--TOC section Диалекты регулярных выражений-->

<H2 CLASS="section"><A NAME="htoc47">5.3</A>&nbsp;&nbsp;Диалекты регулярных выражений</H2><!--SEC END -->

В разных программах регулярные выражения выполняют разные функции, поэтому наборы метасимволов и другие возможности, поддерживаемые программами, также различаются.<BR>
<BR>
К примеру, диалекты регулярных выражений в sed, perl и grep имеют значительное число отличий между собой. Более того, различные варианты grep тоже могут использовать разные диалекты. <BR>
<BR>
Далее изложение будет придерживаться диалекта <CODE>sed</CODE>, с указанием отличий от других реализаций регулярных выражений.<BR>
<BR>
<!--TOC section Метасимволы-->

<H2 CLASS="section"><A NAME="htoc48">5.4</A>&nbsp;&nbsp;Метасимволы</H2><!--SEC END -->

Существует несколько типов метасимволов, выполняющих разные функции. Значение некоторых из них различно в разных частях выражения (или зависит от контекста).<BR>
<BR>
<!--TOC subsection Начало и конец строки-->

<H3 CLASS="subsection"><A NAME="htoc49">5.4.1</A>&nbsp;&nbsp;Начало и конец строки</H3><!--SEC END -->

&#8988;<CODE>^</CODE>&#8991; (крышка) и &#8988; $ &#8991;(доллар) представляют собой начало и конец проверяемой строки.<BR>
<BR>
Примеры:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
&#8988; <CODE>^cat</CODE> &#8991; находит все строки, в начале которых находиться <CODE>cat</CODE>.
<LI CLASS="li-enumerate">&#8988; <CODE>^cat$</CODE> &#8991; находит все строки, которые состоят только из <CODE>cat</CODE>
<LI CLASS="li-enumerate">&#8988; <CODE>^$</CODE> &#8991; пустая строка
</OL>
Особенность &#8988; <CODE>^</CODE> &#8991; и &#8988; $ &#8991; в том, что они совпадают с определенной <EM>позицией</EM> строки, а не с символами текста.<BR>
<BR>
<!--TOC subsection Символьные классы-->

<H3 CLASS="subsection"><A NAME="htoc50">5.4.2</A>&nbsp;&nbsp;Символьные классы</H3><!--SEC END -->

<!--TOC subsubsection Совпадение с одним символом из нескольких возможных-->

<H4 CLASS="subsubsection">Совпадение с одним символом из нескольких возможных</H4><!--SEC END -->

При помощи конструкции &#8988;[&hellip;]&#8991;, называемой <EM>символьным классом</EM> (character class), можно перечислить символы, которые могут находиться в данной позиции текста. <BR>
<BR>
Примеры:<A NAME="examplegray"></A>
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
&#8988; <I>gr</I>[<I>ea</I>]<I>y</I>&#8991;. Это обозначает "найти символ <CODE>g</CODE>, за которым идет <CODE>r</CODE>, за которым следуют <CODE>e</CODE> или <CODE>a</CODE> и все это завершается символом <CODE>y</CODE>".
<LI CLASS="li-enumerate">&#8988;[<I>Ss</I>]<I>eparate</I>&#8991;. возможная смена регистра в первой букве
</OL>
Количество символов в классе может быть любым. Например, класс &#8988;[123456]&#8991; совпадает с любой из перечисленных цифр.<BR>
<BR>
В контексте (внутри) символьного класса <EM>метасимвол символьного класса</EM> <CODE>-</CODE> обозначает интервал символов; так выражение &#8988;[1&minus;6]&#8991; эквивалентно предыдущему примеру. Классы &#8988;[0&minus;9]&#8991; и &#8988;[<I>a</I>&minus;<I>z</I>]&#8991; обычно используются для поиска цифр и символов нижнего регистра соответственно.<BR>
<BR>
Символьный класс может содержать несколько интервалов, поэтому класс &#8988;[0123456789<I>abcdefABCDEF</I>]&#8991; записывается в виде &#8988;[0&minus;9<I>a</I>&minus;<I>fA</I>&minus;<I>F</I>]&#8991;. Интервалы также можно записывать вместе с литералами: &#8988;[0&minus;9<CODE>_!.?</CODE><I>A</I>&minus;<I>Z</I>]&#8991; (совпадет со всеми цифрами, буквами в верхнем регистре и знаками подчеркивания, точки, восклицательного и вопросительного знаков).<BR>
<BR>
<EM>Примечание 1</EM>. Дефис выполняет функции метасимвола только внутри символьного класса - в остальных случаях он совпадает с обычным дефисом в строке.<BR>
<BR>
<EM>Примечание 2</EM>. Правила, определяющие состав поддерживаемых метасимволов (и их функции) внутри класса и за его пределами, полностью различны.<BR>
<BR>
<EM>Примечание 3</EM>. Дефис не интерпретируется как метасимвол, если он находиться на первой позиции класса, например &#8988; [<CODE>-./</CODE>] &#8991;.<BR>
<BR>
<!--TOC subsubsection Инвертированые символьные классы-->

<H4 CLASS="subsubsection">Инвертированые символьные классы</H4><!--SEC END -->

Есле вместо &#8988;[&hellip;]&#8991; используется запись &#8988;[<CODE>^</CODE>&hellip;]&#8991;, класс совпадает с любыми символами <EM>не входящими</EM> в приведенный список. Пример: &#8988; <I>q</I>[<CODE>^</CODE><I>u</I>]&#8991;.<BR>
<BR>
Префикс <CODE>^</CODE> инвертирует список - вместо того, чтобы перечислять символы, принадлежащие классу, перечисляются символы, не входящие в него.<BR>
<BR>
<EM>Примечание</EM>. Инвертированный класс означает "совпадение с символами не входящими в список", а не "несовпадение с символами, входящими в список". Поэтому инвертированный класс удобно рассматривать как сокращенную форму записи для обычного класса, включающего все символы, <EM>кроме</EM> перечисленных.<BR>
<BR>
<!--TOC subsection Один произвольный символ-->

<H3 CLASS="subsection"><A NAME="htoc51">5.4.3</A>&nbsp;&nbsp;Один произвольный символ</H3><!--SEC END -->

Метасимвол &#8988; . &#8991; (точка) представляет собой сокращенную форму записи для символьного класса, содержащего <EM>все</EM> символы. Применяется в тех случаях, когда в некоторых позициях регулярного выражения могут находиться произвольные символы.<BR>
<BR>
Пример: пусть надо найти дату, которая может быть записана в формате <CODE>07/04/76</CODE>, <CODE>07-06-76</CODE> или <CODE>07.06.76</CODE>. Самый простой вариант - &#8988; 07.04.76 &#8991;. Но такое выражение будет совпадать и со строкой <CODE>19 207304 7639</CODE>. Выражение &#8988; 07[&minus;./]04[&minus;./]76 &#8991; обеспечевает более точное совпадение, но его труднее читать и записывать.<BR>
<BR>
При построении регулярных выражений часто приходиться идти на компромис с точноcтья за счет знания текста. Если вы уверены, что в тексте &#8988; 07.04.76 &#8991; наверняка не вызовет нежелательных совпадений, то этим вариантом вполне можно воспользоваться. <BR>
<BR>
Замечание. <EM>Знание целевого текста - важный фактор, обеспечивающий эффективное использование регулярных выражений</EM><BR>
<BR>
<!--TOC subsection Выбор-->

<H3 CLASS="subsection"><A NAME="htoc52">5.4.4</A>&nbsp;&nbsp;Выбор</H3><!--SEC END -->

<!--TOC subsubsection Одно из нескольких выражений-->

<H4 CLASS="subsubsection">Одно из нескольких выражений</H4><!--SEC END -->

<A NAME="reor"></A>
Очень удобный символ &#8988; <CODE>\|</CODE> &#8991; <SUP><A NAME="text27" HREF="#note27">3</A></SUP> обозначает "или". Он позволяет объединить несколько регулярных выражений в одно, совпадающее с любым из выражений-компонентов. <BR>
<BR>
Например, &#8988; <I>Erik</I> &#8991; и &#8988; <I>Bobby</I> &#8991; - два разных выражения, а &#8988; <I>Erik</I><CODE>\|</CODE><I>Bobby</I> &#8991; - одно выражение, совпадающее с любой из этих строк. Подвыражения, объединенные этим способом, называются <EM>альтернативами</EM> (alternatives).<BR>
<BR>
Конструкция выбора всегда является высокоуровневой (то есть обладающей очень низким приоритетом).<BR>
<BR>
Вернемся к примеру 1 из <A HREF="#examplegray">5.4.2</A> &#8988; <I>gr</I>[<I>ae</I>]<I>y</I> &#8991;. Это выражение можно записать также в виде &#8988; <I>gray</I> \ &#8739; <I>grey</I> &#8991; или даже &#8988; <CODE>gr\(a\|e\)y</CODE> &#8991;<SUP><A NAME="text28" HREF="#note28">4</A></SUP>. Здесь круглые скобки <CODE>\(</CODE> и <CODE>\)</CODE> отделяют конструкцию выбора от остального выражения. Без скобок &#8988; <I>gra</I>&#8739; <I>ey</I> &#8991; будет означать "&#8988; <I>gra</I> &#8991; или &#8988; <I>ey</I> &#8991;".<BR>
<BR>
Выражение внутри скобок может быть как угодно сложным, но "снаружи" оно воспринимается как единое целое.<BR>
<BR>
<EM>Примечание</EM>. Не путайте конструкцию выбора с символьным классом. Класс &#8988; <I>abc</I> &#8991; и конструкция выбора &#8988; <CODE>\(a\|b\|c\)</CODE> &#8991; фактически обозначают одно и то же, но это не для общего случая. Символьный класс совпадает ровно с одним символом, каким бы длинным или коротким не был список допустимых символов. С другой стороны, конструкция выбора может содержать альтернативы произвольной длинны, совершенно не связанные друг с другом длиной текста: &#8988; <CODE>\(1.000.000\|million\|thousand*thousand\)</CODE> &#8991;. В отличие от символьных классов, конструкции выбора не могут инвертироваться.<BR>
<BR>
<!--TOC subsection Границы слов-->

<H3 CLASS="subsection"><A NAME="htoc53">5.4.5</A>&nbsp;&nbsp;Границы слов</H3><!--SEC END -->

Одна из распространенных проблем заключается в том, что искомое слово встречается внутри других слов. Для явного указания начала и конца слова используются <EM>метапоследовательности</EM> &#8988; \&lt; &#8991; и &#8988; \&gt; &#8991;<BR>
<BR>
Как и якоря <CODE>^</CODE> и <CODE>$</CODE>, эти метапоследовательности не соотвествуют конкретным символам.<BR>
<BR>
Примеры:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
&#8988; <CODE>\&lt;cat\&gt;</CODE> &#8991; - найти отдельное слово <CODE>cat</CODE>
<LI CLASS="li-enumerate">&#8988; <CODE>\&lt;free</CODE> &#8991; - найти слово, начинающееся с <CODE>free</CODE>, к примеру <CODE>freeware</CODE>
<LI CLASS="li-enumerate">&#8988; <CODE>ed\&gt;</CODE> &#8991;- найти слова, заканчивающиеся на <CODE>ed</CODE>
</OL>
<EM>Примечание</EM> Сами по себе символы &#8988; &lt; &#8991; и &#8988; &gt; &#8991; метасимволами не являются. Они приобретают особый смысл только в сочетании с обратным слэшем <CODE>\</CODE>. <BR>
<BR>
<!--TOC section Квантификаторы-->

<H2 CLASS="section"><A NAME="htoc54">5.5</A>&nbsp;&nbsp;Квантификаторы</H2><!--SEC END -->
 
<A NAME="requant"></A>
<EM>Квантификаторы</EM> регулируют количество экземпляров повторяющегося элемента. Сами по себе, квантификаторы не являются щаблонами символов в тексте, но поставленные после символа или выражения в скобках, указывают, сколько раз может повторяться этот символ или выражение.<BR>
<BR>
Квантификаторы руководствуются критерием максимального совпадения и пытаются найти совпадение как можно большей длины.<BR>
<BR>
<!--TOC subsection Необязательные элементы-->

<H3 CLASS="subsection"><A NAME="htoc55">5.5.1</A>&nbsp;&nbsp;Необязательные элементы</H3><!--SEC END -->

Метасимвол &#8988; <CODE>\?</CODE> &#8991; <SUP><A NAME="text29" HREF="#note29">5</A></SUP> (вопросительный знак) означает "необязательный символ". Он ставиться после символа, который может находиться в данной позиции текста, но наличие которого не требуется для успешного совпадения. Вопросительный знак относиться <EM>только</EM> к символу, расположенному непосредственно перед ним.<BR>
<BR>
Пример: &#8988; <CODE>colou\?r</CODE> &#8991; <BR>
<BR>
Пример2; Пусть нам надо найти дату, содержащую четвертый день месяца. На английском, это будет выглядеть так: <CODE>4</CODE> или <CODE>4th</CODE> или <CODE>fourth</CODE> - &#8988; <I>fourth</I>&#8739; 4&#8739; 4<I>th</I> &#8991;. Вторую половину выражения можно сократить до &#8988; <CODE>4\(th\)\?</CODE> &#8991;. Получим &#8988; <CODE>fourth\|4\(th\)\?</CODE> &#8991;.<BR>
<BR>
Таким образом, квантификатор &#8988; <CODE>\?</CODE> &#8991; может присоединяться и к выражениям в скобках.<BR>
<BR>
<!--TOC subsection Повторение-->

<H3 CLASS="subsection"><A NAME="htoc56">5.5.2</A>&nbsp;&nbsp;Повторение</H3><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
Метасимвол &#8988; <CODE>\+</CODE> &#8991; <SUP><A NAME="text30" HREF="#note30">6</A></SUP>обозначает "один или несколько экземпляров непосредственно предшествуюших элементов".
<LI CLASS="li-itemize">Метасимвол &#8988; * &#8991; обозначает "любое количество экземпляров элемента (в том числе и нулевое)".
</UL>
Иначе говоря, &#8988; * &#8991; означает "найти столько экземпляров сколько возможно, но при необходимости обойтись и без них". Конструкция &#8988; <CODE>\+</CODE> &#8991; имеет похожий смысл, но при отсутствии хотя бы одного экземпляра сопоставление завершается неудачей.<BR>
<BR>
Примеры:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
&#8988; <CODE>^[0-9]\+</CODE> &#8991; - строка, начинающаяся с одной или более цифр 
<LI CLASS="li-enumerate">&#8988; <CODE>^[0-9]*</CODE>$ &#8991; - строка, содержащая в себе только цифры(может быть и пустой) 
<LI CLASS="li-enumerate">&#8988; .* &#8991; - любое количество любых символов
<LI CLASS="li-enumerate">&#8988; * &#8991; и &#8988; + &#8991; могут следовать за скобками: &#8988; <CODE>\(th\)i\+</CODE> &#8991; - одно и более сочетаний букв <CODE>th</CODE> подряд
<LI CLASS="li-enumerate">&#8988; <SUB>&#8852;</SUB><CODE>\+</CODE> &#8991; - один или более пробелов
</OL> 
<!--TOC subsection Интервал-->

<H3 CLASS="subsection"><A NAME="htoc57">5.5.3</A>&nbsp;&nbsp;Интервал</H3><!--SEC END -->

Конструкция вида &#8988; &hellip; <CODE>\{min,max\}</CODE> &#8991;<SUP><A NAME="text31" HREF="#note31">7</A></SUP> называется <EM>интервальным</EM> квантификатором.<BR>
<BR>
Например, выражение &#8988; &hellip; <CODE>\{3,12\}</CODE> &#8991; совпадает до 12 раз, если это возможно, но может ограничиться и всего 3 совпадениями. Запись <CODE>\{0,1\}</CODE> эквивалентна метасимволу <CODE>\?</CODE>, <CODE>\{1,\}</CODE> - <CODE>+</CODE>.<BR>
<BR>
<!--TOC section Круглые скобки и обратные сcылки-->

<H2 CLASS="section"><A NAME="htoc58">5.6</A>&nbsp;&nbsp;Круглые скобки и обратные сcылки</H2><!--SEC END -->

Мы уже знакомы с двумя применениями круглых скобок:
<UL CLASS="itemize"><LI CLASS="li-itemize">
ограничение области действия <CODE>|</CODE> (см. <A HREF="#reor">5.4.4</A>)
<LI CLASS="li-itemize">группировка символов для применения квантификаторов (см. <A HREF="#requant">5.5</A>)
</UL>
Существует еще одно применение круглых скобок. Круглые скобки могут "запоминать" текст, который совпал с подходящим в них подвыражением.<BR>
<BR>
<EM>Обратные ссылки</EM> позволяют искать новый текст, который совпадает с другим текстом в предшествующей части регулярного выражения, причем на момент написания выражения этот текст <EM>неизвестен</EM>.<BR>
<BR>
Круглые скобки "запоминают" текст, а специальный метасимвол &#8988; \ 1 &#8991; представляет этот текст (каким он бы не был) в оставшейся части регулярного выражения.<BR>
<BR>
В выражение можно включить несколько пар круглых скобок и ссылаться на совпавший текст с помощью &#8988; \ 1 &#8991; , &#8988; \ 2 &#8991;, &#8988; \ 3 &#8991; и т.д. Пары скобок нумеруются в соответствии с порядковым номером открывающей скобки справа налево.<BR>
<BR>
Пример. Пусть нам надо найти повторяющиеся слова. Если известно конкретное слово, то можно включить его в шаблон, например, &#8988; <I>the</I> <I>the</I> &#8991;. Но все пары слов проверить таким образом невозможно. Нам надо найти одно "обобщенное" слово, а потом указать искать то же самое. Заменим &#8988; <I>the</I> &#8991; регулярным выражением для обобщенного слова - &#8988; <CODE>[A-Za-z]\+</CODE> &#8991; и запомним его в круглых скобках - &#8988; <CODE>\([A-Za-z]\+\)</CODE> &#8991;. Добавим выражение для пробелов - &#8988; <SUB>&#8852;</SUB><CODE>\+</CODE> &#8991;. Теперь объединим полученные выражения и добавим обратную ссылку &#8988; <CODE>\([A-Za-z]\+\)</CODE> <SUB>&#8852;</SUB><CODE>\+\1</CODE> &#8991;. И последнее - обозначим границы слов<SUP><A NAME="text32" HREF="#note32">8</A></SUP> - &#8988; <CODE>\&lt;\([A-Za-z]\+\)</CODE> <SUB>&#8852;</SUB><CODE>\+\1\&gt;</CODE> &#8991;.<BR>
<BR>
<!--TOC section Экранирование-->

<H2 CLASS="section"><A NAME="htoc59">5.7</A>&nbsp;&nbsp;Экранирование</H2><!--SEC END -->

Чтобы включить в выражение символ, который совпадает с метасимволом, необходимо выполнить <EM>экранирование</EM>. Экранирование выполняется с помощью символа <CODE>\</CODE>.<BR>
<BR>
Например: метасимвол "точка" &#8988; . &#8991; совпадает с любым символом. Чтобы получить обычную точку, надо записать &#8988; <CODE>\.</CODE> &#8991;, которая называется "экранированной" (escaped) точкой.<BR>
<BR>
Экранирование может выполняться со всеми стандартными метасимволами, кроме метасимволов символьных классов.<BR>
<BR>
<!--TOC section sed-->

<H2 CLASS="section"><A NAME="htoc60">5.8</A>&nbsp;&nbsp;sed</H2><!--SEC END -->

<EM>sed (sequential или stream editor) неинтерактивный (поточный) редактор текста</EM>. Он служит для выполнение анализа и преобразования текста. Фактически sed - это продвинутый текстовый фильтр. Имеет свой входной язык, тесно связанный с регулярными выражениями.<BR>
<BR>
Очень удобен для использования в скриптах оболочек как средство обработки текстов.<BR>
<BR>
Далее будет описываться GNU sed.<BR>
<BR>
sed можно использовать двумя основными способами:
<PRE CLASS="verbatim">
sed [-n] [-e] 'команды редактирования' входной_файл
</PRE><DIV CLASS="center">и</DIV>
<PRE CLASS="verbatim">
sed [-n] -f сценарий входные_файлы
</PRE>
Чаще используется первый способ.<BR>
<BR>
Параметры:
<UL CLASS="itemize"><LI CLASS="li-itemize">
-f cmdfile прочитать сценарий из файла
<LI CLASS="li-itemize">-n блокирование вывода, кроме явно задаваемого из сценария 
</UL>
Если команд несколько, то они разделяются <CODE>;</CODE>.<BR>
<BR>
Входные файлы: редактируемый входной поток. Если не указывать имя файла, то sed будет работать со стандартным вводом. Результат выводится в стандартный вывод и обычно перенаправляется в файл или конвейер. Если входных файлов несколько, то они объединяются в один буфер, с которым и идет потом работа. <BR>
<BR>
Строки в буфере пронумерованы. Если sed применяется к нескольким файлам, то номера строк будут продолжаться. Если первый файл содержит 200 строк, то адресом первой строки следующего файла будет 201. <BR>
<BR>
<EM>Примечание</EM>. входные файлы <EM>не изменяются</EM>.<BR>
<BR>
<DIV CLASS="center">
Схема работы:
</DIV>
Входные файлы (stdin) считываются в область шаблонов (pettern buffer), после этого к буферу последовательно применяются команды, и затем результат выводится для сохранения или дальнейшей обработки.<BR>
<BR>
<EM>Внимание:</EM> крайне не рекомендуется перенапрвлять результат в исходные файлы. Это приводит к непредсказуемым результатам.<BR>
<BR>
<!--TOC subsection Общий вид команды-->

<H3 CLASS="subsection"><A NAME="htoc61">5.8.1</A>&nbsp;&nbsp;Общий вид команды</H3><!--SEC END -->
<BR>
<BR>
<CODE>[адрес1[, адрес2]] функция [аргументы]</CODE><BR>
<BR>
<EM>Функция</EM>: представляет собой букву команды. Единственный обязательный параметр. Например <CODE>'p'</CODE>.<BR>
<BR>
<EM>Адрес</EM>: может быть номер строки, регулярное выражение, $ (последняя строка).<BR>
<BR>
Если в адресе задается регулярное выражение, то оно задает все строки, соответствующие регулярному выражению. Регулярное выражение берется в <CODE>/</CODE> (прямой слэш), то есть <CODE>/regexp/</CODE>.<BR>
<BR>
Если не заданы адреса, то обрабатываются все строки буфера.<BR>
<BR>
<EM>Адресный интервал</EM> - это пара адресов, разделенная <CODE>","</CODE> и включающая все строки, начиная со строки, соответствующей первому адресу, до строки, соответствующей второму адресу включительно. Если второй адрес раньше первого, то обрабатывается только первая строка, соответствующая первому адресу.<BR>
<BR>
При добавлении символа <CODE>!</CODE> после адреса смысл меняется на противоположный: обрабатываются все строки, не лежащие в интервале.<BR>
<BR>
Примеры: <CODE>1,4; 1,$; 2,6!</CODE>.<BR>
<BR>
<!--TOC subsection Команды sed-->

<H3 CLASS="subsection"><A NAME="htoc62">5.8.2</A>&nbsp;&nbsp;Команды sed</H3><!--SEC END -->

Описаны только часто используемые команды.<BR>
<BR>
<!--TOC subsubsection Замена-->

<H4 CLASS="subsubsection">Замена</H4><!--SEC END -->
 <BR>
<BR>
<CODE>s/regexp/replacement/flags</CODE>. <BR>
<BR>
<CODE>s</CODE> - буква команды (замена, подстановка - substitute), <CODE>regexp</CODE> - строка поиска, то есть то, что заменится на <CODE>replacement</CODE>. <BR>
<BR>
Флаги:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>g</CODE> заменить все вхождения
<LI CLASS="li-itemize"><CODE>w</CODE> file записать изменения в файл
<LI CLASS="li-itemize"><CODE>p</CODE> после замены вывести строку на экран (обычно используется с ключом sed <CODE>-n</CODE>). 
</UL>
<PRE CLASS="verbatim">
Примеры: 
1. $ sed 's/sun/moon/g' myfile
2. $ sed '1,4 !s/sun/moon/g' myfile
3. $ echo Жужжали бабочки | sed -n 's/\(жж\)\(али\)/Гуж&lt;&amp;&gt;\2\1/p'
# Результат: ЖуГуж&lt;жжали&gt;алижж бабочки
4. $ sed '/^Example/,/ED$/s/first/second/g' 
# если несколько совпадающих строк, то редактируются все вхождения.
5. $ sed 's/Sunday/Monday/gw' changes
# все Sunday заменяются
</PRE>
<!--TOC subsubsection Удаление строк-->

<H4 CLASS="subsubsection">Удаление строк</H4><!--SEC END -->

<CODE>d</CODE>
<PRE CLASS="verbatim">
Примеры: 
1. $ sed '4,5 d' file
2. $ sed '/sun/ !d' file.txt 
# удаление всех строк, кроме содержащих sun.
3. $ sed '/sun/,/moon/ d' myfile
# удаляется диапазон от первой строки, содержащей sun
до первой строки, содержащей moon
</PRE>
<!--TOC subsubsection Вывод на экран-->

<H4 CLASS="subsubsection">Вывод на экран</H4><!--SEC END -->

<CODE>p</CODE> <BR>
<BR>
Обычно используется с <CODE>sed -n</CODE> (иначе строки будут выводиться два раза).
<PRE CLASS="verbatim">
Примеры: 
$ sed -n '/stroka/i !p'.
$ sed -n ' 1,4 p'
# вывести строки с 1 по 4 включительно
</PRE>
<!--TOC subsubsection Трансляция символов-->

<H4 CLASS="subsubsection">Трансляция символов</H4><!--SEC END -->
 <BR>
<BR>
<CODE>y/source_chars/dest_chars/</CODE> <BR>
<BR>
Замена символов по принципу "один к одному" (строки должны быть одной длины).
Пример:<CODE> $ sed 'y/abc/ABC/' file</CODE><BR>
<BR>
<!--TOC subsubsection Запись в файл-->

<H4 CLASS="subsubsection">Запись в файл</H4><!--SEC END -->
 <CODE>w file</CODE> - пишет буфер в файл.<BR>
<BR>
<!--TOC subsubsection Вставка файла-->

<H4 CLASS="subsubsection">Вставка файла</H4><!--SEC END -->
 <CODE>r file</CODE> - вставка в выходной поток файла. Если его нет, то вставляется файл нулевой длины (без ошибки).<BR>
<BR>
<!--TOC subsubsection Вставка строк-->

<H4 CLASS="subsubsection">Вставка строк</H4><!--SEC END -->
 
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>адрес a</CODE> помещает за обрабатываемой строкой
<LI CLASS="li-itemize"><CODE>адрес i</CODE> выводит до указанной строки
</UL>
<EM>Примечание</EM>: a и i разрешают использовать только один адрес.
<PRE CLASS="verbatim">
Пример:
$ cat script
  3 a\
 Здесь добавлена\
 строка
$ who | sed -f script
 root
 stud1
 stud10
        Здесь добавлена
        строка
 stud11
</PRE>
Символ экранирования <CODE>"\"</CODE> необходим, чтобы скрыть все символы конца строки кроме последнего.<BR>
<BR>

<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note25" HREF="#text25"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Утилиты семейства grep предназначены для поиска текста по шаблонам регулярных выражений
<DT CLASS="dt-list"><A NAME="note26" HREF="#text26"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">Для grep рекомендуется заключать regexp в кавычки, так как некоторые метасимволы имеют для оболочки специальные значения и выражение может работать некорректно
<DT CLASS="dt-list"><A NAME="note27" HREF="#text27"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Для Perl и egrep - &#8739; 
<DT CLASS="dt-list"><A NAME="note28" HREF="#text28"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">Для диалекта sed. Для egrep или perl это будет gr(a&#8739;e)y.
<DT CLASS="dt-list"><A NAME="note29" HREF="#text29"><FONT SIZE=5>5</FONT></A><DD CLASS="dd-list">Для Perl, egrep - ?.
<DT CLASS="dt-list"><A NAME="note30" HREF="#text30"><FONT SIZE=5>6</FONT></A><DD CLASS="dd-list">Для perl и egrep +
<DT CLASS="dt-list"><A NAME="note31" HREF="#text31"><FONT SIZE=5>7</FONT></A><DD CLASS="dd-list">В egrep и perl она выглядит как ...{min,max}
<DT CLASS="dt-list"><A NAME="note32" HREF="#text32"><FONT SIZE=5>8</FONT></A><DD CLASS="dd-list">Иначе будут найдены не только повторяющиеся слова, но и сочетания, когда буква, завершающая слово, является первой для следующего.
</DL>
<!--END NOTES-->
<!--TOC chapter Файловая система ОС UNIX-->

<H1 CLASS="chapter"><A NAME="htoc63">Chapter&nbsp;6</A>&nbsp;&nbsp;Файловая система ОС UNIX</H1><!--SEC END -->

С точки зрения пользователя в ОС UNIX существует два типа объектов: файлы и процессы.<BR>
<BR>
Все данные хранятся в виде файлов, доступ к периферийным устройствам осуществляется через чтение/запись в специальные файлы. <BR>
<BR>
При запуске программы ядро загружает соответствующий исполняемый файл, создает образ процесса и передает ему управление.<BR>
<BR>
Во время выполнения процесс может считывать или писать данные в файл. С другой стороны, вся функциональность ОС определяется выполнением соответствующих процессов. <BR>
<BR>
Таким образом, понятия файловой системы и процессов тесно взаимосвязаны.<BR>
<BR>
<!--TOC section Базовые сведения о файловой системе-->

<H2 CLASS="section"><A NAME="htoc64">6.1</A>&nbsp;&nbsp;Базовые сведения о файловой системе</H2><!--SEC END -->

В UNIX файлы организованы в виде <EM>древовидной структуры</EM> (дерева), называемой <EM>файловой системой</EM> (FS или file system).<BR>
<BR>
<EM>Каждый файл имеет имя</EM>, определяющее его расположение в дереве FS.<BR>
<BR>
Корнем дерева является <EM>корневой каталог</EM> (root directory), имеющий имя "/".<BR>
<BR>
Имена всех файлов, кроме "/", содержат <EM>путь - список каталогов, которые надо пройти, чтобы достичь файла</EM>.
Все доступное файловое пространство объединено в единое дерево каталогов, корнем которого является каталог "/". Таким образом, полное имя любого файла начинается с "/". Полное имя файла не содержит идентификатора устройства (HDD, CD-ROM или удаленного компьютера в сети), на котором он фактически находится. Символ "/" является разделителем в структуре каталогов.<BR>
<BR>
Каждый файл имеет связанные с ним <EM>метаданные</EM> (хранящиеся в индексных дескрипторах - <EM>inode</EM>), содержащие все характеристики файла и позволяющие ОС выполнять операции над ним.
 	
Метаданные хранят <EM>права доступа</EM>, <EM>владельца-пользователя</EM> и <EM>владельца-группу</EM>, указатели на дисковые блоки, хранящие данные. <EM>В метаданных нет</EM> сведений об <EM>имени файла</EM>.<BR>
<BR>
<!--TOC section Типы файлов-->

<H2 CLASS="section"><A NAME="htoc65">6.2</A>&nbsp;&nbsp;Типы файлов</H2><!--SEC END -->

В UNIX существует шесть типов файлов, различающихся по строение и поведению при выполнении операций над ними:<BR>
<BR>
<!--TOC subsection Обычный файл (regular file)-->

<H3 CLASS="subsection"><A NAME="htoc66">6.2.1</A>&nbsp;&nbsp;Обычный файл (regular file)</H3><!--SEC END -->

Это наиболее общий тип файлов, содержащий данные в некотором формате. Для ОС это просто последовательность байт. Интерпретация содержимого производится прикладной задачей. <BR>
Пример: текстовый файл, двоичные данные, исполняемый файл. Их можно просматривать командами <CODE>cat имя</CODE> и <CODE>less имя</CODE>.	<BR>
<BR>
<!--TOC subsection Каталог (directory)-->

<H3 CLASS="subsection"><A NAME="htoc67">6.2.2</A>&nbsp;&nbsp;Каталог (directory)</H3><!--SEC END -->

Это файл, содержащий имена находящихся в нем файлов, а также указатели на метаданные этих файлов, позволяющие ОС производить операции над ними.<BR>
<BR>
Каталоги определяют положение файла в дереве файловой системы, так как сам файл не содержит информации о своем местонахождении. Каталоги образуют дерево.<BR>
<BR>
Пример: 
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
<CODE>Номер inode</CODE> 
</TD>
<TD NOWRAP>&#9115;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9117;</TD>
<TD NOWRAP>
</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>	<CODE>10245 .</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	<CODE>12432 ..</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	<CODE> 8672 file1.txt</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	<CODE>12567 first</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	<CODE>19678 report</CODE></TD>
</TR></TABLE></TD>
<TD NOWRAP> 
</TD>
<TD NOWRAP>&#9118;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9120;</TD>
<TD NOWRAP>
<CODE>Имя файла</CODE> 
</TD>
</TR></TABLE></DIV><BR>
<BR>
Для работы с каталогами используются команды: <CODE>ls</CODE> с ключами <CODE>-a</CODE> и <CODE>-l</CODE>, <CODE>cd</CODE>, <CODE>mkdir</CODE>, <CODE>rm</CODE>, <CODE>rmdir</CODE>, <CODE>mv</CODE>.<BR>
<BR>
Первые два байта в каждой строке каталога являются единственной связью между именем файла и его содержимым. Именно поэтому <EM>имя файла в каталоге называют связью</EM>. Оно связывает имя в иерархии каталогов с индексным дескриптором и, тем самым, с информацией.<BR>
<BR>
<!--TOC subsection Специальный файл устройства (special device file)-->

<H3 CLASS="subsection"><A NAME="htoc68">6.2.3</A>&nbsp;&nbsp;Специальный файл устройства (special device file)</H3><!--SEC END -->

Обеспечивает доступ к физическому устройству. Различают символьные и блочные файлы устройств. Доступ к устройствам происходит путем открытия, чтения/записи в специальный файл устройства. <EM>Символьные файлы</EM> позволяют небуферизованный обмен данными (посимвольно), а <EM>блочные</EM> - обмен пакетами определенной длины - блоками. К некоторым устройствам доступ возможен как через символьные, так и через блочные файлы.<BR>
<BR>
Для создания файлов устройств используется команда <CODE>mknod</CODE>.<BR>
<BR>
<!--TOC subsection FIFO или именованный канал (named pipe)-->

<H3 CLASS="subsection"><A NAME="htoc69">6.2.4</A>&nbsp;&nbsp;FIFO или именованный канал (named pipe)</H3><!--SEC END -->

Используется для связи между процессами. Подробно будет рассмотрен при описании системы межпроцессного взаимодействия (см. <A HREF="#fifo">??</A>). <BR>
<BR>
<!--TOC section Связь (ссылка)-->

<H2 CLASS="section"><A NAME="htoc70">6.3</A>&nbsp;&nbsp;Связь (ссылка)</H2><!--SEC END -->

<!--TOC subsection Жесткая ссылка-->

<H3 CLASS="subsection"><A NAME="htoc71">6.3.1</A>&nbsp;&nbsp;Жесткая ссылка</H3><!--SEC END -->

Связь имени файла с его данными называется <EM>жесткой ссылкой</EM> (hard link). 
Имена жестко связаны с метаданными и, соответственно, с данными файла, в то время, как файл существует независимо от того, как его называют в файловой системе. Такая система позволяет одному файлу иметь несколько имен в файловой системе.
<PRE CLASS="verbatim">
Пример: 
$ pwd
/home/stud1
$ln first /home/stud2 second 
# создание жесткой ссылки.
</PRE>Все жесткие ссылки на файл абсолютно равноправны. <BR>
<BR>
Файлы <CODE>first</CODE> и <CODE>second</CODE> будут отличатся только именем в файловой системе. Изменения, внесенные в любой из этих файлов, затронут и другой, так как они ссылаются на одни и те же данные. Даже при переносе файлов в другой каталог все равно они будут жестко связаны.<BR>
<BR>
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
</TD>
<TD NOWRAP>&#9115;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9116;<BR>
&#9117;</TD>
<TD NOWRAP>
</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>	 <CODE>/home/stud1</CODE> 	</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>/home/stud2</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	<CODE>10245 .</CODE>		</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>12563 .</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	 <CODE>12432 ..</CODE> 	</TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>12432 ..</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	 <CODE>8672  file1.txt</CODE></TD>
<TD ALIGN=center NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><CODE>12672 a.out</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	 <CODE>12567 first</CODE> 	</TD>
<TD ALIGN=center NOWRAP>&mdash;&rarr; <CODE>12567(inode)</CODE> &larr;&mdash;</TD>
<TD ALIGN=left NOWRAP><CODE>12567 second</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>	 <CODE>19678 second</CODE> 	</TD>
<TD ALIGN=center NOWRAP>&#8595;</TD>
<TD ALIGN=left NOWRAP><CODE>9675  dir1</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>				</TD>
<TD ALIGN=center NOWRAP><CODE>Данные файла</CODE></TD>
</TR></TABLE></TD>
<TD NOWRAP>
</TD>
<TD NOWRAP>&#9118;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9119;<BR>
&#9120;</TD>
</TR></TABLE></DIV><BR>
<BR>
Файл существует в системе до тех пор, пока существует хотя бы одна жесткая связь, указывающая на него, то есть пока у него есть хотя бы одно имя. Например, простое удаления файла <CODE>second</CODE> не удаляет данные. Их можно достать через <CODE>first</CODE>. <BR>
<BR>
В выводе команды <CODE>ls -l</CODE> вторая колонка показывает количество жестких связей файла.<BR>
<BR>
Таким образом, жесткая связь не принадлежит к особому типу файлов, а является естественной формой связи имени файла с его метаданными.<BR>
<BR>
Жесткие ссылки можно создать командой <CODE>ln</CODE> (link).<BR>
<BR>
<!--TOC subsection Символическая ссылка-->

<H3 CLASS="subsection"><A NAME="htoc72">6.3.2</A>&nbsp;&nbsp;Символическая ссылка</H3><!--SEC END -->

Особый тип связи - символическая связь, позволяющая косвенно адресовать файл, в отличие от жесткой, обращающейся напрямую.
Символическая ссылка содержит в себе имя файла, на который ссылается, а не его данные.<BR>
<BR>
Физическое расположение файлов различно. Размер <CODE>symfirst</CODE> - длина имени файла, на который ссылается символическая связь.
ОС работает с <CODE>symfirst</CODE> не так, как с обычным файлом: при обращении к нему появятся данные <CODE>first</CODE>.<BR>
<BR>
<!--TOC subsection Сокет (socket)-->

<H3 CLASS="subsection"><A NAME="htoc73">6.3.3</A>&nbsp;&nbsp;Сокет (socket)</H3><!--SEC END -->

Используются для межпроцессного взаимодействия. Будут подробнее рассмотрены в соответствующей теме (см. <A HREF="#socket">??</A>.<BR>
<BR>
<!--TOC section Структура файловой системы-->

<H2 CLASS="section"><A NAME="htoc74">6.4</A>&nbsp;&nbsp;Структура файловой системы</H2><!--SEC END -->

Все Unix-системы имеют сходную систему расположения и именования файлов и каталогов. Использование общепринятых имен файлов и структуры каталогов в UNIX-подобных ОС облегчает работу и перенос. Нарушение структуры ведет к нарушениям в работе.<BR>
<BR>
Корневой каталог <CODE>"/"</CODE> является основой FS. Все остальные файлы и каталоги располагаются в рамках структуры, порождаемой корневым каталогом.<BR>
<BR>
<EM>Абсолютное или полное имя</EM> файла определяет точное местонахождение файла в структуре файловой системы. Начинается с <CODE>"/"</CODE> (в корневом каталоге) и содержит полный путь подкаталогов, которые нужно пройти, чтобы достичь файла.<BR>
<BR>
<EM>Относительное имя</EM> определяет местонахождение файла через текущий каталог. Никогда не начинается с <CODE>"/"</CODE>.<BR>
<BR>
<EM>Каталог-предок</EM> - это тот, который содержит другой каталог. Две точки (<CODE>..</CODE>) как имя каталога всегда относятся к каталогу, содержащему текущий каталог. Корневой каталог не имеет предка. Каталог, находящийся в другом каталоге, называется <EM>каталогом-потомком или подкаталогом</EM>. К текущему каталогу можно обратиться по имени <CODE>"."</CODE>. Например, <CODE>./file1</CODE>.<BR>
<BR>
<EM>Домашним или начальным каталогом</EM> называется область, котрая выделяется каждому пользователю и в которой он может хранить свои файлы и программы.
К своему домашнему каталогу пользователь может обратиться по имени <CODE>~</CODE> (тильда). Например, <CODE>~/file.txt</CODE>.<BR>
<BR>
<!--TOC subsection Основные каталоги-->

<H3 CLASS="subsection"><A NAME="htoc75">6.4.1</A>&nbsp;&nbsp;Основные каталоги</H3><!--SEC END -->

<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>/bin</CODE> - наиболее часто употребляемые файлы и утилиты.
<LI CLASS="li-enumerate"><CODE>/dev</CODE> - содержит специальные файлы устройств, являющиеся интерфейсом доступа к периферийным устройствам. Может содержать подкаталоги, группирующие устройства по типам. Например, <CODE>/dev/dsk</CODE> - доступ к дискам.
<LI CLASS="li-enumerate"><CODE>/etc</CODE> - системные конфигурационные файлы и утилиты. Иногда утилиты отсюда выносятся в <CODE>/sbin</CODE> и <CODE>/usr/sbin</CODE>.
<LI CLASS="li-enumerate"><CODE>/lib</CODE> - библиотеки Си и других языков программирования. Часть библиотек - в <CODE>/usr/lib</CODE>. 
<LI CLASS="li-enumerate"><CODE>/lost</CODE>found+ - "каталог потерянных файлов", то есть потерявших свое имя при сбое, но существующих на диске.
<LI CLASS="li-enumerate"><CODE>/mnt</CODE> - для временного связывания (монтирования) физических файловых систем к корневой для получения единой структуры.
<LI CLASS="li-enumerate"><CODE>/home</CODE> - каталоги пользователей.
<LI CLASS="li-enumerate"><CODE>/usr</CODE> 
<UL CLASS="itemize"><LI CLASS="li-itemize"> 
 <CODE>/usr/bin</CODE> - утилиты;
 <LI CLASS="li-itemize"><CODE>/usr/include</CODE> - заголовочные файлы Си;
 <LI CLASS="li-itemize"><CODE>/usr/man</CODE> - справочная система;
 <LI CLASS="li-itemize"><CODE>/usr/local</CODE> - дополнительные программы;
 <LI CLASS="li-itemize"><CODE>/usr/share</CODE> - файлы, разделяемые между различными программами.	
</UL>
<LI CLASS="li-enumerate"><CODE>/var</CODE> - временные файлы сервисных подсистем (печати, почты, новостей).
<LI CLASS="li-enumerate"><CODE>/tmp</CODE> - каталог временных файлов. Обычно открыт на запись для всех пользователей системы.
</OL>
<!--TOC section Атрибуты файлов-->

<H2 CLASS="section"><A NAME="htoc76">6.5</A>&nbsp;&nbsp;Атрибуты файлов</H2><!--SEC END -->

<!--TOC subsection Владельцы файлов-->

<H3 CLASS="subsection"><A NAME="htoc77">6.5.1</A>&nbsp;&nbsp;Владельцы файлов</H3><!--SEC END -->

Группой называется определенный список пользователей системы.
Пользователь может быть членом нескольких групп, одна из которых является первичной, а остальные - дополнительными.<BR>
<BR>
<CODE>/etc/passwd</CODE> - список всех пользователей и их первичных групп;
<CODE>/etc/group</CODE> - список всех групп и их дополнительных пользователей.
В UNIX любой файл имеет двух владельцев:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
владельца-пользователя
<LI CLASS="li-enumerate">владельца-группу.
</OL>
При этом владелец-пользователь не обязательно принадлежит владельцу-группе. <BR>
<BR>
Команда <CODE>ls -l</CODE> выводит информацию о владельцах в третью и четвертую колонки. Для изменения владельцев используются команды:<BR>
<CODE>chown новый_влад. имя_файла</CODE>. Например: <CODE>chown sys something.doc</CODE>.<BR>
<CODE>chgrp  новый_влад. имя_файла</CODE>. Например: <CODE>chgrp adm something.doc</CODE>.<BR>
<BR>
Сменить владельца-пользователя может либо текущий владелец, либо администратор (root). Сменить владельца-группу может либо владелец-пользователь для группу, к которой он сам принадлежит (POSIX), либо администратор.<BR>
<BR>
<!--TOC subsection Права доступа к файлам-->

<H3 CLASS="subsection"><A NAME="htoc78">6.5.2</A>&nbsp;&nbsp;Права доступа к файлам</H3><!--SEC END -->

У каждого файла существуют атрибуты, называемые правами доступа.
В UNIX существует три базовых типа доступа:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	<CODE>u</CODE> (user) для владельца-пользователя
<LI CLASS="li-enumerate">	<CODE>g</CODE> (group) для владельца-группы 
<LI CLASS="li-enumerate">	<CODE>o</CODE> (other) для всех остальных 
<LI CLASS="li-enumerate">	<CODE>а</CODE> (all - объединяет 3 предыдущих класса). Для всех классов пользователей
</OL>
В каждом из этих классов установлены три основных права доступа:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
 <CODE>r</CODE> (read) право на чтение 
 <LI CLASS="li-enumerate"><CODE>w</CODE> (write) право на запись 
 <LI CLASS="li-enumerate"><CODE>x</CODE> (execute) право на выполнение 
</OL>
В первой колонке вывода команды <CODE>ls -l</CODE> можно просмотреть установленные права.
<PRE CLASS="verbatim">
Пример: 
$ ls -l 
 - r w - r - - r w x     1   stud1    students  ...  example.program
 0 1 2 3 4 5 6 7 8 9
0 - тип  файла: - обычный; d каталог; l символическая ссылка; 
    c,b символьный/блочный файл устройств.
1-3 - права доступа для владельца-пользователя.
4-6 - права доступа для владельца-группы.
7-9 - права доступа для остальных.
</PRE>
Права может изменять владелец-пользователь и(или) администратор.
Для изменения прав доступа используется команда <CODE>chmod</CODE>:
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
<CODE>chmod</CODE> &nbsp;&nbsp;
</TD>
<TD NOWRAP>&#9121;<BR>
&#9122;<BR>
&#9122;<BR>
&#9122;<BR>
&#9123;</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP><I>u</I></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>g</I></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>o</I></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>a</I></TD>
</TR></TABLE></TD>
<TD NOWRAP> </TD>
<TD NOWRAP>&#9124;<BR>
&#9125;<BR>
&#9125;<BR>
&#9125;<BR>
&#9126;</TD>
<TD NOWRAP>
</TD>
<TD NOWRAP>&#9121;<BR>
&#9122;<BR>
&#9122;<BR>
&#9123;</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP>+</TD>
</TR>
<TR><TD ALIGN=center NOWRAP>&minus;</TD>
</TR>
<TR><TD ALIGN=center NOWRAP>=</TD>
</TR></TABLE></TD>
<TD NOWRAP> </TD>
<TD NOWRAP>&#9124;<BR>
&#9125;<BR>
&#9125;<BR>
&#9126;</TD>
<TD NOWRAP>
</TD>
<TD NOWRAP>&#9121;<BR>
&#9122;<BR>
&#9122;<BR>
&#9123;</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP><I>r</I></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>w</I></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><I>x</I></TD>
</TR></TABLE></TD>
<TD NOWRAP> </TD>
<TD NOWRAP>&#9124;<BR>
&#9125;<BR>
&#9125;<BR>
&#9126;</TD>
<TD NOWRAP>
&nbsp;&nbsp; <CODE>файлы</CODE> &nbsp;&nbsp;&nbsp;&nbsp;
</TD>
<TD NOWRAP><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>+ <CODE>добавить права к текущим</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&minus; <CODE>отнять права от текущих</CODE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>= <CODE>обнулить права и присвоить новые</CODE></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
<PRE CLASS="verbatim">
Пример:
$ chmod a+w text  
# добавить разрешение писать всем пользователям;
$ chmod go=r text 
# установить только одно право на чтение для всех кроме владельца-пользователя;
$ chmod g+x-r program 
# добавить для группы право на выполнение и отнять у нее право читать;
$ chmod u+w, og+r-w text2;
</PRE>
Возможно также задание прав через числовой формат в восьмеричной системе счисления.
<BR>
<BR>
<CODE>Пример: chmod 666 *</CODE>.<BR>
<BR>
<!--TOC subsection Значение прав доступа-->

<H3 CLASS="subsection"><A NAME="htoc79">6.5.3</A>&nbsp;&nbsp;Значение прав доступа</H3><!--SEC END -->

Для обычных фалов - очевидно: право на чтение надо, чтобы прочитать файл, право на запись, чтобы иметь возможность файл изменить, а право на выполнение, чтобы запустить программу или скрипт.<BR>
<BR>
<EM>Примечание</EM>. Для успешного запуска скрипта необходимо установить атрибут r, чтобы командный интерпретатор мог построчно считывать текст скрипта.<BR>
<BR>
Для каталогов и символических связей интерпретация прав доступа проводится по-другому.<BR>
<BR>
Права символических ссылок совпадают с файлом, на который она указывает. На самой ссылке стоит <CODE>777</CODE> (всем все) и это не имеет значения. <BR>
<BR>
Для каталогов <CODE>r</CODE> позволяет получить имена (и только имена) файлов, находящихся в данном каталоге. <CODE>X</CODE> позволяет "выполнить" каталог, то есть заглянуть в метаданные и получить полную информацию о каталоге.
<PRE CLASS="verbatim">
Пример:  
$ chmod u+r-x dir1
$ ls dir1      - выполнится
$ ls -l dir1  - Permission denied
$  cd dir1     - Permission denied (надо х).
</PRE><BR>
<BR>
<CODE>r</CODE> и <CODE>x</CODE> для каталога действуют независимо (одно не требует другого).
<PRE CLASS="verbatim">
Пример:  
$ mkdir dark_dir
$ chmod a-r+w dark_dir
$ ls dark_dir  -выполниться
$ ls -l        -нет  
$ cat file1       
# yes (заранее зная имя файла, можно обратиться к нему).
</PRE>
Атрибут w должен быть установлен для того, чтобы можно было изменять каталог: создавать и удалять файлы.
Для удаления файла из каталога достаточно иметь установленный атрибут w для каталога, в котором он находился, а права файла при этом не учитываются.<BR>
<BR>
<!--TOC subsection Последовательность проверки прав-->

<H3 CLASS="subsection"><A NAME="htoc80">6.5.4</A>&nbsp;&nbsp;Последовательность проверки прав</H3><!--SEC END -->

<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	если вы администратор (root), доступ разрешен. Права не проверяются.
	<LI CLASS="li-enumerate">если операция запрашивается владельцем, идет проверка его прав. В соответствии с ними ему разрешается выполнение операции или нет.
	<LI CLASS="li-enumerate">если операция запрашивается пользователем, входящим в группу, владеющую файлом, идет проверка его прав. Соответственно, он либо получает разрешение, либо нет.
	<LI CLASS="li-enumerate">аналогично для всех остальных пользователей.
</OL>
<PRE CLASS="verbatim">
Пример: 
----rwr--  2  stud1   students ... file1  
stud1 в доступе будет отказано, но он, как владелец, 
может в любой момент сменить права доступа. 
</PRE>
<!--TOC subsection Дополнительные атрибуты файла-->

<H3 CLASS="subsection"><A NAME="htoc81">6.5.5</A>&nbsp;&nbsp;Дополнительные атрибуты файла</H3><!--SEC END -->

Для обычных файлов:
<UL CLASS="itemize"><LI CLASS="li-itemize">
	<CODE>t</CODE> - <EM>"sticky bit"</EM> (бит липучка)- сохранить образ выполняемого файла в памяти после выполнения (устаревший аттрибут)
	<LI CLASS="li-itemize"><CODE>s</CODE> - set UID, <EM>SUID</EM> - установить права у процесса, как у запущенного файла, а не как у пользователя, запустившего программу (по умолчанию)
	<LI CLASS="li-itemize"><CODE>s</CODE> - set GID, <EM>SGID</EM> - то же для группы
	<LI CLASS="li-itemize"><CODE>1</CODE> - блокирование - в каждый момент времени с файлом может работать только одна задача
</UL>
Для каталогов:
<UL CLASS="itemize"><LI CLASS="li-itemize">
	<CODE>t</CODE> - пользователь может удалять только те файлы и каталоги, которыми владеет или имеет право на запись;
	<LI CLASS="li-itemize"><CODE>s</CODE> для создаваемых файлов группа-владелец наследуется от каталога-предка (а не от первичной группы пользователя, создающего файл).
</UL>
Дополнительные атрибуты также устанавливаются с помощью <CODE>chmod</CODE>.<BR>
<BR>
 
<!--TOC chapter Процессы-->

<H1 CLASS="chapter"><A NAME="htoc82">Chapter&nbsp;7</A>&nbsp;&nbsp;Процессы</H1><!--SEC END -->

<EM>Процесс</EM> - это экземпляр выполняющейся программы.<BR>
<BR>
Программа - совокупность файлов, будь то исходники, объектные файлы либо выполняемый файл.<BR>
<BR>
Для запуска программы на выполнение ОС должна создать <EM>окружение</EM> или среду выполнения задачи, куда относится ресурсы памяти, возможность доступа к устройствам ввода/вывода и различным системным ресурсам.<BR>
<BR>
Процесс состоит из инструкций, выполняемых процессором, данных и информации о выполняемой задаче, такой, как размещенная память, открытые файлы и статус процесса.<BR>
<BR>
Программа может породить более одного процесса. Пользователи могут запускать несколько экземпляров одной программы. Например, количество BASH - эквивалентно числу пользователей. Таким образом UNIX - многозадачная ОС.<BR>
<BR>
Выполнение процесса заключается в точном следовании набору инструкций, который никогда не передает управление набору инструкций другого процесса. Процесс взаимодействует со своими данными и стеком, но ему не доступны чужие данные и стек. <BR>
<BR>
Процессы изолированы друг от друга. В то же время, процессы имеют возможность обмениваться друг с другом данными с помощью системы межпроцессного взаимодействия <EM>(IPC)</EM>.<BR>
<BR>
Виды IPC:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
сигналы
<LI CLASS="li-enumerate">каналы
<LI CLASS="li-enumerate">разделяемая память
<LI CLASS="li-enumerate">семафоры
<LI CLASS="li-enumerate">сообщения
<LI CLASS="li-enumerate">файлы.
</OL>
<!--TOC section Типы процессов-->

<H2 CLASS="section"><A NAME="htoc83">7.1</A>&nbsp;&nbsp;Типы процессов</H2><!--SEC END -->

<!--TOC subsection Системные процессы-->

<H3 CLASS="subsection"><A NAME="htoc84">7.1.1</A>&nbsp;&nbsp;Системные процессы</H3><!--SEC END -->

<EM>Системные процессы</EM> являются частью ядра и всегда расположены в оперативной памяти. Системные процессы не имеют соответствующих им программ в виде исполняемых файлов и запускаются особым образом при инициализации ядра системы.
<PRE CLASS="verbatim">
Примеры:
1)диспетчер свопинга
2)диспетчер памяти
и другие.
</PRE>
Выполняемые инструкции и данные системных процессов находятся в ядре, таким образом, они могут обращаться к функциям и данным, не доступным извне (ядра). <BR>
<BR>
Процесс <CODE>init</CODE> можно также отнести к системным, хотя он запускается из файла. Он прародитель всех процессов системы. <CODE>init</CODE> запускается первым после загрузки ядра и запускает все остальные инициализационные задачи на выполнение.<BR>
<BR>
<!--TOC subsection Демоны-->

<H3 CLASS="subsection"><A NAME="htoc85">7.1.2</A>&nbsp;&nbsp;Демоны</H3><!--SEC END -->

<EM>Демоны</EM> - неинтерактивные процессы, запускаемые обычным образом, и выполняются в фоновом режиме. Они не связаны не с одним пользовательским сеансом и не могут непосредственно управляться пользователем. Обеспечивают работу различных подсистем: <UL CLASS="itemize"><LI CLASS="li-itemize">
печати
<LI CLASS="li-itemize">сетевого доступа
<LI CLASS="li-itemize">терминального доступа
<LI CLASS="li-itemize">почта
<LI CLASS="li-itemize">web-сервера
<LI CLASS="li-itemize">СУБД.
</UL>
<!--TOC subsection Прикладные процессы-->

<H3 CLASS="subsection"><A NAME="htoc86">7.1.3</A>&nbsp;&nbsp;Прикладные процессы</H3><!--SEC END -->

<EM>Прикладные процессы</EM> - все остальные процессы. Как правило, порождаются в рамках пользовательского сеанса. <BR>
<BR>
<CODE>Пример: ls, BASH.</CODE><BR>
<BR>
Пользовательские процессы могут выполняться как в интерактивном, так и в фоновом режиме, но время из жизни (выполнения) ограничено сеансом работы пользователя. При выходе из системы все пользовательские процессы будут уничтожены.<BR>
<BR>
<EM>Примечание</EM>: интерактивные процессы монопольно владеют терминалом, и, пока такой процесс не завершит выполнение, пользователь не может работать с другими приложениями. (Кроме случаев, когда есть режим запуска других процессов из этого интерактивного процесса.)<BR>
<BR>
<!--TOC section Атрибуты процессов-->

<H2 CLASS="section"><A NAME="htoc87">7.2</A>&nbsp;&nbsp;Атрибуты процессов</H2><!--SEC END -->

Атрибуты позволяют ОС эффективно управлять работой процесса.<BR>
<BR>
Просмотр атрибутов процесса: <CODE>ps -ef</CODE>.<BR>
<BR>
<!--TOC subsection Идентификатор процесса-->

<H3 CLASS="subsection"><A NAME="htoc88">7.2.1</A>&nbsp;&nbsp;Идентификатор процесса</H3><!--SEC END -->

<A NAME="pid"></A>
Идентификатор процесса - <EM>Process ID (PID)</EM> - каждый процесс имеет уникальный идентификатор, позволяющий ядру системы различать процессы.
При создании нового процесса, ядро присваивает ему следующий свободный идентификатор. Присвоение PID - по возрастающей, то есть PID нового процесса больше, чем PID процесса, созданного перед ним. <BR>
<BR>
Если PID достиг максимального значения, следующий процесс получит минимальный свободный и цикл повторяется.<BR>
<BR>
Когда процесс завершает работу - ядро освобождает занятый им PID.<BR>
<BR>
<!--TOC subsection Родительский процесс-->

<H3 CLASS="subsection"><A NAME="htoc89">7.2.2</A>&nbsp;&nbsp;Родительский процесс</H3><!--SEC END -->

<A NAME="ppid"></A>
Идентификатор родительского процеcса -Parent Process ID (PPID) - PID процесса, породившего данный.<BR>
<BR>
<!--TOC subsection Приоритет процесса-->

<H3 CLASS="subsection"><A NAME="htoc90">7.2.3</A>&nbsp;&nbsp;Приоритет процесса</H3><!--SEC END -->

Приоритет процесса (nice number) - относительный приоритет процесса, учитываемый планировщиком при определении очередности запуска. Чем меньше число, тем больше приоритет (nice - приятный, то есть чем более "приятный" процесс, тем меньше он загружает CPU).<BR>
<BR>
Фактическое распределение ресурсов - приоритет выполнения: динамически изменяется ядром во время выполнения. Относительный - постоянен, но может изменяться администратором или пользователем с помощью nice.<BR>
<BR>
<!--TOC subsection Терминальная линия-->

<H3 CLASS="subsection"><A NAME="htoc91">7.2.4</A>&nbsp;&nbsp;Терминальная линия</H3><!--SEC END -->

Терминальная линия (TTY) - терминал или псевдотерминал, ассоциированный с процессом. <BR>
<BR>
<EM>Примечание</EM>. Демоны не имеют ассоциированного терминала. <BR>
<BR>
<!--TOC subsection Идентификаторы пользователей-->

<H3 CLASS="subsection"><A NAME="htoc92">7.2.5</A>&nbsp;&nbsp;Идентификаторы пользователей</H3><!--SEC END -->

<A NAME="euid"></A> <A NAME="rid"></A>
Реальный (RID) и эффективный (EUID) идентификаторы пользователя. RID - идентификатор пользователя, запустившего этот процесс. EUID служит для определения прав доступа процессак системным ресурсам (в первую очередь к файловой системе.)
Обычно RID=EUID, то есть процесс имеет те же права, что и пользователь, запустивший его. RID!=EUID, когда на программе установлен бит SUID. Тогда EUID=UID, то есть процесс получает те же права, что и у владельца исполняемого файла (например, администратор).<BR>
<BR>
<!--TOC subsection Идентификаторы групп-->

<H3 CLASS="subsection"><A NAME="htoc93">7.2.6</A>&nbsp;&nbsp;Идентификаторы групп</H3><!--SEC END -->

Реальный (RGID) и эффективный (EGID) идентификаторы группы. RGID=GID первичной группы пользователя, запустившего процесс. EGID служит для определения прав доступа пользователя по классу доступа группы. По умолчанию RGID=EGID, кроме SGID, установленного на команду, тогда EGID=GID группы-владельца команды.<BR>
<BR>
<!--TOC section Жизненный путь процессов-->

<H2 CLASS="section"><A NAME="htoc94">7.3</A>&nbsp;&nbsp;Жизненный путь процессов</H2><!--SEC END -->

Процесс в UNIX создается системным вызовом <CODE>fork(2)</CODE>. <BR>
<BR>
Процесс, сделавший вызов fork(2), называется <EM>родительским</EM>, а вновь созданный - <EM>дочерним</EM>. Новый процесс является точной копией породившего его процесса. <BR>
<BR>
<EM>Примечание</EM>. новый процесс имеет те же инструкции и данные, что и родитель. Более того, выполнение родительского и дочернего начнется с одной и той же инструкцией, следующей за системным вызовом fork. Единственное их отличие - идентификатор PID.<BR>
<BR>
Каждый процесс имеет одного родителя, но может иметь несколько потомков.<BR>
<BR>
Для запуска задачи, то есть загрузки новой программы, процесс должен сделать вызов <CODE>exec(3)</CODE>. При этом новый процесс не порождается, а исполняемый код нового процесса полностью замещается кодом запускаемой программы. Тем не менее сохраняются значения переменных окружения, назначение стандартных потоков ввода/вывода и ошибок, а также приоритет процесса.<BR>
<BR>
В UNIX запуск на выполнение новой программы часто связан с порождением нового процесса. Таким образом, процесс сначала выполняет fork, порождая дочерний процесс, который затем выполняет exec, полностью замещая родительский процесс. Такая процедура запуска называется fork-and-exec. <BR>
<BR>
Бывают ситуации, когда достаточно одного вызова fork без последующего exec. В этом случае исполняемый код родительского и дочернего процессов должен содержать логическое ветвление для родительского и дочернего процессов. (fork возвращает PID порожденного процесса в родительский и ноль - в дочерний.)<BR>
<BR>
Все процессы создаются через вызов fork. Запуск осуществляется либо по fork-and-exec, либо с помощью exec.
Прародителем всех процессов является init или распределитель процессов.<BR>
<BR>
<!--TOC section Сигналы-->

<H2 CLASS="section"><A NAME="htoc95">7.4</A>&nbsp;&nbsp;Сигналы</H2><!--SEC END -->

Сигналы являются способом передачи уведомления о возникновении какого-либо события. Сигнал может идти от одного процесса другому или от ядра ОС какому-либо процессу.<BR>
<BR>
Сигналы - простейшая форма IPC. <BR>
<BR>
Например, при делении на ноль процессу посылается сигнал SIGFPE, а при нажатии Ctrl+C на терминале текущему процессу посылается сигнал SIGINT.<BR>
<BR>
Для отправки сигналов используется команда <CODE>kill</CODE>: <BR>
<CODE>$ kill sig_no pid</CODE>, где <BR>
sig_no - номер или символьное название сигнала;<BR>
pid - идентификатор процесса, которому посылается сигнал.<BR>
<BR>
Пользователь может посылать сигналы только тем процессам, владельцем которых он является, то есть RID и EUID совпадают с UID пользователя. Администратор (root) может посылать сигналы всем процессам.
<PRE CLASS="verbatim">
Пример: посылка сигнала процессу, только что запущенному в фоновом режиме
$ back_fone_prog &amp;
$ kill $! (по умолчанию посылается SIGTERM, номер 15).
</PRE>
При получении сигнала процесс может реагировать следующим образом:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
игнорировать сигнал.<BR>
	<EM>Замечание:</EM> не следует игнорировать аппаратно вызванные сигналы, например, SIGFPE.
<LI CLASS="li-enumerate">действие по умолчанию. Обычно это завершение работы.
<LI CLASS="li-enumerate">перехватить сигнал и самостоятельно обработать его. Например, перехват SIGINT позволит удалить все tmp-файлы и корректно завершить выполнение.
</OL>
<EM>Исключение:</EM> SIGKILL и SIGSTOP нельзя ни перехватить, ни игнорировать.<BR>
<BR>
Возможны ситуации, когда процесс не реагирует на SIGKILL:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
процессы-зомби. Фактически он завершился, но осталась запись в системной таблице процессов.
<LI CLASS="li-enumerate">процессы, ожидающие недоступные ресурсы NFS. Например, процессы пишущие данные в файл удаленного компьютера, который уже отключился. Проблему решают посылкой SIGINT или SIGQUIT. 
<LI CLASS="li-enumerate">процесс, ожидающий завершения операции с устройством, например, перемотка ленты или перепозиционирование головки CD-ROM на порченном диске.
</OL>
Сигналы используются не только для завершения работы процессов, но и могут иметь специфическое значение для приложения. (Это не относится к SIGKILL и SIGSTOP, потому что их нельзя перехватить.)
К примеру, системные демоны - proxy servers, smtp (pop, imap), СУБД, bind при получении сигнала SIGHUP должны перечитать свои конфигурационные файлы и рестартовать. 

<!--TOC chapter Среда программирования Unix-->

<H1 CLASS="chapter"><A NAME="htoc96">Chapter&nbsp;8</A>&nbsp;&nbsp;Среда программирования Unix</H1><!--SEC END -->

<!--TOC section Unix-way программирования-->

<H2 CLASS="section"><A NAME="htoc97">8.1</A>&nbsp;&nbsp;Unix-way программирования</H2><!--SEC END -->

<!--TOC section Unix как единая среда разработки (IDE)-->

<H2 CLASS="section"><A NAME="htoc98">8.2</A>&nbsp;&nbsp;Unix как единая среда разработки (IDE)</H2><!--SEC END -->

Из высказывания в ru.unix.prog Алексея Махоткина из ru.unix.prog FAQ :
<BLOCKQUOTE CLASS="quote">
 &gt;&gt; Q: Какие есть IDE (integrated development environments) под Unix? Hу<BR>
&gt;&gt; чтобы компилятор, среда редактирования, отладчик и прочее - были все<BR>
&gt;&gt; вместе?<BR>
...<BR>
<BR>
UNIX сам по себе является Integrated Development Environment.<BR>
<BR>
В "обычных" IDE есть бинарник-интегратор, который вызывает в лучшем случае
внешние утилиты, а в худшем случае &ndash; свою реализацию каждой функцию из DLL
или прямо зашитую в бинарник.<BR>
<BR>
В UNIX таким бинарником-интегратором является shell (Emacs считается
shell'ом в данном случае). Для выполнения каждой функции вызываются
специально написанные динамически выполняемые модули, такие как make, cc,
ld, и т. д.<BR>
<BR>
Преимущество в этом такое же, как преимущество математических функций
высшего порядка перед "обычными" функциями.<BR>
<BR>
Hапример, функция "отслеживать зависимости" чаще всего реализуется с
помощью make, но можно также легко использовать, скажем, cook, или же
переключаться между GNU Make и BSD Make по вкусу. Точно такая ситуация с
используемыми редактором, компилятором, etc. Более того, сам по себе shell
является "функцией высшего порядка", и легко может быть заменен.<BR>
<BR>
Кроме того, так как пространство функций практически неограниченно, то IDE
"Unix" обеспечивает также заранее не предусмотренные функции высшего
порядка, например, различную автогенерацию кода, поддержку тестирования и
т. п.
</BLOCKQUOTE>
Другими словами, командная строка Unix (shell) и является IDE для Unix. Подобный подход позволяет не зацикливаться на програмных решениях одного производителя (разработчика). Любой компонент, воспринимаемый как часть IDE (компилятор, отладчик, компоновщик, редактор, ассемблер, утилиты сборки и тестирования проекта, система контроля версий) может быть заменен на другой. Эти компоненты мы условно можем назвать <EM>Инструментальные средства Unix</EM>.<BR>
<BR>
<!--TOC section Низкоуровневый доступ к системе-->

<H2 CLASS="section"><A NAME="htoc99">8.3</A>&nbsp;&nbsp;Низкоуровневый доступ к системе</H2><!--SEC END -->

Базой UNIX-системы является компилятор Си (сс), библиотека libc и ядро.<BR>
<BR>
Все версии UNIX предоставляют строго определенный, ограниченный набор входов в ядро ОС, через которые прикладные задачи получают доступ к базовым услугам UNIX. Эти точки входа называются <EM>системными вызовами (system calls)</EM>.<BR>
<BR>
Системный вызов определяет функцию, выполняемую ядром ОС от имени процесса, выполнившего вызов. Syscall является интерфейсом самого низкого уровня взаимодействия прикладных процессов с ядром.<BR>
<BR>
Язык системного программирования - Си. Характерная особенность Unix - ассемблер практически не используется. Более того, часть прерываний и регистров просто недоступна из program space. Ассемблер применяется только для написания драйверов устройств и ядра (платформенно-зависимые их части). <BR>
<BR>
Библиотека <EM>libc</EM> - это набор интерфейсов к системным вызовам и различных функций, работающих поверх системных вызовов. Для программиста различие между <EM>системным вызовом</EM> и <EM>библиотечной функцией</EM> лишь в том, как они взаимодействуют с ядром. Системный вызов сразу уходит в пространство ядра и там выполняется. Библиотечная функция выполняется в пространстве процесса (хотя конечно может и делать системные вызовы в ходе выполнения).<BR>
<BR>
<!--TOC section Принципы разработки программ для Unix-->

<H2 CLASS="section"><A NAME="htoc100">8.4</A>&nbsp;&nbsp;Принципы разработки программ для Unix</H2><!--SEC END -->

Чтобы плавать, надо плавать. Мао Цзе Дун (из красных книжечек председателя Мао)<BR>
<BR>
За 30 лет существования вокруг Unix сформировалась своя культура: слэнг, традиции и опыт, передаваемый между поколениями программистов. Принципы - это набор философских высказываний, подводящий итоги и суммирующий опыт тысяч человеко-лет разработки.<BR>
<BR>
Из Tao Of The Unix Programming (by Eric S. Raymond):
<UL CLASS="itemize"><LI CLASS="li-itemize">
Правило модульности: Пишите простые части, соединяемые ясными интерфейсами.
<LI CLASS="li-itemize">Правило ясности: Ясность лучше чем изощренность.
<LI CLASS="li-itemize">Правило соединения: Проектируйте программы чтобы они могли взаимодействовать с другими программами.
<LI CLASS="li-itemize">Правило разделения: Отделяйте алгоритмы от механизмов и интерфейсы от движков.
<LI CLASS="li-itemize">Правило простоты: Разрабатывайте просто. Используйте сложные конструкции только тогда, когда без этого не обойтись.
<LI CLASS="li-itemize">Правило умеренности: Пишите большую программу, только если ясно, что больше ничего не поможет.
<LI CLASS="li-itemize">Правило прозрачности: Пишите наглядно, чтобы сделать просмотр и отладку программы легче.
<LI CLASS="li-itemize">Правило надежности: Надежность - следствие ясности и простоты.
<LI CLASS="li-itemize">Правило представления: Храните знания в данных, а программная логика должна быть надежной и тупой.
<LI CLASS="li-itemize">Правило наименьшего удивления: Когда разрабатываете интерфейсы, делайте их как можно более предсказуемыми.
<LI CLASS="li-itemize">Правило тишины: Когда программе нечего сказать нового, она должна молчать.
<LI CLASS="li-itemize">Правило восстановления: Когда программа должна ошибиться, она должна шумно и долго об этом вопить. Настолько часто, насколько это возможно.
<LI CLASS="li-itemize">Правило экономии: Время программиста - дорогое, экономьте его, взваливая как можно больше задач на компьютер (автоматизация).
<LI CLASS="li-itemize">Правило генерации кода: Избегайте ручного кодирования. Пишите программы для генерации других программ всегда, когда возможно.
<LI CLASS="li-itemize">Правило оптимизации: Делайте прототипы перед полировкой кода. Заставьте код работать, прежде чем оптимизировать.
<LI CLASS="li-itemize">Правило многообразия: Не доверяйте всем претензиям на "единственно верное решение"
<LI CLASS="li-itemize">Правило рамширяемости: Проектируйте с прицелом на будущее. Оно может наступить быстрее чем вы думаете.
</UL>
Философия Unix в одном уроке.<BR>
<BR>
<EM>keep It Simple, Stupid - оставь это простым, тупица.</EM><BR>
<BR>
<!--TOC chapter Инструментальные средства разработчика-->

<H1 CLASS="chapter"><A NAME="htoc101">Chapter&nbsp;9</A>&nbsp;&nbsp;Инструментальные средства разработчика</H1><!--SEC END -->

<!--TOC section Компилятор Си-->

<H2 CLASS="section"><A NAME="htoc102">9.1</A>&nbsp;&nbsp;Компилятор Си</H2><!--SEC END -->

Компилятор языка Си (C compliler или cc) - неотъемлемая часть системы. С него начинается разработка любой версии Unix или перенос на новую платформу существующей. Ядро и базовые утилиты системы написаны на Си<SUP><A NAME="text33" HREF="#note33">1</A></SUP>.<BR>
<BR>
Компилятор реализован как утилита командной строки. Он вызывается командой <CODE>cc</CODE>. Существует большое количество системных компиляторов Cи <SUP><A NAME="text34" HREF="#note34">2</A></SUP> (gcc в Linux и FreeBSD, собственные компиляторы в большинстве коммерческих версий Unix), поэтому <CODE>cc</CODE> будет указывать на компилятор по умолчанию для нашей системы. 
<PRE CLASS="verbatim">
типовые ключи компилятора
$сс foo.c
компилирование и сборка (линковка) программы из 'foo.c' 
создаётся исполняемый файл 'a.out'

$cc -c foo.c
только компилировать. Будет получен объектный модуль 'foo.o'

$cc -o exec_foo foo.c
создается исполняемый файл 'exec_foo' (вместо 'a.out')

$cс foo.c bar.o
слинковать 2 объектных файла в исполняемый ('a.out')
</PRE>
<!--TOC section make-->

<H2 CLASS="section"><A NAME="htoc103">9.2</A>&nbsp;&nbsp;make</H2><!--SEC END -->

<EM>Make</EM> - стандартное средство, применяемое для сборки программных проектов. Является универсальной программой для решения задач автоматической генерации и изменения файлов с учетом зависимостей.<BR>
<BR>
Схема работы: make читает файл с описанием проекта (makefile) и, интерпретируя его содержание, выполняет определенные действия.<BR>
<BR>
Makefile - текстовый файл, описывает отношения между файлами проекта и действия, необходимые для его сборки.<BR>
<BR>
<!--TOC subsection Запуск-->

<H3 CLASS="subsection"><A NAME="htoc104">9.2.1</A>&nbsp;&nbsp;Запуск</H3><!--SEC END -->

Make является утилитой командной строки и запускается командой <CODE>make</CODE>. При запуске <CODE>make</CODE> проверяет наличие файлов <CODE>makefile</CODE>, <CODE>Makefile</CODE> и если и запускает на обработку первый из найденных Make-файлов. Можно явно указать какой Makefile использовать ключом <CODE>-f</CODE>.<BR>
<BR>
<!--TOC subsection Формат и использование make-файлов.-->

<H3 CLASS="subsection"><A NAME="htoc105">9.2.2</A>&nbsp;&nbsp;Формат и использование make-файлов.</H3><!--SEC END -->

Основной элемент - <EM>правила (rules)</EM>.
<PRE CLASS="verbatim">
Общий вид:
&lt;цель 1&gt; &lt;цель 2&gt; ?&lt;цель n&gt;:&lt;зависимость 1&gt; &lt;завис-ть 2&gt;?&lt;завис-ть n&gt;
        &lt;команда 1&gt;
        &lt;команда 2&gt;
        ?
        &lt;команда n&gt;
</PRE>
<EM>Цель (target)</EM> - некий желаемый результат, способ достижения которого описан в правиле. Цель может быть именем файла.<BR>
<BR>
<EM>Примечание</EM>. Перед командами вставляется табуляция, чтобы <CODE>make</CODE> отличал их от целей.
<PRE CLASS="verbatim">
Пример1: цель как имя файла
iEdit: main.o Editor.o
         gcc main.o Editor.o -o iEdit
Пример описывает, как можно получить исполняемый файл из объектных модулей.
</PRE>
Цель может быть именем некоторого действия, тогда правило описывает, как совершается указанное действие.
<PRE CLASS="verbatim">
Пример2: цель как имя действия
clean:
        rm *.o iEdit
</PRE>
Такие цели называют <EM>абстрактными</EM> (phony targets) или псевдоцелями (pseudo targets).<BR>
<BR>
<EM>Зависимость (dependency)</EM> - это 'исходные данные', необходимые для достижения указанной в правиле цели. Это предварительные условия достижения цели. Зависимостью может быть имя файла или имя действия. В примере1 main.o и Editor.o - зависимости. Файлы должны существовать, чтобы можно было собрать iEdit.
<PRE CLASS="verbatim">
Пример3:
clean_all: clean_obj
        rm iEdit
clean_obj:
        rm *.o
 Для достижения сlean_all необходимо выполнить действие clean_obj.
</PRE>
<EM>Команда</EM> - действия, которые надо выполнить для обновления или достижения цели. Перед командой должен быть символ табуляции (код 9). Так make определяет команды.<BR>
<BR>
Типичный makefile, который содержит несколько правил, у каждого правила есть некоторая цель и зависимости.
<PRE CLASS="verbatim">
Пример4: 
1.  iEdit: main.o Editor.o
2.              gcc main.o Editor.o -o iEdit
3.       main.o: main.cpp
4.          gcc -c main.cpp
5. Editor.o: Editor.cpp
6.         gcc - Editor.cpp
7. clean:
8.         rm *.c
</PRE>
Смысл работы - достижение главной цели (default goal). Если цель - имя действия (абстрактная), то выполняется действие. Если главная цель - имя файла, то make строит самую свежую версию. Главная цель обычно задается как параметр make: make iEdit, make clean. Если make вызывается без параметров, то в качестве главной берется первая встреченная цель. (В примере это iEdit). Обычно задают цель <EM>all</EM> как цель по умолчанию.<BR>
<BR>
Алгоритм работы:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	выбор главной цели
	<LI CLASS="li-enumerate">достижение цели
	<LI CLASS="li-enumerate">обработка правил
	<LI CLASS="li-enumerate">обработка зависимостей
</OL>
Достижение цели - проверяет зависимости и потом определяет, надо ли запускать команды.
При вызове make iEdit определяет, что главная цель - iEdit. Правило ее достижения - строки 1,2. Обрабатывая правило iEdit, определяем, что зависит от main.o и Editor.o. Для этих зависимостей существуют правила (3,4) и (5,6). main.o зависит от main.cpp. Если нет еще объектного файла, но существует файл .срр, то запускается компиляция. Аналогично и для Editor.o. Для clean зависимостей нет и make сразу переходит к выполнению.<BR>
<BR>
<EM>Инкрементная сборка</EM> - перекомпилируется только то, что было изменено. Для файлов .с и .срр обычно указываются как зависимости .h файлы.<BR>
<BR>
<!--TOC subsection Переменные make.-->

<H3 CLASS="subsection"><A NAME="htoc106">9.2.3</A>&nbsp;&nbsp;Переменные make.</H3><!--SEC END -->

Присвоение: <CODE>имя = строка</CODE> (можно с пробелами). <BR>
<BR>
Получение значения переменной: <CODE>$(имя)</CODE>. Значение - текстовая строка, может содержать ссылки на другие переменные.
<PRE CLASS="verbatim">
Пример: 
obj_list = main.o Editor.o 
# присвоение; 

$(obj_list) 
# получение значения

1)dir_list = . .. src/include
all:
        echo $(dir_list) 
2)optimize_flags  = -03
compile_flags = $(optimize_flags) -pipe
all:
        echo $(compile_flags)
Результат: -03 -pipe
3)program_name = iEdit
obj_list = main.o Editor.o TextLine.o
$(program_name) : $(obj_list)
        gcc $(obj_list) -o $(program_name)
</PRE>
<EM>Примечание</EM>. Значение переменной вычисляется в момент использования.<BR>
<BR>
Часто используемые переменные:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>CC</CODE> - указать компилятор по умолчанию.
<LI CLASS="li-enumerate"><CODE>CFLAGS</CODE> - параметры компиляции
<LI CLASS="li-enumerate"><CODE>LDFLAGS</CODE> - параметры линковки объектных файлов
</OL>
<!--TOC subsubsection Автоматические переменные-->

<H4 CLASS="subsubsection">Автоматические переменные</H4><!--SEC END -->


<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$^</CODE> - список зависимостей, разделённых пробелами
<LI CLASS="li-itemize"><CODE>$@</CODE> - имя цели (файла). Если у нас несколько целей (см <A HREF="#PatternRules">9.2.4</A>), эта переменная принимает значение той цели, для которой выполняется шаблон в конкетный запуск
<LI CLASS="li-itemize"><CODE>$&lt;</CODE> - имя первой зависимости
</UL>
<PRE CLASS="verbatim">
Пример:
$(program_name):$(obj_name)
        gcc $^ -o $@
</PRE>
<!--TOC subsection Шаблонные правила-->

<H3 CLASS="subsection"><A NAME="htoc107">9.2.4</A>&nbsp;&nbsp;Шаблонные правила</H3><!--SEC END -->

<A NAME="PatternRules"></A>
Шаблонные правила (implicit или pattern rules) применяются к группе файлов.<BR>
<BR>
Синтаксис: 
<PRE CLASS="verbatim">
.&lt;расширение_файлов_завис.&gt; .&lt;расширение_файлов_целей&gt;:
        &lt;команда 1&gt;
        &lt;команда 2&gt;
        ?
        &lt;команда n&gt; 
</PRE><PRE CLASS="verbatim">
Пример:
.cpp .o:
      gcc -c $^
</PRE>
<!--TOC section Системы управления версиями. CVS-->

<H2 CLASS="section"><A NAME="htoc108">9.3</A>&nbsp;&nbsp;Системы управления версиями. CVS</H2><!--SEC END -->

Очень часто над программой работает больше одного человека. Выходят различные версии программ. И существует потребность как то упорядочивать внесение изменений и дополнений. Для этого служат системы управления версиями. Из используемых сейчас можно назвать CVS, RCS, Monotone, Arch, BitKeeper и SourceSafe. <BR>
<BR>
<CODE>CVS</CODE> - <EM>Conhurent Versions Systems</EM> (система управления конкурирующими версиями). <BR>
<BR>
<!--TOC subsection Репозиторий-->

<H3 CLASS="subsection"><A NAME="htoc109">9.3.1</A>&nbsp;&nbsp;Репозиторий</H3><!--SEC END -->

<EM>Репозиторий CVS (или хранилище)</EM> хранит полную копию всех файлов и каталогов под управлением CVS, включая все сделанные<BR>
<BR>
Обычно Вы никогда не получаете доступ к файлам в CVS напрямую. Используются команды CVS для получения копии в "рабочий каталог" и далее работа идёт над копией. 
После внесения изменений - юзер вносит изменения в репозиторий. После этого, в хранилище сохраняется информация о сделанных изменениях, времени внесения изменений и другая подобная информация.<BR>
<BR>
Для указания, какой из репозиторев используется - применяется переменная окружения CVSROOT, либо явно указывается с помощью ключа -d.<BR>
<BR>
Примеры:
<PRE CLASS="verbatim">
$ CVSROOT=/var/cvs; export CVSROOT
$ cvs checkout module/project
или
$ cvs -d /var/cvs module/project
</PRE>
Кроме локальных репозиториев - очень часто используются удалённые (сетевые). Для них необходимо указать адрес и (иногда) - способ доступа.
<PRE CLASS="verbatim">
$ cvs -d server1:/root checkout sdir1
</PRE>
Подробнее об этом - в <A HREF="#cvsbook">??</A> или в её русском переводе на http://opennet.ru<BR>
<BR>
<!--TOC subsection Получение рабочей копии исходников-->

<H3 CLASS="subsection"><A NAME="htoc110">9.3.2</A>&nbsp;&nbsp;Получение рабочей копии исходников</H3><!--SEC END -->

<!--TOC subsection Сохранение результатов и версионирование-->

<H3 CLASS="subsection"><A NAME="htoc111">9.3.3</A>&nbsp;&nbsp;Сохранение результатов и версионирование</H3><!--SEC END -->

<!--TOC subsection Коллективная работа над проектом-->

<H3 CLASS="subsection"><A NAME="htoc112">9.3.4</A>&nbsp;&nbsp;Коллективная работа над проектом</H3><!--SEC END -->

<!--TOC section Библиотека Си (libc)-->

<H2 CLASS="section"><A NAME="htoc113">9.4</A>&nbsp;&nbsp;Библиотека Си (libc)</H2><!--SEC END -->

libc содержит 2 части: <EM>системные вызовы</EM> и <EM>библиотечные функции</EM>. <BR>
<BR>
Системные вызовы определены, как функции языка Си (независимы от фактической реализации в ядре). В UNIX каждый системный вызов имеет соответствующую функцию (или функции) с тем же именем, хранящуюся в стандартной библиотеке Си. Функции из библиотеки выполняют преобразования аргументов и вызов соответствующего кода ядра. Таким образом, библиотечный код - только оболочка, фактические инструкции находятся в ядре.<BR>
<BR>
Функции общего значения - также часть библиотеки, но не являются системными вызовами. Функции общего назначения и системные вызовы - основа среды программирования UNIX.<BR>
<BR>
В отличие от других библиотек, libc линкуется с каждым приложением, написанном на Си.<BR>
<BR>
Информация о системных вызовах и функциях содержится в 2 и 3 разделах <CODE>man</CODE> соотвественно. В различных системах различный набор системных вызовов, поэтому некоторые функции могут быть реализованы как библиотечные в одной системе и как системные вызовы в другой. <BR>
<BR>
libc полностью включает в себя библиотеки, определенные в ANSI C (stdio, math, assert). Как следствие: один из основных методов сделать программу переносимой - это написать ее на ANSI C. Такая программа будет компилироваться и работать на всех unix-системах.<BR>
<BR>
Подробнее интерфейсы libc будут рассмотрены в главах, посвященных архитектуре и межпроцессному взаимодействию.
<BR>
<BR>
<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note33" HREF="#text33"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">Более того, сам язык Си был создан для разработки ядра Unix. Авторы языка Си являются также первыми разработчиками Unix.
<DT CLASS="dt-list"><A NAME="note34" HREF="#text34"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">В SUSv3(POSIX) опредено общее подмножество ключей и параметров, которые должен поддерживать компилятор Cи. Этому набору следуют все системные компиляторы. Естественно, что каждый из них имеет и свои дополнительные параметры.
</DL>
<!--END NOTES-->
<!--TOC chapter Процессы и сигналы.IPC-->

<H1 CLASS="chapter"><A NAME="htoc114">Chapter&nbsp;10</A>&nbsp;&nbsp;Процессы и сигналы.IPC</H1><!--SEC END -->

В UNIX процессы выполняются в собственном адресном пространстве и изолированы друг от друга, таким образом сведены к минимуму
возможности влияния процессов друг на друга.<BR>
<BR>
Но существует необходимость взаимодействия процессов. Для этого требуется:
<UL CLASS="itemize"><LI CLASS="li-itemize">
обеспечить средства взаимодействия
<LI CLASS="li-itemize">исключить нежелательное влияние одного процесса на другой
</UL>
Взаимодействие решает следующие задачи:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
передача данных
<LI CLASS="li-enumerate">совместное использование данных
<LI CLASS="li-enumerate">извещения
</OL>
Решать проблему взаимодействия средствами процессов в рамках многозадачной системы опасно.<BR>
<BR>
<!--TOC section Типы IPC-->

<H2 CLASS="section"><A NAME="htoc115">10.1</A>&nbsp;&nbsp;Типы IPC</H2><!--SEC END -->

<UL CLASS="itemize"><LI CLASS="li-itemize">
 сигналы
 <LI CLASS="li-itemize">каналы
 <LI CLASS="li-itemize">FIFO (именованные каналы)
 <LI CLASS="li-itemize">сообщения (очереди сообщений)
 <LI CLASS="li-itemize">семафоры
 <LI CLASS="li-itemize">разделяемая память
 <LI CLASS="li-itemize">сокеты
</UL>
<!--TOC section Сигналы-->

<H2 CLASS="section"><A NAME="htoc116">10.2</A>&nbsp;&nbsp;Сигналы</H2><!--SEC END -->

Простейший вид IPC. Позволяют уведомлять процесс или группу процессов о наступлении некоторого события.<BR>
<BR>
<EM>Группа процессов</EM> - любой процесс принадлежит определенной группе процессов. У каждой группы есть свой уникальный идентификатор. Лидер группы - процесс, PID которого совпадает с ID группы. Обычно группа наследуется процессом от родителя.<BR>
<BR>
Процесс может покинуть группу и создать свою.<BR>
<BR>
<EM>Управляющий терминал</EM> - процесс может быть связан с терминалом, который называется управляющим. Все процессы группы имеют один и тот же управляющий терминал.<BR>
<BR>
Специальный файл устройства <CODE>/dev/tty</CODE> связан с управляющим терминалом процесса. Драйвер для этого псевдоустройства перенаправляет запросы на фактический терминальный драйвер, который может быть различным для разных процессов.<BR>
<BR>
<EM>Сигнал</EM> - механизм вызова определенной процедуры при наступлении некоторого события.<BR>
<BR>
Есть две фазы в использовании сигналов: генерация (отправление), доставка и обработка. В промежутке - ожидание доставки.<BR>
<BR>
<EM>Примечание</EM>: сигналы не могут накапливаться, то есть в любой конкретный момент времени дожидаться обработки могут только разнотипные сигналы.<BR>
<BR>
Причины оправления сигналов:
<UL CLASS="itemize"><LI CLASS="li-itemize">
особые ситуации (например, деление на 0)
<LI CLASS="li-itemize">терминальные прерывания (нажатия клавиш Del, Ctrl+Z, Ctrl+C, отключение терминала)
<LI CLASS="li-itemize">другие процессы
<LI CLASS="li-itemize">управление заданиями (для командных интерпретаторов)
<LI CLASS="li-itemize">квоты (превышение процессом квот)
<LI CLASS="li-itemize">уведомления (процесс запрашивает информацию о готовности устройства)
<LI CLASS="li-itemize">алармы.
</UL>
Над сигналами можно выполнить три действия:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
изменение реакции на сигнал (обработка)
<LI CLASS="li-enumerate">блокирование сигнала - откладывание обработки на время выполнения критических участков кода
<LI CLASS="li-enumerate">посылка сигнала.
</OL>
<EM>Примечание:</EM> сигналы не могут непосредственно переносить информацию.<BR>
<BR>
Каждому сигналу присвоено мнемоническое имя (например, SIGINT), которое указывает, для чего обычно используется сигнал этого типа. Имена сигналов определены в <CODE>&lt;signal.h&gt;</CODE>.<BR>
<BR>
<!--TOC section Посылка сигналов-->

<H2 CLASS="section"><A NAME="htoc117">10.3</A>&nbsp;&nbsp;Посылка сигналов</H2><!--SEC END -->

<PRE CLASS="verbatim">
#include&lt;sys/types.h&gt;
#include&lt;signal.h&gt;

int kill (pid_t pid, int sig);
</PRE><BR>
<BR>
<CODE>Пример: kill (7421, SIGTERM)</CODE>.<BR>
<BR>
Процесс может посылать сигналы самому себе.<BR>
<BR>
Получение своего PID (<A HREF="#pid">7.2.1</A>) - <CODE>pid=getpid();</CODE> <BR>
<BR>
Получение своего PPID (<A HREF="#ppid">7.2.2</A>) - <CODE>ppid=getppid();</CODE><BR>
<BR>
Ограничения: EUID (<A HREF="#euid">7.2.5</A>) или RID (<A HREF="#rid">7.2.5</A>) процесса, посылающего сигнал, должны совпадать с EUID и RID процесса-адресата. Для администратора таких ограничений нет.<BR>
<BR>
При неудачном вызове kill возвращает -1 и переменной errno присваивается значения: EPERM (нельзя послать чужому процессу), ESRCH (такого процесса нет) , EINVAL (sig содержит неверный номер сигнала).<BR>
<BR>
<!--TOC subsection Смысл параметра PID-->

<H3 CLASS="subsection"><A NAME="htoc118">10.3.1</A>&nbsp;&nbsp;Смысл параметра PID</H3><!--SEC END -->

Pid==0 - сигнал посылается всем процессам группы, к которой принадлежит процесс, пославший сигнал;<BR>
<BR>
Pid==-1 и если EUID не администратора, то посылается всем процессам, RID которых равен EUID посылающего процесса, включая и его (если его RID=EUID);<BR>
<BR>
Pid==-1 и EUID администратора, то сигнал посылается всем процессам, кроме некоторых системных;<BR>
<BR>
Pid&lt;0 и не равен -1 - посылается всем процессам, идентификатор группы которых равен по модулю PID, включая пославший процесс, если он также входит в эту группу.<BR>
<BR>
<!--TOC subsection Посылка сигнала самому себе-->

<H3 CLASS="subsection"><A NAME="htoc119">10.3.2</A>&nbsp;&nbsp;Посылка сигнала самому себе</H3><!--SEC END -->

<PRE CLASS="verbatim">
#include&lt;signal.h&gt;

int raise (int sig)
</PRE>вызывающему процессу посылается сигнал. В случае успеха возвращает 0. Например, <CODE>raise (SIGKILL)</CODE>.<BR>
<BR>
<!--TOC section Таймеры-->

<H2 CLASS="section"><A NAME="htoc120">10.4</A>&nbsp;&nbsp;Таймеры</H2><!--SEC END -->
<BR>
<BR>
<CODE>setitimer</CODE> - установка разных таймеров (3 вида).
<PRE CLASS="verbatim">
#include&lt;unistd.h&gt;

unsigned int alarm (unsigned int secs);
</PRE><BR>
<BR>
<CODE>secs</CODE> - время в секундах, на которое устанавливается таймер. После истечения времени процессу посылается <CODE>SIGALRM</CODE>.<BR>
<BR>
<CODE>Пример: alarm(60).</CODE><BR>
<BR>
<EM>Выключение таймера</EM> <CODE>alarm(0).</CODE><BR>
<BR>
Вызов таймера не накапливается. Вызов следующего отменяет предыдущий.
<PRE CLASS="verbatim">
#include&lt;unistd.h&gt;

int pause (void);
</PRE>приостанавливает выполнение процесса до получения любого сигнала, часто используется вместе с <CODE>alarm</CODE>.<BR>
<BR>
<!--TOC subsection Нормальное и аварийное завершение-->

<H3 CLASS="subsection"><A NAME="htoc121">10.4.1</A>&nbsp;&nbsp;Нормальное и аварийное завершение</H3><!--SEC END -->

Большинство сигналов вызывают нормальное завершение (normal termination). Похоже на вызов процессом функции <CODE>exit</CODE>.<BR>
<BR>
Некоторые сигналы ( SIGABRT, SIGBUS, SIGQUIT, SIGILL и другие) инициируют аварийное завершение со сбросом значения переменных, регистров и т.д. в core (dump).<BR>
<BR>
<!--TOC section Имена сигналов (по алфавиту, выборочно)-->

<H2 CLASS="section"><A NAME="htoc122">10.5</A>&nbsp;&nbsp;Имена сигналов (по алфавиту, выборочно)</H2><!--SEC END -->

Определены в <CODE>&lt;signal.h&gt;</CODE>
<UL CLASS="itemize"><LI CLASS="li-itemize">
SIGABRT - прерывание процесса (abort), посылается процессу при вызове системного вызова abort. Core dump.
<LI CLASS="li-itemize">SIGALRM - сигнал таймера.
<LI CLASS="li-itemize">SIGBUS - аппаратная ошибка на шине. Аварийное завершение.
<LI CLASS="li-itemize">SIGCHLD - останов или завершение дочернего процесса. Игнорируется.
<LI CLASS="li-itemize">SIGCONT - продолжение работы остановленного процесса (обратный для SIGSTOP).
<LI CLASS="li-itemize">SIGHUP - освобождение линии, посылается процессам, подключенным к терминальной линии, при отключении терминала или при завершении работы лидера сеанса членам группы.
<LI CLASS="li-itemize">SIGILL - недопустимая команда процессора. Core dump.
<LI CLASS="li-itemize">SIGINT - нормальное прерывание программы (Сtrl+C). Посылается всем процессам сеанса.
<LI CLASS="li-itemize">SIGKILL - немедленное уничтожение процесса. Не перехватывается.
<LI CLASS="li-itemize">SIGPIPE - попытка записи в канал или сокет, для которого принимающий процесс уже завершил работу.
<LI CLASS="li-itemize">SIGPROF - сигнал профилирующего таймера.
<LI CLASS="li-itemize">SIGQUIT - завершение программы. Похож на SIGINT, но завершение аварийное.
<LI CLASS="li-itemize">SIGSEGV - некорректный адрес памяти. Аварийный сброс.
<LI CLASS="li-itemize">SIGSTOP - сигнал останова. Управление заданиями. Нельзя перехватить.
<LI CLASS="li-itemize">SIGSYS - ошибочный системный вызов.
<LI CLASS="li-itemize">SIGTERM - программный сигнал завершения. Используется для корректного завершения процесса.
<LI CLASS="li-itemize">SIGTSTP - терминальный сигнал остановки (Сtrl+Z). Похож на SIGSTOP, но можно перехватить.
<LI CLASS="li-itemize">SIGTTIN - попытка ввода с терминала фоновым процессом. Остановка процесса.
<LI CLASS="li-itemize">SIGTTOU - попытка вывода на терминал фоновым процессом. Остановка процесса.
<LI CLASS="li-itemize">SIGURG - поступление в буфер сокета срочных внеочередных данных.
<LI CLASS="li-itemize">SIGUSR1, SIGUSR2 - зарезервированы для пользовательских задач. По умолчанию - ничего не происходит.
<LI CLASS="li-itemize">SIGVTALRM - виртуальный таймер.
<LI CLASS="li-itemize">SIGXCPU - превышение лимита процессорного времени. Core dump.
<LI CLASS="li-itemize">SIGXFSZ - превышение лимита на размер файла.
</UL>
<!--TOC section Наборы сигналов-->

<H2 CLASS="section"><A NAME="htoc123">10.6</A>&nbsp;&nbsp;Наборы сигналов</H2><!--SEC END -->

<A NAME="sigset"></A>
<EM>Набор сигналов</EM> - это список сигналов, которые необходимо передать системному вызову.<BR>
<BR>
Тип <CODE>sigset_t</CODE> в <CODE>&lt;signal.h&gt;</CODE>, его размер позволяет поместиться всем сигналам, определенным в системе.<BR>
<BR>
Выбор сигналов - либо из полного, удаляя ненужные, либо из пустого набора, добавляя необходимые.<BR>
<BR>
<!--TOC subsection Инициализация набора-->

<H3 CLASS="subsection"><A NAME="htoc124">10.6.1</A>&nbsp;&nbsp;Инициализация набора</H3><!--SEC END -->

<PRE CLASS="verbatim">
#include &lt;signal.h&gt;

int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
</PRE>
<!--TOC subsection Добавление и удаление сигналов-->

<H3 CLASS="subsection"><A NAME="htoc125">10.6.2</A>&nbsp;&nbsp;Добавление и удаление сигналов</H3><!--SEC END -->

<PRE CLASS="verbatim">
int sigaddset(sigset_t *set, int signo);

int sigdelset(sigset_t *set, int signo);
</PRE>
<!--TOC subsection Типовой сценарий работы с набором-->

<H3 CLASS="subsection"><A NAME="htoc126">10.6.3</A>&nbsp;&nbsp;Типовой сценарий работы с набором</H3><!--SEC END -->

<PRE CLASS="verbatim">
sigset_t mask1, mask2;

sigemptyset(&amp;mask1);

sigaddset(&amp;mask1, SIGINT);
sigaddset(&amp;mask1, SIGQUIT);

sigfillset(&amp;mask2);
sigdelset(&amp;mask2, SIGCHLD);
</PRE>
<!--TOC section Обработчик сигналов-->

<H2 CLASS="section"><A NAME="htoc127">10.7</A>&nbsp;&nbsp;Обработчик сигналов</H2><!--SEC END -->

После определения списка можно задать обработку сигналов:
<PRE CLASS="verbatim">
#include&lt;signal.h&gt;

int sigaction(int signo, const struct sigaction *act, struct sigaction
*oact);
</PRE><BR>
<BR>
<CODE>signo</CODE> - сигнал, для которого задается действие.<BR>
<BR>
<CODE>act</CODE> - определяем обработчик.<BR>
<BR>
<CODE>oact</CODE> - если не NULL, то в эту структуру сохранится старый обработчик.<BR>
<BR>
<!--TOC section Разбор структуры sigaction-->

<H2 CLASS="section"><A NAME="htoc128">10.8</A>&nbsp;&nbsp;Разбор структуры sigaction</H2><!--SEC END -->

<PRE CLASS="verbatim">
struct sigaction {
void (*sa_handler)(int); //функция обработчика
sigset_t sa_mask; //сигналы, блокируемые во время обработки данного
int sa_flags; //флаги, влияющие на поведение сигнала
viod (*sa_sigaction)(int, siginfo_t*, void*);
};
</PRE>
Толкование:<BR>
<BR>
<CODE>sa_handler:</CODE>
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>SIG_DFL</CODE> - константа обработки по умолчанию.
<LI CLASS="li-enumerate"><CODE>SIG_IGN</CODE> - константа игнорирования. Не может применятся для SIGSTOP и SIGKILL.
<LI CLASS="li-enumerate">Адрес функции, принимающей аргумент типа <CODE>int</CODE> (<CODE>sa_handler=f1</CODE>). Она будет вызываться при получении сигнала, а signo передается как параметр.
</OL>
Управление передается функции из любого места программы, а после возврата из нее выполнение будет продолжено с точки, в которой было прервано.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>sa_mask</CODE> - сигналы из этого набора будут игнорироваться во время выполнения функции-обработчика (<CODE>sa_handler</CODE>).
<LI CLASS="li-itemize"><CODE>sa_flags</CODE> - изменение характера реакции:
</UL>
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>SA_RESETHAND</CODE> - после возврата из обработчика вернуть обработчик по умолчанию <CODE>SIG_DFL</CODE>.
<LI CLASS="li-enumerate"><CODE>SA_SIGINFO</CODE> - обработчику передается дополнительная информация и вместо <CODE>sa_handler</CODE> используется <CODE>sa_sigaction</CODE>.
<LI CLASS="li-enumerate"><CODE>SA_RESTART</CODE> - повтор прерванного сигналом системного вызова.
</OL>
<!--TOC section Ненадежные сигналы (устаревшая версия)-->

<H2 CLASS="section"><A NAME="htoc129">10.9</A>&nbsp;&nbsp;Ненадежные сигналы (устаревшая версия)</H2><!--SEC END -->

<PRE CLASS="verbatim">
#include&lt;signal.h&gt;

void (*signal(int sig, void(*disp)(int))) (int);
</PRE><CODE>sig</CODE> - номер сигнала.<BR>
<BR>
<CODE>disp</CODE> - <CODE>SIG_DFL, SIG_IGN</CODE> или функция-обработчик.<BR>
<BR>
<CODE>Пример: signal(SIGINT, SIG_IGN);</CODE><BR>
<BR>
<!--TOC section Блокирование сигналов-->

<H2 CLASS="section"><A NAME="htoc130">10.10</A>&nbsp;&nbsp;Блокирование сигналов</H2><!--SEC END -->
<BR>
<BR>
<CODE>int sigprocmask(int how, const sigset_t *set, sigset_t *oset);</CODE>
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>how</CODE> - указывается, какое действие надо выполнить:
	<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
		<CODE>SIG_MASK</CODE> - установить блокирование сигналов по списку;
		<LI CLASS="li-enumerate"><CODE>SIG_UNBLOCK</CODE> - отмена блокирования сигналов по списку;
		<LI CLASS="li-enumerate"><CODE>SIG_BLOCK</CODE> - добавление списка к текущим блокируемым.
	</OL>
<LI CLASS="li-itemize"><CODE>set</CODE> - набор сигналов.
</UL>
<PRE CLASS="verbatim">
Пример:

sigset_t set1;

sigfillset(&amp;set1);

sigprocmask(SIG_SETMASK, &amp;set1, NULL);

//критический участок - непрерываемый

sigprocmask(SIG_UNBLOCK, &amp;set, NULL);
</PRE>
<EM>Примечание:</EM> можно варьировать наборы и степень защищенности кода.<BR>
<BR>

<!--TOC chapter References-->

<H1 CLASS="chapter">References</H1><!--SEC END -->
<DL CLASS="list" COMPACT="compact"><DT CLASS="dt-list">
<A NAME="Rob"><FONT COLOR=purple>[1]</FONT></A><DD CLASS="dd-list"> А. Робачевский. Операционная система UNIX. Второе издание - BHV, 2005.
<DT CLASS="dt-list"><A NAME="Nemeth"><FONT COLOR=purple>[2]</FONT></A><DD CLASS="dd-list"> Э. Немет, Г. Снайдер и др. UNIX: Руководство системного администратора. Для профессионалов. 3-е изд. - BHV, 2002
<DT CLASS="dt-list"><A NAME="Esr"><FONT COLOR=purple>[3]</FONT></A><DD CLASS="dd-list"> Эрик Реймонд. Искусство программирования для Unix (The Art of Unix Programming). - Вильямс, 2005.
<DT CLASS="dt-list"><A NAME="Glass"><FONT COLOR=purple>[4]</FONT></A><DD CLASS="dd-list"> Грэм Гласс, Кинг Эйблс. Unix для программистов и пользователей. - BHV, 2004.
<DT CLASS="dt-list"><A NAME="Moli"><FONT COLOR=purple>[5]</FONT></A><DD CLASS="dd-list"> Б. Моли. Unix/Linux: теория и практика программирования. - Кудиц-образ, 2004.
<DT CLASS="dt-list"><A NAME="Ker"><FONT COLOR=purple>[6]</FONT></A><DD CLASS="dd-list"> Б. Керниган, Р. Пайк. UNIX. Программное окружение. Символ, 2003
<DT CLASS="dt-list"><A NAME="Friedle"><FONT COLOR=purple>[7]</FONT></A><DD CLASS="dd-list"> Дж. Фридл. Регулярные выражения. Библиотека программиста. - Питер, 2001. 
<DT CLASS="dt-list"><A NAME="Robbins"><FONT COLOR=purple>[8]</FONT></A><DD CLASS="dd-list"> Арнольд Роббинс. Linux. Программирование в примерах. - Кудиц-образ, 2005. 
<DT CLASS="dt-list"><A NAME="Pet"><FONT COLOR=purple>[9]</FONT></A><DD CLASS="dd-list"> К. Петцке. LINUX. От понимания к применению. - ДМК, 2000.
<DT CLASS="dt-list"><A NAME="NetProgVol1"><FONT COLOR=purple>[10]</FONT></A><DD CLASS="dd-list"> У. Стивенс. UNIX: разработка сетевых приложений. - Питер, 2003.
<DT CLASS="dt-list"><A NAME="NetProgVol2"><FONT COLOR=purple>[11]</FONT></A><DD CLASS="dd-list"> У. Стивенс. UNIX: взаимодействие процессов. - Питер, 2002.
<DT CLASS="dt-list"><A NAME="Asp"><FONT COLOR=purple>[12]</FONT></A><DD CLASS="dd-list"> ASPLinux. Руководство пользователя. - ASPLinux, 2001.
<DT CLASS="dt-list"><A NAME="Bah"><FONT COLOR=purple>[13]</FONT></A><DD CLASS="dd-list"> М. Бах. Архитектура операционной системы UNIX. http://www.lib.ru.
<DT CLASS="dt-list"><A NAME="Sol"><FONT COLOR=purple>[14]</FONT></A><DD CLASS="dd-list"> А. Соловьев. Sed и awk. Учебное пособие.
<DT CLASS="dt-list"><A NAME="shell"><FONT COLOR=purple>[15]</FONT></A><DD CLASS="dd-list"> Программирование на shell (Unix).
<DT CLASS="dt-list"><A NAME="bootle"><FONT COLOR=purple>[16]</FONT></A><DD CLASS="dd-list"> Стен Келли-Бутл. Введение в Unix. - Лори, 1995.
<DT CLASS="dt-list"><A NAME="Sage"><FONT COLOR=purple>[17]</FONT></A><DD CLASS="dd-list"> Rassel S. Sage. Приемы профессиональной работы в UNIX. http://www.citforum.ru.
<DT CLASS="dt-list"><A NAME="Mak"><FONT COLOR=purple>[18]</FONT></A><DD CLASS="dd-list"> Дж. МакМален. UNIX. - Компьютер, 1996.
<DT CLASS="dt-list"><A NAME="text"><FONT COLOR=purple>[19]</FONT></A><DD CLASS="dd-list"> А. Шевель. Linux. Обработка текста. Специальный справочник. - Питер, 2001 
<DT CLASS="dt-list"><A NAME="cvsbook"><FONT COLOR=purple>[20]</FONT></A><DD CLASS="dd-list"> Free Software Foundation. CVS book. 1993-2004.</DL>


<!--TOC chapter GNU Free Documentation License-->

<H1 CLASS="chapter"><A NAME="htoc131">Chapter&nbsp;11</A>&nbsp;&nbsp;GNU Free Documentation License</H1><!--SEC END -->


 <DIV CLASS="center">
Version 1.2, November 2002<BR>
<BR>
Copyright ©2000,2001,2002 Free Software Foundation, Inc.<BR>
<BR>
<BR>
<BR>
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA<BR>
<BR>
<BR>
<BR>
Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
</DIV><BR>
<BR>
<DIV CLASS="center">
<B><FONT SIZE=4>Preamble</FONT></B>
</DIV><BR>
<BR>
The purpose of this License is to make a manual, textbook, or other
functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.<BR>
<BR>
This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense. It
complements the GNU General Public License, which is a copyleft
license designed for free software.<BR>
<BR>
We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does. But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book. We recommend this License
principally for works whose purpose is instruction or reference.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>1. APPLICABILITY AND DEFINITIONS</B></FONT>

</DIV><BR>
<BR>
This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License. Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein. The <B>"Document"</B>, below,
refers to any such manual or work. Any member of the public is a
licensee, and is addressed as <B>"you"</B>. You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.<BR>
<BR>
A <B>"Modified Version"</B> of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.<BR>
<BR>
A <B>"Secondary Section"</B> is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject. (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.) The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.<BR>
<BR>
The <B>"Invariant Sections"</B> are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License. If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant. The Document may contain zero
Invariant Sections. If the Document does not identify any Invariant
Sections then there are none.<BR>
<BR>
The <B>"Cover Texts"</B> are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License. A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.<BR>
<BR>
A <B>"Transparent"</B> copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters. A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text. A copy that is not "Transparent" is called <B>"Opaque"</B>.<BR>
<BR>
Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification. Examples of
transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.<BR>
<BR>
The <B>"Title Page"</B> means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page. For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.<BR>
<BR>
A section <B>"Entitled XYZ"</B> means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language. (Here XYZ stands for a
specific section name mentioned below, such as <B>"Acknowledgements"</B>,
<B>"Dedications"</B>, <B>"Endorsements"</B>, or <B>"History"</B>.) 
To <B>"Preserve the Title"</B>
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.<BR>
<BR>
The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document. These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>2. VERBATIM COPYING</B></FONT>

</DIV><BR>
<BR>
You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License. You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute. However, you may accept
compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3.<BR>
<BR>
You may also lend copies, under the same conditions stated above, and
you may publicly display copies.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>3. COPYING IN QUANTITY</B></FONT>

</DIV><BR>
<BR>
If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover. Both covers must also clearly and legibly identify
you as the publisher of these copies. The front cover must present
the full title with all words of the title equally prominent and
visible. You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.<BR>
<BR>
If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.<BR>
<BR>
If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.<BR>
<BR>
It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>4. MODIFICATIONS</B></FONT>

</DIV><BR>
<BR>
You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it. In addition, you must do these things in the Modified Version:
<UL CLASS="itemize"><LI CLASS="li-itemize">
A. 
 Use in the Title Page (and on the covers, if any) a title distinct
 from that of the Document, and from those of previous versions
 (which should, if there were any, be listed in the History section
 of the Document). You may use the same title as a previous version
 if the original publisher of that version gives permission.<BR>
<BR>
<LI CLASS="li-itemize">B.
 List on the Title Page, as authors, one or more persons or entities
 responsible for authorship of the modifications in the Modified
 Version, together with at least five of the principal authors of the
 Document (all of its principal authors, if it has fewer than five),
 unless they release you from this requirement.<BR>
<BR>
<LI CLASS="li-itemize">C.
 State on the Title page the name of the publisher of the
 Modified Version, as the publisher.<BR>
<BR>
<LI CLASS="li-itemize">D.
 Preserve all the copyright notices of the Document.<BR>
<BR>
<LI CLASS="li-itemize">E.
 Add an appropriate copyright notice for your modifications
 adjacent to the other copyright notices.<BR>
<BR>
<LI CLASS="li-itemize">F.
 Include, immediately after the copyright notices, a license notice
 giving the public permission to use the Modified Version under the
 terms of this License, in the form shown in the Addendum below.<BR>
<BR>
<LI CLASS="li-itemize">G.
 Preserve in that license notice the full lists of Invariant Sections
 and required Cover Texts given in the Document's license notice.<BR>
<BR>
<LI CLASS="li-itemize">H.
 Include an unaltered copy of this License.<BR>
<BR>
<LI CLASS="li-itemize">I.
 Preserve the section Entitled "History", Preserve its Title, and add
 to it an item stating at least the title, year, new authors, and
 publisher of the Modified Version as given on the Title Page. If
 there is no section Entitled "History" in the Document, create one
 stating the title, year, authors, and publisher of the Document as
 given on its Title Page, then add an item describing the Modified
 Version as stated in the previous sentence.<BR>
<BR>
<LI CLASS="li-itemize">J.
 Preserve the network location, if any, given in the Document for
 public access to a Transparent copy of the Document, and likewise
 the network locations given in the Document for previous versions
 it was based on. These may be placed in the "History" section.
 You may omit a network location for a work that was published at
 least four years before the Document itself, or if the original
 publisher of the version it refers to gives permission.<BR>
<BR>
<LI CLASS="li-itemize">K.
 For any section Entitled "Acknowledgements" or "Dedications",
 Preserve the Title of the section, and preserve in the section all
 the substance and tone of each of the contributor acknowledgements
 and/or dedications given therein.<BR>
<BR>
<LI CLASS="li-itemize">L.
 Preserve all the Invariant Sections of the Document,
 unaltered in their text and in their titles. Section numbers
 or the equivalent are not considered part of the section titles.<BR>
<BR>
<LI CLASS="li-itemize">M.
 Delete any section Entitled "Endorsements". Such a section
 may not be included in the Modified Version.<BR>
<BR>
<LI CLASS="li-itemize">N.
 Do not retitle any existing section to be Entitled "Endorsements"
 or to conflict in title with any Invariant Section.<BR>
<BR>
<LI CLASS="li-itemize">O.
 Preserve any Warranty Disclaimers.
</UL>
If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant. To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.<BR>
<BR>
You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties&ndash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.<BR>
<BR>
You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version. Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.<BR>
<BR>
The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>5. COMBINING DOCUMENTS</B></FONT>

</DIV><BR>
<BR>
You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.<BR>
<BR>
The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy. If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.<BR>
<BR>
In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications". You must delete all sections
Entitled "Endorsements".<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>6. COLLECTIONS OF DOCUMENTS</B></FONT>

</DIV><BR>
<BR>
You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.<BR>
<BR>
You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>7. AGGREGATION WITH INDEPENDENT WORKS</B></FONT>

</DIV><BR>
<BR>
A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.<BR>
<BR>
If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>8. TRANSLATION</B></FONT>

</DIV><BR>
<BR>
Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections. You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers. In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.<BR>
<BR>
If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>9. TERMINATION</B></FONT>

</DIV><BR>
<BR>
You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License. Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License. However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>10. FUTURE REVISIONS OF THIS LICENSE</B></FONT>

</DIV><BR>
<BR>
The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See
http://www.gnu.org/copyleft/.<BR>
<BR>
Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation. If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.<BR>
<BR>
<DIV CLASS="center">
<FONT SIZE=5><B>ADDENDUM: How to use this License for your documents</B></FONT>

</DIV><BR>
<BR>
To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:<BR>
<BR>
<BR>
<BR>
<BLOCKQUOTE CLASS="quote">
 Copyright ©YEAR YOUR NAME.
 Permission is granted to copy, distribute and/or modify this document
 under the terms of the GNU Free Documentation License, Version 1.2
 or any later version published by the Free Software Foundation;
 with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
 A copy of the license is included in the section entitled "GNU
 Free Documentation License".
</BLOCKQUOTE>
<BR>
<BR>
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the "with...Texts." line with this:<BR>
<BR>
<BR>
<BR>
<BLOCKQUOTE CLASS="quote">
 with the Invariant Sections being LIST THEIR TITLES, with the
 Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
</BLOCKQUOTE>
<BR>
<BR>
If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.<BR>
<BR>
If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.<BR>
<BR>

<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
