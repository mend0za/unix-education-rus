\chapter{Shell (оболочка)}
\section{Понятие оболочки}

\emph{Оболочки (командные интерпретаторы, процессоры, shells)} представляют собой промежуточные уровень между пользователем и ОС. Они анализируют командную строку, выполняют преобразования аргументов команд, находя и выполняя команды.

Shell  это обычная прикладная программа. Она не является частью ядра, и поэтому может быть заменена на любую другую, например, на игрушку или текстовый редактор. Из оболочки может быть запущена другая оболочка (или такая же), что дает дополнительные возможности.

Виды shell: sh, csh, ksh, zsh, tcsh, ash и другие.

В курсе будет рассматриваться \emph{Bourne Shell - sh}. Оболочки, совместимые с Bourne Shell существуют для все версий Unix. На лабораторных работах будет использоваться \verb+bash+ (Bourne Again SHell).

\section{Bourne Shell}

\emph{Сценарий (скрипт)} оболочки представляет собой текстовый файл, который задает выполнение последовательности действий. Сценарий может содержать любую последовательность команд (как внутренних команд оболочки, так и внешних команд UNIX, с аргументами или без них), вызовов программ или других написанных ранее сценариев.

Про Shell можно сказать, что это и программа и язык программирования.

Работа пользователя в командной сроке ничем не отличается от выполнения длинного запутанного скрипта.

Механизм работы скрипта: при запуске скрипта из командной строки запускается копия интерпретатора, для которого вводом служит скрипт (как-будто пользователь сам вводил эти команды).

\emph{Способы запуска}: по имени, bash имя.\\
Для запуска по имени, файл скрипта должнен иметь атрибут X (eXecutable - исполняемый). Подробнее  об атрибутах будет расказано в \ref{attrib} 


\subsection{Структура скриптов}

\verb+#+ - то, что следует за ним(в том числе и другие \verb+#+), является комментарием. Комментарии могут занимать всю строку или следовать за командой.\\
\verb+\+ - обозначает, что строка продолжится на следующей строке файла.

Можно записать несколько команд в 1 строку, разделенных \verb+;+ \label{tz}.

\section{Переменные}

Значение переменной - строка, которая передается присваиванием.\\
\verb+V1 = 5; v2 = "string"+ \footnote{Значения переменных будут переходить из примера в пример}\\
Переменной также можно  присваивать значение, которое возвращается командой.\\
\verb+V3 = `pwd`+

\begin{center}
Получение значения
\end{center} 
\begin{itemize}
\item \verb+$имя_переменной+ - в это место подставляется значение переменной.
\item \verb+$(имя_переменной)+ -  отделяем переменную от последующих символов.
\begin{verbatim}
Пример: 
$ echo result = $(v1)2 +
result = 52+
\end{verbatim}
\end{itemize}

В shell существует ряд \emph{предопределенных} переменных\footnote{Полный список встроенных и предопределенных переменных можно найти в man bash}:
\begin{itemize}
	\item \verb+HOME+ - домашний каталог пользователя
	\item \verb+PATH+ - путь поиска исполняемых программ 
	\item \verb+MAIL+ - полное имя файла с почтой пользователя
	\item \verb+PS1,PS2+ - первичное и вторичное приглашение shell (Значок \verb+$+, который пишется в примерах - это первичное приглашение).
\end{itemize}

В shell существует ряд переменных, которые определяются оболочкой по ходу выполнения скриптов. Это так называемые \emph{встроенные} переменные:
\begin{enumerate}
	\item \verb+$0, $1, $2, ... ,$9+  значения параметров, передаваемых скрипту из командной строки. 
	\item \verb+$0+  - имя самого скрипта.\\
		\emph{Примечание}: хороший стиль программирования  выдавать имя скрипта по \verb+$0+ в выдаваемом скриптом сообщении.
	\item \verb+$#+ - число параметров, переданных скрипту;
	\item \verb+$*+ - все параметры, переданные скрипту. Представляют собой единое слово, заключенное в кавычки.
\end{enumerate}

Существуют три вида кавычек при присваивании переменных:
\begin{itemize}
	\item \verb+' '+ - непосредственная  подстановка,  например: \verb+v4='$v1'+  присвоит  \verb+$v1+, а не 5.
	\item \verb+" "+ - подстановка после интерпретации символов \verb+\+ и \verb+$+. Например: \verb+v5=$v1+. Переменной \verb+v5+ присвоится 5.
		Записи без подстановочных символов эквивалентны. 
		\begin{verbatim}
		Например присваивание
        		v6=string
        		v7="string"
        		v8='string'
		даст одинаковый результат. Кавычки одного вида экранируют другие.
		\end{verbatim}
	\item \verb+` `+ - выполнение команды внутри скобок. Результат выполнения команды будет присвоен переменной.\\
	\verb+Пример: $list=`ls -a`+
\end{itemize}

По умолчанию все переменные локальны, то есть существуют, пока выполняется скрипт. Чтобы сделать их глобальными (для данного shell), надо задать их при помощи export. \verb+например: export v1+

При выводе неопределенных переменных результатом будет пустая строка.

Для удаления переменной используется \verb+unset список_переменных+. \verb+Пример: $ unset $v1 $v3 $v4+

Команда \verb+set+ выводит список всех установленных переменных shell.


\section{Перенаправление ввода/вывода}.

\label{redirect}Каждая программы, запущенная из shell, получает три открытых потока ввода/вывода, которые по умолчанию ассоциируются с терминалом. Потоки задаются номерами(\emph{дескрипторы}):
\begin{itemize}
\item 0 стандартный поток ввода, ассоциируется с клавиатурой
\item 1 стандартный поток вывода, ассоциируется с экраном
\item 2 стандартный поток ошибок, ассоциируется с экраном
\end{itemize}

Большинство утилит Unix используют только стандартные потоки, поэтому для этих утилит можно осуществлять перенаправление.
\begin{center}
Виды перенаправления
\end{center}
\begin{itemize}
	\item \verb+>file+ - поток вывода перенаправляется в файл. \verb+Пример: cat file1>file2+
	\item \verb+>>file+ - данные из потока вывода добавляются в файл.
	\item \verb+<file+ -  получение данных для стандартного ввода из файла.
	\item \verb+p1|p2+ - передача вывода программы р1 на ввод программы р2 (\emph{конвейер или неименованный канал}). \verb+Пример: cat spisok | wc l+
	\item \verb+n>file+ - переключение потока с номером \verb+n+ в файл.
	\item \verb+n>>file+ - переключение потока с дескриптором \verb+n+ в файл, но данные добавляются в конец файла.
	\item \verb+n>&m+  - объединить потоки с дескрипторами \verb+n+ и \verb=m=. 
	\item \verb+<<str+ - конструкция \emph{"Ввод здесь"}. Использует стандартный поток ввода до появления строки \verb+str+ во вводе и потом передает его на вход программе.
\end{itemize}
\begin{verbatim}
Примеры: 
1)ls -al | wc 1>&2 1>>wc.out
2)run 2>/dev/null  подавление вывода ошибок.
\end{verbatim}


\section{Шаблоны(wildcard's, подстановочные символы)}

Оболочка позволяет делать подстановку имен. \emph{Подстановочный символ} заменяется оболочкой на имена файлов, если что-то в каталоге подходит под шаблон. Это полезно в случаях, когда файлов много или необходимо выбрать несколько файлов по определенному правилу.
\begin{itemize}
\item \verb+*+  - заменяет любое количество символов (может быть и 0) , в имени файла.
\item \verb+?+  - заменяет любой символ в имени файла.
\item \verb+[символы]+ -  задает любой символ из диапазона.\verb+[a-c1-3]+ тоже что и  \verb+[abc123]+
\item \verb+\с+  - задает символ с буквально (\emph{экранирует}) \label{slash}, если с  это спецсимвол(\verb+\,',",`,# и т.д.+).
\end{itemize}
\begin{verbatim}
Примеры: 
$ ls [a-d]* //все файлы, начинающиеся на a,b,c,d
$ ls x*y // все, начинающиеся на x и кончающиеся на y
$ ls *\ ? // предпоследний символ - пробел
\end{verbatim}

\section{Условное выполнение команд}

Следующая удобная возможность - \emph{условное выполнение}. Его суть такова: пусть ваши действия зависят от результата выполнения предыдущих. Выше уже упоминался разделитель команд \verb+';'+ (см. \ref{tz}). Но при использовании \verb+';'+ последовательность команд всегда выполниться, вне зависимости от результатов работы отдельных команд (ошибок в них). 

Для повышения гибкости работы, в Bourne Shell существуют следующие конструкции: 
\begin{itemize}
\item \verb+p1&&p2+  выполняется р1, если удачно (код возврата 0\footnote{Коды возврата для shell - противоположны Си (см. \ref{shellreturncode})}), то запускается р2
\item \verb+p1||p2+ - выполняется р1, если неудачно (код возврата не 0), то запускается р2
\item \verb+p1&+ - р1 выполняется в фоновом режиме, и shell не ждет окончания работы р1 (см. \ref{jobcontrol}, Контроль заданий). Оболочка сразу выводит приглашение на ввод.
\item \verb+(p1;p2;)+ - команды выполняются последовательно в новой оболочке.  
\item \verb+{p1;p2;}+ - команды выполняются последовательно в текущей shell.
\end{itemize}
\begin{verbatim}
Примеры: 
1)(ps; who) | more
2)mount | wc -l > mounts.number &
\end{verbatim}

\emph{Примечание}: процессы в фоновом режиме не могут использовать стандартный ввод и вывод, поэтому их надо перенаправлять. Поток ошибок работает без изменений.


\section{Условные выражения}

Синтаксис
\begin{verbatim}
if   условие 		
then 
else 	
fi 					 
\end{verbatim}

В shell true (0)  и false (не 0) имеют обратные значения по сравнению с Си.\label{shellreturncode}. \footnote{Более подробно коды возврата отдельных команд описаны в man в пункте EXIT STATUS или DIAGNOSTIC или RETURN CODE}

Условные выражения можно записывать в строчку, разделяя ;.

Условием может быть результат команды. Часто используется \verb+test+ с параметрами. Наиболее употребимые значения:
\begin{itemize}
\item test s файл  - является ли размер файла отличным от 0
\item test r файл  - доступен ли файл для чтения
\item test f файл  - существует ли файл и является ли он обычным
\item test d файл  - существует ли файл и является ли он каталогом
\end{itemize}

Можно записывать без \verb+test+, используя то же значение в \verb+[ ... ]+.

\emph{Примечание}. Между \verb+[, ], if+ обязательно должны стоять пробелы!

\begin{verbatim}
Пример: следующие записи эквивалентны:
1)if test f $HOME/file.txt
then
            echo Он есть!
     fi
2)if [ -f $HOME/file.txt]
then
            echo Он есть!
     fi
3)  test f $HOME/file.txt && echo Он есть!
\end{verbatim}

\subsection{Сравнение строк}
 
\begin{itemize}
\item \verb+строка1 = строка2+  проверка на равенство
\item \verb+строка1 != строка2+  проверка на не равно
\item \verb+-n $переменная+  true, если строка имеет ненулевую длину
\end{itemize}
\begin{verbatim}
Примеры:
1)if [ $v1 = abc ]; then; echo Потрясающе!
2)if [ -n $empty ]; then; echo Действительно
\end{verbatim}

\subsection{Сравнение чисел}

Аргументами являются \verb+$x+(значение переменной) или число\footnote{Тут наблюдается некоторое сходство с ассемблером}:
\begin{enumerate}
\item \verb+$x eq $y+   true, если аргументы равны
\item \verb+$x ne $y+  true, если аргументы не равны
\item \verb+$x gt $y+  true, если значение x больше значения y 
\item \verb+$x ge $y+  true, если значение x больше либо равно значению y
\end{enumerate}

\verb+Пример:  if [ $# eq 2 ]; then; echo 2 аргумента +

\subsection{Сложные выражения}

\begin{enumerate}
\item \verb+!выражение+	- отрицание
\item \verb+выражение1 a выражение2+	- логическое И
\item \verb+выражение1 o выражение2+	- логическое ИЛИ
\end{enumerate}
\begin{verbatim}
Пример: 
1)if [ !\( $x eq $y\) ]
2)if [ $a ne 3 a $b lt $c ]
3)if [ $x = $y a \( $n lt 0 o $m gt 30\) ]
\end{verbatim}
\emph{Примечание}: Скобки экранируются (см. \ref{slash}), так как они имеют специальный смысл для команд (последовательное выполнение в новом экземпляре shell).


\section{Циклы}

В языке shell есть несколько видов циклов. Часто употребимые из них:\verb+for+, \verb+while+ .
\begin{itemize}
\item Цикл \verb+for+\footnote{BASH поддерживает также циклы в стиле Си: for ((i=1; $i<10; $i++)) - c 2 открывающими и закрывающими скобками. } выполниться столько раз, сколько слов в списке. var последовательно принимает значения из списка. Список может формироваться вручную, как вывод команды (`команда`) или с помощью шаблонов.
\begin{verbatim}
for переменная in список
do
....
done
\end{verbatim}
\item Цикл \verb+while+ выполняется, пока условие не станет ложным.
\begin{verbatim}
while условие
do
...
done
\end{verbatim}
\end{itemize}
\begin{verbatim}
Примеры:
while sleep 60
do
 who | grep mary
done

for user in `who`
do
  echo и этот $user здесь!
done

for i in * ; do echo $i; done  #эквивалент ls.
\end{verbatim}

Элементы цикла  можно записывать на отдельных строках или разделяя ';'. Эти формы записи эквивалентны.

\emph{Примечание}. Если вводить в командной строке цикл, условное выражение или просто не закрыть скобку (кавычки) то при нажатии \verb+ENTER+ оболочка предложит вводить окончание команды на следующей строке.

Существует \emph{встроенная}(см. \ref{internalcmd}) команда \verb+break+ для  выхода из цикла.

\section{Функции}

Для упорядочивания скрипта пользователь может определить функцию:
\begin{verbatim}
имя_функции ()
{
   команды
}
\end{verbatim}
Синтаксис и передача аргументов - как у скрипта.
\begin{verbatim}
Пример: отображает в приглашении имя каталога
mcd ()
{
		cd $*
		PS1 = `pwd`
}
\end{verbatim}

Команды разделяются на \emph{встроенные} (в оболочку) \label{internalcmd} и \emph{внешние}. Запуск встроенной команды не требует создания нового процесса.
 
Распространенные встроенные команды: \verb+cd+, \verb+pwd+, \verb+echo+, \verb+exit+, \verb+set+, \verb+unset+.


\section{Выполнение арифметических операций}

\emph{Важное замечание}. В shell выполняется только целочисленная арифметика\footnote{Для плавающей точки и сложных вычислений можно использовать программу bc}!

\verb+еxpr строка+  преобразует строку в число. \verb+Например: expr 23+.

Выполняются операции: \verb=+, -, *, /, %= (деление по модулю). Их приоритет обычный.
\begin{verbatim}
Примеры: 
1)a = `expr $a + 3`
2)b = `expr 2 \* 3` - символ \ отменяет специальное значение *.
\end{verbatim}
\emph{Примечание}. Числа и операции разделяются пробелами.
