
                         Лекция No.8. IPC. Сигналы.

   В UNIX процессы выполняются в собственном адресном пространстве и
   изолированы друг от друга, таким образом сведены к минимуму
   возможности влияния процессов друг на друга.

   Но существует необходимость взаимодействия процессов. Для этого
   требуется:

     * обеспечить средства взаимодействия
     * исключить нежелательное влияние одного процесса на другой

   Взаимодействие решает следующие задачи:

    1. передача данных
    2. совместное использование данных
    3. извещения

   Решать проблему взаимодействия средствами процессов в рамках
   многозадачной системы опасно.

   Типы IPC:

     * сигналы
     * каналы
     * FIFO (именованные каналы)
     * 0x08 graphic
       0x08 graphic
       сообщения (очереди сообщений)
     * семафоры
     * разделяемая память
     * сокеты

                                  Сигналы.

   Простейший вид IPC. Позволяют уведомлять процесс или группу процессов
   о наступлении некоторого события.

   Группа процессов - любой процесс принадлежит определенной группе
   процессов. У каждой группы есть свой уникальный идентификатор. Лидер
   группы - процесс, PID которого совпадает с ID группы. Обычно группа
   наследуется процессом от родителя.

   Процесс может покинуть группу и создать свою.

   Управляющий терминал - процесс может быть связан с терминалом, который
   называется управляющим. Все процессы группы имеют один и тот же
   управляющий терминал.

   Специальный файл устройства /dev/tty- связан с управляющим терминалом
   процесса. Драйвер для этого псевдоустройства перенаправляет запросы на
   фактический терминальный драйвер, который может быть различным для
   разных процессов.

   Сигнал - механизм вызова определенной процедуры при наступлении
   некоторого события.

   Есть две фазы в использовании сигналов: генерация (отправление),
   доставка и обработка. В промежутке - ожидание доставки.

   Примечание: сигналы не могут накапливаться, то есть в любой конкретный
   момент времени дожидаться обработки могут только разнотипные сигналы.

   Причины оправления сигналов:

     * особые ситуации (например, деление на 0)
     * терминальные прерывания (нажатия клавиш Del, Ctrl+Z, Ctrl+C,
       отключение терминала)
     * другие процессы
     * управление заданиями (для командных интерпретаторов)
     * квоты (превышение процессом квот)
     * уведомления (процесс запрашивает информацию о готовности
       устройства)
     * алармы.

   Над сигналами можно выполнить три действия:

    1. изменение реакции на сигнал (обработка)
    2. блокирование сигнала - откладывание обработки на время выполнения
       критических участков кода
    3. посылка сигнала.

   Примечание: сигналы не могут непосредственно переносить информацию.

   Каждому сигналу присвоено мнемоническое имя (например, SIGINT),
   которое указывает, для чего обычно используется сигнал этого типа.
   Имена сигналов определены в <signal.h>.

   Посылка сигналов:

   #include<sys/types.h>

   #include<signal.h>

   int kill (pid_t pid, int sig);

   Пример: kill (7421, SIGTERM).

   Процесс может посылать сигналы самому себе.

   Получение своего PID - pid=getpid();

   Получение своего PPID - ppid=getppid();

   Ограничения: EUID или RID процесса, посылающего сигнал, должны
   совпадать с EUID и RID процесса-адресата. Для администратора таких
   ограничений нет.

   При неудачном вызове kill возвращает -1 и переменной errno
   присваивается значения: EPERM (нельзя послать чужому процессу), ESRCH
   (такого процесса нет) , EINVAL (sig содержит неверный номер сигнала).

   Смысл параметра PID:

   Pid==0 - сигнал посылается всем процессам группы, к которой
   принадлежит процесс, пославший сигнал;

   Pid==-1 и если EUID не администратора, то посылается всем процессам,
   RID которых равен EUID посылающего процесса, включая и его (если его
   RID=EUID);

   Pid==-1 и EUID администратора, то сигнал посылается всем процессам,
   кроме некоторых системных;

   Pid<0 и не равен -1 - посылается всем процессам, идентификатор группы
   которых равен по модулю PID, включая пославший процесс, если он также
   входит в эту группу.

   Посылка самому себе:

   #include<signal.h>

   int raise (int sig) - вызывающему процессу посылается сигнал. В случае
   успеха возвращает 0. Например, raise (SIGKILL).

   setitimer - установка разных таймеров (3 вида).

   #include<unistd.h>

   unsigned int alarm (unsigned int secs);

   secs - время в секундах, на которое устанавливается таймер. После
   истечения времени процессу посылается SIGALRM.

   Пример: alarm(60).

   Выключение таймера alarm(0).

   Вызов таймера не накапливается. Вызов следующего отменяет предыдущий.

   #include<unistd.h>

   int pause (void) - приостанавливает выполнение процесса до получения
   любого сигнала, часто используется вместе с alarm.

                     Нормальное и аварийное завершение.

   Большинство сигналов вызывают нормальное завершение (normal
   termination). Похоже на вызов процессом функции exit.

   Некоторые сигналы ( SIGABRT, SIGBUS, SIGQUIT, SIGILL и другие)
   инициируют аварийное завершение со сбросом значения переменных,
   регистров и т.д. в core (dump).

                       Имена сигналов (по алфавиту).

   <signal.h>

   SIGABRT - прерывание процесса (abort), посылается процессу при вызове
   системного вызова abort. Core dump.

   SIGALRM - сигнал таймера.

   SIGBUS - аппаратная ошибка на шине. Аварийное завершение.

   SIGCHLD - останов или завершение дочернего процесса. Игнорируется.

   SIGCONT - продолжение работы остановленного процесса (обратный для
   SIGSTOP).

   SIGHUP - освобождение линии, посылается процессам, подключенным к
   терминальной линии, при отключении терминала или при завершении работы
   лидера сеанса членам группы.

   SIGILL - недопустимая команда процессора. Core dump.

   SIGINT - нормальное прерывание программы (Сtrl+C). Посылается всем
   процессам сеанса.

   SIGKILL - немедленное уничтожение процесса. Не перехватывается.

   SIGPIPE - попытка записи в канал или сокет, для которого принимающий
   процесс уже завершил работу.

   SIGPROF - сигнал профилирующего таймера.

   SIGQUIT - завершение программы. Похож на SIGINT, но завершение
   аварийное.

   SIGSEGV - некорректный адрес памяти. Аварийный сброс.

   SIGSTOP - сигнал останова. Управление заданиями. Нельзя перехватить.

   SIGSYS - ошибочный системный вызов.

   SIGTERM - программный сигнал завершения. Используется для корректного
   завершения процесса.

   SIGTSTP - терминальный сигнал остановки (Сtrl+Z). Похож на SIGSTOP, но
   можно перехватить.

   SIGTTIN - попытка ввода с терминала фоновым процессом. Остановка
   процесса.

   SIGTTOU - попытка вывода на терминал фоновым процессом. Остановка
   процесса.

   SIGURG - поступление в буфер сокета срочных внеочередных данных.

   0x08 graphic
   0x08 graphic
   SIGUBR1

   SIGUBR2

   SIGVTALRM - виртуальный таймер.

   SIGXCPU - превышение лимита процессорного времени. Core dump.

   SIGXFSZ - превышение лимита на размер файла.

                              Наборы сигналов.

   Набор сигналов - это список сигналов, которые необходимо передать
   системному вызову.

   Тип sigset_t в <signal.h>, его размер позволяет поместиться всем
   сигналам, определенным в системе.

   Выбор сигналов - либо из полного, удаляя ненужные, либо из пустого
   набора, добавляя необходимые.

   Инициализация набора:

   #include <signal.h>

   int sigemptyset(sigset_t *set);

   int sigfillset(sigset_t *set);

   Добавление и удаление сигналов:

   int sigaddset(sigset_t *set, int signo);

   int sigdelset(sigset_t *set, int signo);

   Пример:

   sigset_t mask1, mask2;

   sigemptyset(&mask1);

   sigaddset(&mask1, SIGINT);

   sigaddset(&mask1, SIGQUIT);

   sigfillset(&mask2);

   sigdekset(&mask2, SIGCHLD);

                            Обработчик сигналов.

   После определения списка можно задать обработку сигналов:

   #include<signal.h>

   int sigaction(int signo, const struct sigaction *act, struct sigaction
   *oact);

   signo - сигнал, для которого задается действие.

   act - определяем обработчик.

   oact - если не NULL, то в эту структуру сохранится старый обработчик.

   struct sigaction {

   void (*sa_handler)(int); //функция обработчика

   sigset_t sa_mask; //сигналы, блокируемые во время обработки данного

   int sa_flags; //флаги, влияющие на поведение сигнала

   viod (*sa_sigaction)(int, siginfo_t*, void*);

   };

   Толкование:

   - sa_handler:

    1. SIG_DFL - константа обработки по умолчанию.
    2. SIG_IGN - константа игнорирования. Не может применятся для SIGSTOP
       и SIGKILL.
    3. Адрес функции, принимающей аргумент типа int (sa_handler=f1). Она
       будет вызываться при получении сигнала, а signo передается как
       параметр.

   Управление передается функции из любого места программы, а после
   возврата из нее выполнение будет продолжено с точки, в которой было
   прервано.

     * sa_mask - сигналы из этого набора будут игнорироваться во время
       выполнения функции-обработчика (sa_handler).
     * sa_flags - изменение характера реакции:

    1. SA_RESETHAND - после возврата из обработчика вернуть обработчик по
       умолчанию SIG_DFL.
    2. SA_SIGINFO - обработчику передается дополнительная информация и
       вместо sa_handler используется sa_sigaction.
    3. SA_RESTART - повтор прерванного сигналом системного вызова.

                  Ненадежные сигналы (устаревшая версия).

   #include<signal.h>

   void (*signal(int sig, void(*disp)(int))) (int);

   sig - номер сигнала.

   disp - SIG_DFL, SIG_IGN или функция-обработчик.

   Пример: signal(SIGINT, SIG_IGN);

                           Блокирование сигналов.

   int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

   - how - указывается, какое действие надо выполнить:

    1. SIG_MASK - установить блокирование сигналов по списку;
    2. SIG_UNBLOCK - отмена блокирования сигналов по списку;
    3. SIG_BLOCK - добавление списка к текущим блокируемым.

     * set - набор сигналов.
     * oset - старый набор. Если не равен NULL, то в него заносится
       значение.

   Пример:

   sigset_t set1;

   sigfillset(&set1);

   sigprocmask(SIG_SETMASK, &set1, NULL);

   //критический участок - непрерываемый

   sigprocmask(SIG_UNBLOCK, &set, NULL);

   Примечание: можно варьировать наборы и степень защищенности кода.

                               Пример демона.

   Иллюстрация работы с сигналами и процессами.

   Скелет демона:

   #include<stdio.h>

   #include<signal.h>

   #include<sys/types.h>

   #include<sys/param.h>

   #include<sys/resource.h>

   main(int argc, char** argv)

   {

   int fd;

   struct rlimit flim;

   struct sigaction sa;

   sa.sa_handler = SIG_IGN;

   if (getppid() !=1 )

   {

   sigaction(SIGTTOU, &sa, NULL);

   sigaction(SIGTTIN, &sa, NULL);

   sigaction(SIGTSTP, &sa, NULL);

   if (fork() != 0) exit(0); //завершение родителя

   setsid();

   };

   getrlimit(RLIMIT_NOFILE, &flim);

   for (fd = 0; fd < flim.rlim_max; fd++ ) close(fd); //закрывает все
   файлы

   chdir("/");

   ... //содержательная часть демона

   }

                                System V IPC

   пользовательские. Ядром никогда не посылаются и могут использоваться
   для своих целей.
