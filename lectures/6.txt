
          Лекция No.6. Среда программирования и архитектура UNIX.

   Одной из целей разработчиков UNIX было создание удобной среды
   программирования. Ради простоты и изящества архитектуры пожертвовали
   сиюминутной производительностью, что впоследствии оправдало себя.

   Базой любой UNIX-системы является компилятор Си (сс), библиотека libc
   и ядро.

   Любая версия UNIX предоставляет строго определенный, ограниченный
   набор входов в ядро ОС, через которые прикладные задачи получают
   доступ к базовым услугам UNIX. Эти точки входа называются системными
   вызовами (system calls).

   Системный вызов определяет функцию, выполняемую ядром ОС от имени
   процесса, выполнившего вызов, и является интерфейсом самого низкого
   уровня взаимодействия прикладных процессов с ядром.

   В основу нашего курса положено описание стандарта X/Open System
   Interfaces (XSI), включающего System Interface Definition, System
   Interface and Headers, Networking Services и являющегося частью XPG.

                  Инструментальные средства программиста.

   Это широкий выбор трансляторов для различных языков программирования
   (С/С++, Pascal, Python, Fortran, Perl и т.д.), компиляторы (cc, gcc,
   egcs, bcc), линковщики (ld), отладчики (debug, gdb). Далее будут
   описаны только базовые функции и параметры, общие для всех
   компиляторов.

   На лабораторных будут использоваться gcc (Bsd cc), GNU make, GNU
   binutils (gas, ld, ...).

   Make - стандартное средство, применяемое для сборки программных
   проектов. Является универсальной программой для решения задач
   автоматической генерации и изменения файлов с учетом зависимостей.

   Схема работы: make читает файл с описанием проекта (makefile) и,
   интерпретируя его содержание, выполняет определенные действия.

   Makefile - текстовый файл, описывает отношения между файлами проекта и
   действия, необходимые для его сборки.

                    Формат и использование make-файлов.

   Основной элемент - правила (rules).

   Общий вид:

   <цель 1> <цель 2> ...<цель n>:<зависимость 1> <завис-ть 2>...<завис-ть
   n>

   <команда 1>

   <команда 2>

   ...

   <команда n>

   Цель (target) - некий желаемый результат, способ достижения которого
   описан в правиле. Цель может быть именем файла.

   Пример1: цель как имя файла

   iEdit: main.o Editor.o

   gcc main.o Editor.o -o iEdit

   Пример описывает, как можно получить исполняемый файл из объектных
   модулей.

   Цель может быть именем некоторого действия, тогда правило описывает,
   как совершается указанное действие.

   Пример2: цель как имя действия

   clean:

   rm *.o iEdit

   Такие цели называют абстрактными (phony targets) или псевдоцелями
   (pseudo targets).

   Зависимость (dependency) - это <<исходные данные>>, необходимые для
   достижения указанной в правиле цели. Можно сказать, что
   предварительные условия достижения цели. Зависимостью может быть имя
   файла или имя действия. В примере1 main.o и Editor.o - зависимости.
   Они должны существовать, чтобы можно было собрать iEdit.

   Пример3:

   clean_all: clean_obj

   rm iEdit

   clean_obj:

   rm *.o

   Для достижения сlean_all необходимо выполнить действие (достигнуть
   цель) clean_obj.

   Команда - действия, которые надо выполнить для обновления или
   достижения цели. Перед командой должен быть символ табуляции (код 9).
   Так make определяет команды.

   Пример4: типичный make file, который содержит несколько правил, у
   каждого правила есть некоторая цель и зависимости.

   1. iEdit: main.o Editor.o

   2. gcc main.o Editor.o -o iEdit

   3. main.o: main.cpp

   4. gcc -c main.cpp

   5. Editor.o: Editor.cpp

   6. gcc - Editor.cpp

   7. clean:

   8. rm *.c

   Смысл работы - достижение главной цели (default goal). Если цель - имя
   действия (абстрактная), то выполняется действие. Если главная цель -
   имя файла, то make строит самую свежую версию.

   Главная цель обычно задается как параметр make: make iEdit, make
   clean. Если make вызывается без параметров, то в качестве главной
   берется первая встреченная цель. (В примере это iEdit).

   Алгоритм работы:

    1. выбор главной цели;
    2. достижение цели;
    3. обработка правил;
    4. обработка зависимостей.

   Достижение цели - проверяет зависимости и потом определяет, надо ли
   запускать команды.

   При вызове make iEdit определяет, что главная цель - iEdit. Правило ее
   достижения - строки 1,2. Обрабатывая правило iEdit, определяем, что
   зависит от main.o и Editor.o. Для этих зависимостей существуют правила
   (3,4) и (5,6). main.o зависит от main.cpp. Если нет еще объектного
   файла, но существует файл .срр, то запускается компиляция. Аналогично
   и для Editor.o. Для clean зависимостей нет и make сразу переходит к
   выполнению.

   Инкрементная сборка - перекомпилируется только то, что было изменено.
   Для файлов .с и .срр обычно указываются как зависимости .h файлы.

                              Переменные make.

   Присвоение: имя = строка (можно с пробелами).

   Значение переменной: $(имя). Значение - текстовая строка, может
   содержать ссылки на другие переменные.

   Пример: obj_list = main.o Editor.o - присовение; $(obj_list) -
   получение значения.

    1. dir_list = . .. src/include

   all:

   echo $(dir_list)

    2. optimize_flags = -03

   compile_flags = $(optimize_flags) -pipe

   all:

   echo $(compile_flags)

   Результат: -03 -pipe

    3. program_name = iEdit

   obj_list = main.o Editor.o TextLine.o

   $(program_name) : $(obj_list)

   gcc $(obj_list) -o $(program_name)

   Примечание: значение переменной вычисляется в момент использрвания.

   $(cc) - очень распространенная переменная, так как в системе может
   быть более одного компилятора.

   Автоматические переменные:

   $^ - список зависимостей;

   $@ - имя цели

   Пример:

   $(program_name):$(obj_name)

   gcc $^ -o $@

                             Шаблонные правила.

   Шаблонные правила (implicit или pattern rules) применяются к группе
   файлов.

   Синтаксис:

   .<расширение_файлов_завис.> .<расширение_файлов_целей>:

   <команда 1>

   <команда 2>

   ...

   <команда n>

   Пример:

   .cpp .o:

   gcc -c $^

                            Компилятор Си (сс).

   Вызов: сс исходные_файлы.

   Результатом по умолчанию является файл a.out в текущем каталоге.

   Параметры:

   cс -с файлы - только компиляция (без линковки);

   cс -o выходной входные - получается исполняемый файл с указанным
   именем вместо a.out;

   cc -g - получается файл вместе с отладочной информацией.

   Для gcc стандартный отладчик - gdb.

                               Библиотека Си.

   Системные вызовы определены, как функции языка Си (независимы от
   фактической реализации в ядре). В UNIX каждый системный вызов имеет
   соответствующую функцию (или функции) с тем же именем, хранящуюся в
   стандартной библиотеке Си. Функции из библиотеки выполняют
   преобразования аргументов и вызов соответствующего кода ядра. Таким
   образом, библиотечный код - только оболочка, фактические инструкции
   находятся в ядре.

   Функции общего значения - также часть библиотеки, но не являются
   системными вызовами. Функции общего назначения и системные вызовы -
   основа среды программирования UNIX.

                    Стандартная библиотека ввода/вывода.

   Образует основную часть стандартной библиотеки, поставляемой со всеми
   системами UNIX. Главная цель - предоставление эффективных, развитых и
   переносимых средств доступа к файлам. Эффективность библиотечных
   процедур достигается за счет механизма автоматической буферизации,
   который невидим для пользователя. Этот механизм минимизирует число
   действительных обращений к файлам и число выполняемых низкоуровневых
   вызовов.

   Процедуры стандартной библиотеки ввода/вывода являются переносимыми,
   так как они не привязаны к особым свойствам UNIX, а на самом деле -
   часть стандарта ANSI C.

                              Структура FILE.

   Буферизация ввода/вывода идентифицирует открытые файлы (каналы, сокеты
   и др.) при помощи указателя на структуру типа FILE.

   Указатель на структуру типа FILE называется потоком ввода/вывода.

   Поток ввода/вывода - аналог низкоуровневого дескриптора.

   Тип FILE определен в <stdio.h>.

   Все данные, считываемые или записываемые в файл, передаются через
   буфер структуры FILE. Эти действия прозрачны для пользователя. Буфер
   пишется/считывается с диска по мере наполнения/опустошения (выполняет
   системный вызов).

   Размер буфера - BUFSIZ - константа из stdio.h. Обычно равен размеру
   блока на диске ( 512, 1024, 2048, 4096).

   Механизм буферизации гарантирует, что данные всегда пишутся/читаются
   блоками стандартного размера. Результат этого - оптимальное число
   обращений к файлам на диске и системным вызовам.

   Следствие: проблема общей эффективности решается библиотеками, а
   программист составляет программы, исходя из простоты и читаемости.

   Пример: чтение по одному байту тоже буферизируется и все равно
   эффективно.

   Вывод: для большинства приложений стандартная библиотека ввода/вывода
   является предпочтительным методом доступа к файлам.

                      Основные процедуры (<stdio.h>).

   Подробно их можно изучить по электронному справочнику (man) или по
   книгам по Си.

   1) fopen/fclose - открытие/закрытие потоков

   2) getc/putc (fgetc/fputc) - посимвольный ввод/вывод

   3) ungetc - возврат символа в поток

   4) stdin, stdout, stderr - стандартный ввод, вывод и поток ошибок

   5) ferror, feof, clearer, fileno - опрос состояния (обычно макросы)

   6) gets, fgets, puts, fputs - построчный ввод/вывод

   7) fread, fwrite

   8) fseek, rewind, ftell - используются для поток с произвольным

   доступом к файлам (к ним не относятся терминалы)

   9) printf (fprintf, sprintf) - форматированный вывод

   10) scanf (fscanf, sscanf) - форматированный ввод

   Примечание: рекомендуется fgets+sscanf вместо

   fscanf.

   11) system, popen, pclose - запуск программ (доступ к тому, что

   запущенный процесс выводит на экран)

   12) freopen, fdopen - дополнительные процедуры (связывают новую

   структуру FILE с уже открытым дескриптором)

   13) setbuf (setvbuf) - управление буфером

   14) malloc - работа с динамической памятью

   15) string - работа со строками

                        Форматы исполняемых файлов.

   COFF и ELF - (common object file format) и (executable and linking
   format).

   Исполняемые файлы хранят информацию:

    1. Какие части загружаются в память.
    2. Как создается область для неинициализированных данных.
    3. Какие части должны свопится (при замещении страниц памяти), а
       какие можно снова считать из файла.
    4. Где в памяти находятся инструкции и данные программы.
    5. Какие библиотеки необходимы для выполнения программы.
    6. Как связаны исполняемый файл, область программы и swap.

   Исполняемые образы программ:

   COFF ELF

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   Основные элементы: сегменты кода, данных и стека.

   Сегмент данных - инициализированные данные (копируются из
   соответствующих разделов исполняемого файла) и неинициализированные
   данные (заполняются нулями). Неинициализированные данные - это сегмент
   BSS.

   Размер стека изменяется ОС автоматически. Управление сегментом данных
   осуществляет приложение.

                                    ELF.

   Формат ELF имеет файлы нескольких типов:

    1. перемещаемый файл - хранит инструкции и данные, может быть связан
       (слинкован) с другими такими файлами или с разделяемыми объектными
       файлами с образованием исполняемого файла.
    2. Разделяемый объектный файл (shared object) - также содержит
       инструкции и данные, но может использоваться двумя способами:

    a. при запуске программы на выполнение ОС динамически связывает его с
       исполняемым файлом и создает исполняемый образ (как разделяемая
       библиотека);
    b. связан с другими такими же ил объектными файлами для создания
       нового объектного файла.

    3. исполняемый файл - содержит полное описание, позволяющее системе
       создать образ процесса. Содержит инструкции, данные, описание
       необходимых разделяемых объектных файлов, необходимую символьную и
       отладочную информацию.

                       Структура исполняемого файла:

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic

   Заголовок фиксирован. Остальные части располагаются в соответствии с
   информацией заголовка.

   Заголовок содержит общее описание структуры файла, расположение
   отдельных компонент и их размеры.

   Структура заголовка: тип файла, архитектура аппаратной платформа,
   точка входа, номер версии ELF-формата, размещение таблицы заголовков и
   т.д.

                                   COFF.

   Имеет два основных заголовка: COFF и стандартный заголовок системы
   UNIX a.out.

   Далее заголовки разделов, и после разделы, в которых находятся
   инструкции и данные.

   В файле также содержится информация, необходимая для отладки.

   В файле всегда находятся только инициализированные данные, так как
   неинициализированные заполняются нулями при загрузки программы на
   выполнение.

   Отладочная информация: таблица символов, содержащая идентификаторы, их
   адреса и типы, и таблица символов, куда помещаются имена, если их
   длина больше восьми. Обе таблицы присутствуют и в объетном файле, и в
   исполняемом, если явно не удалены (strip).

   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic

   Заголовок COFF: аппаратная платформа, количество разделов, время и
   дата создания файла, расположение и количество записей в таблице
   символов, размер заголовка a.out, тип файла.

   Заголовок a.out хранит информацию, необходимую ядру при запуске
   программы: номер версии заголовка, размер раздела инструкций, размеры
   разделов инициализированных и неинициализированных данных, точку
   входа, адреса начала сегментов инструкций и данных виртуальной памяти.

   VM

   Разделяемые библиотеки

   Разделяемая память

                                Стек (stack)

                                Куча (heap)

                                Данные(data)

                                 Код(text)

                                Стек(stack)

                                 Код(tetx)

                                Данные(data)

                                 Куча(heap)

                           Динамические сегменты

                                 Заголовок

                            Заголовок сегмента 1

                                    ...

                            Заголовок сегмента n

   Таблица заголовков

                                 Сегмент 1

                                    ...

                                 Сегмент n

                         Таблицы заголовков секций

                               Заголовок COFF

                              Заголовок a.out

                            Заголовок раздела 1

                                    ...

                            Заголовок раздела n

                                  Раздел 1

                                    ...

                                  Раздел n

                              Таблица символов

                               Таблица строк
