
                           Лекция No.5. Процессы.

   Процессы - дно из двух ключевых понятий для пользователя.

   Процесс - это экземпляр выполняющейся программы.

   Программа - совокупность файлов, будь то сырцов, объектных файлов либо
   выполняемый файл.

   Для запуска программы на выполнение ОС должна создать окружение или
   среду выполнения задачи, куда относится ресурсы памяти, возможность
   доступа к устройствам ввода/вывода и различным системным ресурсам.

   Процесс состоит из инструкций, выполняемых процессором, данных и
   информации о выполняемой задаче, такой, как размещенная память,
   открытые файлы и статус процесса.

   Программа может породить более одного процесса. Пользователи могут
   запускать несколько экземпляров одной программы. Например, количество
   BASH - эквивалентно числу пользователей. Таким образом UNIX -
   многозадачная ОС.

   Выполнение процесса заключается в точном следовании набору инструкций,
   который никогда не передает управление набору инструкций другого
   процесса. Процесс взаимодействует со своими данными и стеком, но уме
   не доступны чужие данные и стек.

   Процессы изолированы друг от друга. В то же время, процессы имеют
   возможность обмениваться друг с другом данными с помощью системы
   межпроцессного взаимодействия (IPC).

   Средства IPC:

    1. сигналы
    2. каналы
    3. разделяемая память
    4. семафоры
    5. сообщения
    6. файлы.

                              Типы процессов.

   Системные процессы являются частью ядра и всегда расположены в
   оперативной памяти. Системные процессы не имеют соответствующих им
   программ в виде исполняемых файлов и запускаются особым образом при
   инициализации ядра системы.

   Примеры:

    1. диспетчер свопинга
    2. диспетчер памяти

   и другие.

   Выполняемые инструкции и данные этих процессов находятся в ядре, таким
   образом, они могут обращаться к функциям и данным, не доступным извне
   (ядра).

   Процесс init можно также отнести к системным, хотя он запускается из
   файла. Он прародитель всех процессов системы.

   Демоны - неинтерактивные процессы, запускаемые обычным образом, и
   выполняются в фоновом режиме. Они не связаны не с одним
   пользовательским сеансом и не могут непосредственно управляться
   пользователем. Обеспечивают работу различных подсистем:

     * печати
     * сетевого доступа
     * терминального доступа
     * почта
     * web-сервера
     * СУБД.

   Прикладные процессы - все остальные процессы. Как правило, порождаются
   в рамках пользовательского сеанса.

   Пример: ls, BASH.

   Пользовательские процессы могут выполняться как в интерактивном, так и
   в фоновом режиме, но время из жизни (выполнения) ограничено сеансом
   работы пользователя. При выходе из системы все пользовательские
   процессы будут уничтожены.

   Примечание: интерактивные процессы монопольно владеют терминалом, и,
   пока такой процесс не завершит выполнение, пользователь не может
   работать с другими приложениями. (Кроме случаев, когда есть режим
   запуска других процессов из-под этого интерактивного процесса.)

                            Атрибуты процессов.

   Они позволяют ОС эффективно управлять работой процесса.

    1. идентификатор процесса -Process ID (PID) - каждый процесс имеет
       уникальный идентификатор, позволяющий ядру системы различать
       процессы.

   При создании нового, ядро присваивает ему следующий свободный
   идентификатор. Присвоение PID - по возрастающей, то есть PID нового
   процесса больше, чем PID процесса, созданного перед ним.

   Если PID достиг максимального значения, следующий процесс получит
   минимальный свободный и цикл повторяется.

   Когда процесс завершает работу - ядро освобождает занятый им PID.

    2. идентификатор родительского процеcса -Parent Process ID (PPID) -
       PID процесса, породившего данный.
    3. приоритет процесса (nice number) - относительный приоритет
       процесса, учитываемый планировщиком при определении очередности
       запуска.

   Фактическое распределение ресурсов - приоритет выполнения: динамически
   изменяется ядром во время выполнения. Относительный - постоянен, но
   может изменяться администратором или пользователем с помощью nice.

    4. терминальная линия (TTY) - терминал или псевдотерминал,
       ассоциированный с процессом. Демоны не имеют ассоциированного
       терминала.
    5. реальный (RID) и эффективный (EUID) идентификаторы пользователя.
       RID - идентификатор пользователя, запустившего этот процесс. EUID
       служит для определения прав доступа процессак системным ресурсам.
       (В первую очередь к файловой системе.)

   Обычно RID=EUID, то есть процесс имеет те же права, что и
   пользователь, запустивший его. RID 0x01 graphic
   EUID, когда на программе установлен бит SUID. Тогда EUID=UID, то есть
   процесс получает те же права, что и у владельца исполняемого файла
   (например, администратор).

    6. реальный (RGID) и эффективный (EGID) идентификаторы группы.
       RGID=GID первичной группы пользователя, запустившего процесс. EGID
       служит для определения прав доступа пользователя по классу доступа
       группы. По умолчанию RGID=EGID, кроме SGID, установленного на
       команду, тогда EGID=GID группы-владельца команды.

   Просмотр атрибутов процесса: ps -ef.

                         Жизненный путь процессов.

   Процесс в UNIX создается системным вызовом fork(2).

   Процесс, сделавший вызов fork(2), называется родительским, а вновь
   созданный - дочерним. Новый процесс является точной копией породившего
   его процесса.

   Примечание: новый процесс имеет те же инструкции и данные, что и
   родитель. Более того, выполнение родительского и дочернего начнется с
   одной и той же инструкцией, следующей за системным вызовом fork.
   Единственное их отличие - идентификатор PID.

   Каждый процесс имеет одного родителя, но может иметь несколько
   потомков.

   Для запуска задачи, то есть загрузки новой программы, процесс должен
   сделать вызов exec(). При этом новый процесс не порождается, а
   исполняемый код нового процесса полностью замещается кодом запускаемой
   программы. Тем не менее сохраняются значения переменных окружения,
   назначение стандартных потоков ввода/вывода и ошибок, а также
   приоритет процесса.

   В UNIX запуск на выполнение новой программы часто связан с порождением
   нового процесса. Таким образом, процесс сначала выполняет fork,
   порождая дочерний процесс, который затем выполняет exec, полностью
   замещая родительский процесс.

   Процедура запуска, показанная на рис.1, называется fork-and-exec.
   Бывают ситуации, когда достаточно одного вызова fork без последующего
   exec. В этом случае исполняемый код родительского и дочернего
   процессов должен содержать логическое ветвление для родительского и
   дочернего процессов. (fork возвращает PID порожденного процесса в
   родительский и ноль - в дочерний.)

   Все процессы создаются через вызов fork. Запуск осуществляется либо по
   fork-and-exec, либо с помощью exec.

   Прародителем всех процессов является init или распределитель
   процессов.

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   Рис. 1.

                                  Сигналы.

   Сигналы является способом передачи от одного процесса другому или от
   ядра ОС какому-либо процессу уведомления о возникновении какого-либо
   события.

   Сигналы - простейшая форма IPC. Они напоминают прерывания. Только в
   случае сигналов нормальный ход выполнения может быть прерван.

   Пример:

    1. при делении на ноль процессу посылается сигнал SIGFPE;
    2. при нажатии Ctrl+C на терминале текущему процессу посылается
       сигнал SIGINT.

   Для отправки сигналов используется команда:

   kill sig_no pid

   sig - номер или символьное название сигнала;

   pid - идентификатор процесса, которому посылается сигнал.

   Пользователь может посылать сигналы только тем процессам, владельцем
   которых он является, то есть RID и EUID совпадают с UID пользователя.
   Администратор может посылать сигналы всем процессам.

   Пример: посылка сигнала процессу, только что запущенному в фоновом
   режиме

   back_fone_prog &

   kill $! (по умолчанию посылается SIGTERM, номер 15).

   При получении сигнала процесс может реагировать следующим образом:

    1. игнорировать сигнал.

   Замечание: не следует игнорировать аппаратно вызванные сигналы,
   например, SIGFPE.

    2. действовать по умолчанию. Обычно это завершение работы.
    3. перехватить сигнал и самостоятельно обработать его. Например,
       перехват SIGINT позволит удалить все tmp-файлы и корректно
       завершить выполнение.

   Примечание: SIGKILL (9) и SIGSTOP(23) нельзя ни перехватить, ни
   игнорировать.

   Kill -9 PID - посылка SIGKILL.

   Возможны ситуации, когда процесс не реагирует и не исчезает:

    1. процессы-зомби. Фактически он завершился, но осталась запись в
       системной таблице процессов. В этой ситуации действует только
       перезагрузка.
    2. процессы, ожидающие недоступные ресурсы NFS. Например, процессы
       пишущие данные в файл удаленного компьютера, который уже
       отключился. Проблему решают посылкой SIGINT или SIGQUIT.
    3. процесс, ожидающий завершения операции с устройством, например,
       перемотка ленты или перепозиционирование головки CD-ROM на
       порченном диске.

   Сигналы используются не только для завершения работы процессов, но и
   могут иметь специфическое значение для приложения. (Это не относится к
   SIGKILL и SIGSTOP, потому что их нельзя перехватить.)

   Пример: системные демоны - proxy servers, smtp (pop, imap), СУБД, bind
   при получении сигнала SIGHUP должны перечитать свои конфигурационные
   файлы.

   sh

   PID=745

   PPID=1

   sh

   PID=802

   PPID=745

   ls

   PID=02

   PPID=745

   sh

   PID=745

   PPID=1

   /usr/bin/ls

   fork()

   exec()

   exit()

   wait()
