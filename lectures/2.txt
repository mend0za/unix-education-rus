
                              Лекция 2. BASH.

   Оболочки (командные интерпретаторы, процессоры, shell's) представляют
   собой промежуточные уровни между пользователем и ОС. Они анализируют
   командную строку, выполняют преобразования аргументов команд, находя и
   интерпретируя команды.

   Shell - это обычная прикладная программа. Она не является частью ядра,
   и поэтому может быть заменена на любую другую, например, на любую
   игрушку.

   Виды shell: sh, csh, ksh, zsh, tcsh, ash и другие.

   В курсе углубленно будет рассматриваться bourne shell как
   функциональное подмножество bash, объединяющее возможности
   предшественников.

   Сценарий (скрипт) командного процессора представляет собой текстовый
   файл, который указывает оболочке на выполнение заданной
   последовательности действий. Сценарий может содержать любую
   последовательность команд (как внутренних команд оболочки, так и
   внешних команд UNIX, с аргументами или без них), вызовов программ или
   других написанных ранее сценариев.

   Возможности BASH:

    1. переменные - определяемые пользователем и нет;
    2. перенаправление ввода/вывода;
    3. функции - встроенные, определяемые пользователем и внешние
       программы и утилиты;
    4. запуск команд - обычный, условный и фоновый;
    5. условные выражения;
    6. циклы;
    7. целочисленная арифметика;
    8. развитые средства работы с файлами и строками;
    9. обработка сигналов.

   Принципиально работа пользователя в командной сроке ничем не
   отличается от выполнения длинного, часто бестолкового скрипта.

   Механизм работы скрипта: при запуске скрипта из командной строки
   запускается копия интерпретатора, для которого стандартным вводом
   служит скрипт.

   Способы запуска: по имени, .имя (в этом случае порождается новый
   процесс), bash < имя, bash имя.

                            Структура скриптов.

   # - то, что следует за ним, является комментарием. Комментарии могут
   занимать всю строку или следовать за командой.

   \ - обозначает, что строка продолжится на следующей строке файла.

                                Переменные.

   Значение переменной - строка, которая передается присваиванием.

   V1 = 5; v2 = "string";

   V3 = `pwd` - переменной можно присваивать значение, которое

   возвращается командой.

   Получение значения:

    1. $имя_переменной;
    2. $(имя_переменной) - отделяем команду от последующих символов

   Пример: echo $(v1)2 - результат: 52;

    3. $(имя:-строка) - возвращает значение переменной либо строку, если
       переменная не определена;
    4. $(имя:=строка) - возвращает значение переменной либо, если
       переменная не определена, ей присвоится строка;
    5. $(имя:?строка) - если переменная не определена, то выводится
       строка и скрипт прекращает работу;
    6. $(имя:+строка) - возвращает строку, если переменная определена.

   В UNIX существует ряд предопределенных переменных:

    a. HOME - домашний каталог пользователя
    b. PATH - путь поиска исполняемых программ (по умолчанию поиск в
       текущем каталоге не производится, его надо задавать явно:
       ./script)
    c. MAIL - полное имя каталога (файла) с почтой
    d. TERM - тип терминала (ansi, vt100, vt220)
    e. PS1,PS2- первичное и вторичное приглашение shell.

   В shell существует ряд переменных, которые определяются

   интерпретатором по ходу выполнения скриптов. Это так называемые
   встроенные переменные:

    a. $0, $1, $2,...,$9 - значения параметров, передаваемых скрипту из
       командной строки. $0 - имя самого скрипта.

   Примечание: хороший стиль программирования - выдавать имя скрипта по
   $0 в выдаваемом скриптом сообщении.

    b. $# - число параметров, переданных скрипту;
    c. $@ - все параметры, переданные скрипту. Представляют собой
       отдельные слова, заключенные в кавычки.
    d. $* - все параметры, переданные скрипту. Представляют собой единое
       слово, заключенное в кавычки.
    e. $? - код возврата последнего выполненного процесса;
    f. $$ - PID текущей копии shell;
    g. $! - PID последнего процесса, запущенного в фоновом режиме.

   Замечание: код возврата равен 0, если команда успешно завершилась, и
   равен ненулевому значению, если произошла ошибка. В shell "true" и
   "false" имеют обратные значения по сравнению с Си.

   Пример: if [$? -ne 0]; then ; echo Error; fi

   Существуют три вида кавычек при присваивании переменных: ", `, `.
   Кавычки одного вида экранируют другие.

    a. ` - непосредственная подстановка, например: v4='$v1' присвоит $v1,
       а не 5.
    b. " - подстановка после интерпретации символов "\" и "$". Например:
       v5="$v1". Переменной v5 присвоится 5.

   Записи без подстановочных символов эквивалентны. Так, например:

   v6=string

   v6="string"

   v6='string'

   дадут одинаковый результат.

   Встроенная переменная $@ представляет собой отдельные заключенные с
   кавычки слова: "пар1" "пар2" "пар3", - а в переменной $* все аргументы
   представляют собой одно слово, но так как они разделены пробелами, то
   заключены в кавычки: "пар1 пар2 пар3".

    c. ` - выполнение команды внутри скобок.

   По умолчанию все переменные локальны, то есть существуют, пока
   выполняется скрипт. Чтобы сделать их глобальными (для данного shell),
   надо задать их при помощи export, например: export v1.

   При выводе неопределенных переменных результатом будет пустая строка.

   Для удаления переменной используется unset имя_переменной (можно
   несколько переменных).

   Команда set выводит список всех переменных shell.

                       Перенаправление ввода/вывода.

   Каждая программы, запущенная из shell, получает три открытых потока
   ввода/вывода ( в Си описываются файловыми дескрипторами), по умолчанию
   ассоциируются с терминалом. Задаются дескрипторами, по которым к ним
   можно обращаться:

   0 - стандартный поток ввода, ассоциируется с клавиатурой;

   1 - стандартный поток вывода, ассоциируется с экраном;

   2 - стандартный поток ошибок, ассоциируется с экраном.

   Большое количество утилит используют только стандартные потоки,
   поэтому для этих утилит можно осуществлять их перенаправление.

   Синтаксис:

   >file - поток вывода перенаправляется в файл. Пример: cat file1>file2.

   >>file - данные из потока вывода добавляются в файл.

   <file - получение данных для стандартного ввода из файла.

   p1|p2 - передача вывода р1 на ввод р2. Пример: cat spisok | wc -l.
   Реализует конвейер или неименованный программный канал.

   n>file - переключение потока с дескриптором n в файл.

   n>>file - переключение потока с дескриптором n в файл, но данные
   добавляются в конец файла.

   n>$m - слияние потоков с дескрипторами n и m.

   <<str - "Ввод здесь". Использует стандартный поток ввода до появления
   строки str во вводе.

   <<\str - "Ввод здесь". Использует стандартный поток ввода до появления
   строки str во вводе, но при этом метаподстановки shell не
   производятся.

   Пример:

    1. ls -a -l | wc 1>$2 1>>wc.out
    2. run 2>/dev/null - подавление вывода ошибок.

                     Подстановочные символы (шаблоны).

   * - задает любую строку, состоящую из 0 или более символов в имени
   файла.

   ? - задает любой один символ в имени файла.

   [символы] - задает любой символ из диапазона.

   /c - задает с буквально, если с - это спецсимвол.

   Примеры:

    1. [a-c1-3] эквивалентно [abc123] .
    2. ls x*y
    3. ls [xy]*? .

                        Условное выполнение команд.

   p1&&p2 - выполняется р1, если удачно (код возврата 0), то запускается
   р2

   p1||p2 - выполняется р1, если неудачно (код возврата не 0), то
   запускается

   р2

   p1& - р1 выполняется в фоновом режиме, то есть асинхронно, и shell не

   ждет окончания работы р1

   (p1;p2;...) - команды выполняются последовательно в порожденной shell

   {p1;p2;...} - команды выполняются последовательно в текущей shell.

   Примеры: 

    1. (ps; who) | more
    2. mount | wc -l > number.of.partitions &

   Примечание: процессы в фоновом режиме не могут использовать
   стандартный ввод и вывод, поэтому их надо перенаправлять. Поток ошибок
   работает без изменений.

                            Условные выражения.

   if условие if условие if условие

   the n ... then ... then ...

   else ... fi elif условие

   fi then ...

   fi

   Условные выражения можно записывать в строчку, разделяя ";".

   Условием может быть результат команды. Часто используется test с
   параметрами. Файловые параметры:

   test -s файл - является ли размер файла отличным от 0

   test -r файл - доступен ли файл для чтения

   test -w файл - доступен ли файл для записи

   test -x файл - доступен ли файл для выполнения

   test -f файл - существует ли файл и является ли он обычным

   test -d файл - существует ли файл и является ли он каталогом

   test -c файл - существует ли файл и является ли он файлом символьного
   устройства

   test -b файл - существует ли файл и является ли он файлом блочного

   устройства

   test -p файл - существует ли файл и является ли он поименованным
   каналом

   test -u файл - установлен ли бит SUID

   test -g файл - установлен ли бит SGID

   test -k файл - установлен ли sticky bit

   Можно использовать эквивалентные записи без test.

   Пример: следующие записи эквивалентны:

    1. if test -f $HOME/file.txt

   then

   echo "Он есть!"

   fi

    2. if [ -f $HOME/file.txt]

   then

   echo "Он есть!"

   fi

   3) test -f $HOME/file.txt && echo "Он есть!"

   Сравнение строк:

   строка1 = строка2 - проверка на равенство

   строка1 != строка2 - проверка на равенство с выполнением заданных
   действий

   -n "$переменная" - true, если строка имеет ненулевую длину

   -z "$переменная" - true, если строка имеет нулевую длину

   Примеры:

    1. if [ "$v1" = "abc" ]; then; echo "Потрясающе!"
    2. if [ -n "$empty" ]; then; echo "Действительно"

   Сравнение чисел: аргументами являются "$x" или число

   "$x" -eq "$y" - true, если аргументы равны

   "$x" -ne "$y" - true, если аргументы не равны

   "$x" -gt "$y" - true, если значение x больше значения y

   "$x" -ge "$y" - true, если значение x больше либо равно значению y

   "$x" -lt "$y" - true, если значение x меньше значения y

   "$x" -le "$y" - true, если значение x меньше либо равно значению y

   Пример: if [ "$#" -eq 2 ]; then; echo "2 аргумента"

   Сложные выражения:

   !выражение - отрицание

   выражение1 -a выражение2 - логическое "И"

   выражение1 -o выражение2 - логическое "ИЛИ"

   Пример:

    1. if [ !\( $x -eq $y\) ]
    2. if [ "$a" -ne 3 -a "$b" -lt "$c ]
    3. if [ "$x" = "$y" -a \( "$n" -lt 0 -o "$m -gt 30\) ]

   Примечание: Скобки экранируются, так как они имеют специальный смысл
   для команд (последовательное выполнение в новом экземпляре shell).

                                   Циклы.

   1) while условие 2) until условие 3) for var in список

   do ... do ... do ...

   done done done

   Цикл while выполняется, пока условие не станет ложным.

   Цикл until выполняется, пока условие не станет истинным.

   Цикл for выполниться столько раз, сколько слов в списке. var
   последовательно принимает значения из списка. Список может
   формироваться вручную, как вывод команды (`команда`) или с помощью
   шаблонов.

   Примеры:

    1. while sleep 60

   do

   who | grep mary

   done

    2. until who | grep mary

   do

   sleep 60

   done

   grep выдает код возврата, показывает, удалось ли найти что-то.

    3. for user in `who`

   do

   echo "и этот $user здесь!"

   done

    4. for i in * ; do echo $i; done - эквивалент ls

                                 Селекторы.

   case слово in

   шаблон 1)

   ...

   ;;

   шаблон 2)

   ...

   ;;

   ...

   *) - секция, аналогичная default-секции в Си

   ...

   ;;

   esac

   Слово сравнивается с шаблонами, начиная с первого. В шаблонах могут
   использоваться метасимволы (шаблоны).

   Пример: перебор параметров командной строки, в том числе и флагов

   while [ "$1" != "" ]

   do

   case "$1" in

   -i) INPUT = $2; shift;;

   -o) OUTPUT = $2; shift;;

   -[0-9]) VERSION = $1;;

   -*) echo "unknown argument $1" 1>&2; exit;;

   stop) halt;;

   *) echo "$0: unknown parameter $1" 1>&2; exit;;

   esac

   done

                                  Функции.

   Определение функции пользователя:

   имя_функции ()

   {

   команды

   }

   Синтаксис и передача аргументов как у скрипта.

   Пример: отображает в приглашении имя каталога

   mcd ()

   {

   cd $*

   PS1 = `pwd`

   }

   Запуск встроенной команды не требует порождения нового процесса, так
   как она является частью shell.

   Встроенные команды: (в [] указываются необязательные параметры)

    1. : nop

    i. Пример: while : ; do; wait 60; done



   . имя команды - текущий shell выполнит команду из файла



   break [n] - выход из n вложенных циклов



   cd [dir] - переход в каталог dir



   echo [string] - вывод строки в поток вывода с дескриптором 1



   exec program - выполняет программу, замещая ей shell

   Пример: exec ls из командной строки вызовет logout после вывода списка
   файлов

    7. exit [n] - выходс кодом возврата
    8. export [name1, name2, ...] - помещает переменные в окружение
       текущего shell
    9. hash [-r] [cmd1, cmd2, ...] - для каждой из команд запоминает
       полный путь. При следующих вызовах этих команд поиск не
       производится. При вызове с параметром -r удаляет все запомненные
       пути. При вызове без параметров выводится информация обо всех
       запомненных путях.
   10. jobs - если командный интерпретатор поддерживает управление
       заданиями. То выводится список всех текущих заданий.
   11. pwd - выводит имя текущего каталога
   12. read [var1, var2] - считывает из потока с дескриптором 0 в var1 и
       var2 слова. Если слов больше, чем переменных, то в последнюю
       заносится вся оставшаяся строка.
   13. return [n] - выход из функции с кодом возврата n
   14. set - выводит список определенных переменных
   15. shift [n] - сдвиг параметров командной строки, хранящихся в $1, $2
       и т.д. на n позиций (по умолчанию на 1).
   16. test - вычисление условного выражения
   17. times - суммарное время использования процессора программами,
       запущенными из данного shell.
   18. trap cmd sig1, sig2, ... - определяет команду, которая выполнится
       при получении указанных сигналов.
   19. ulimit - выводит или устанавливает системные ограничения.
   20. umask nnn - устанавливает маску прав доступа для создаваемых
       файлов.
   21. unset var1 var2 - удаляет указанные переменные из списка
       определенных переменных shell.
   22. wait pid - ожидает окончания работы процесса с указанным pid и
       возвращает его код возврата.

                    Выполнение арифметических операций.

   Выполняется только целочисленная арифметика.

   еxpr строка - преобразует строку в число. Например: expr "23".

   Выполняются операции: +, -, *, /, % (деление по модулю). Их приоритет
   обычный.

   Примеры: 

    1. a = `expr $a + 3`
    2. b = `expr 2 \* 3` - символ "\" отменяет специальное значение "*".

   Примечание: числа и операции разделяются пробелами.

                      Обработка сигналов (прерываний).

   Сигналы посылаются программе при возникновении определенных событий
   системой или вручную с помощью команды kill.

   Сигналы:

   0 - выход из shell

   1 - отбой (отключение от сети)

   2 - прерывание выполнения процесса (при нажатии ctrl+c)

   9 - безусловное завершение программы (нельзя перехватить)

   15 - окончание выполнения

   Пример: trap `послать команду' список_номеров_сигналов

   trap `rm -f *.tmp; exit 1' 1 2 15

   14
