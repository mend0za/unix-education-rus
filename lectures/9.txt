
                      Лекция No.9. IPC. Каналы и FIFO.

                                  Каналы.

   Программный канал (или просто канал) служит для установления
   односторонней связи, соединяющий один процесс с другим.

   Каналы доступны даже с уровня shell. Они очень характерны для UNIX.

   Пример: who | wc -l

                            Создание и закрытие:

   #include<unistd.h>

   int pipe(int filedes[2]);

   filedes - массив файловых дескрипторов из двух целых чисел: filedes[0]
   - дескриптор для чтения из канала, а filedes[1] - для записи в канал.

   Возвращает значение -1, если произошла ошибка открытия.

   int close(filedes);

   Возвращает 0 в случае успеха. Обычно не закрывают.

          Чтение/запись через низкоуровневый файловый ввод/вывод.

   #include<unistd.h>

   ssize_t read(int filedes, void* buffer, size_t n);

   ssize_t write(int filedes, const void* buffer, size_t n);

   filedes - файловый дескриптор;

   buffer - указатель на массив или структуру, в/из которую копируются
   данные;

   n - количество байт, которые нужно прочитать/записать;

   ssize_t - количество реально прочитанных/записанных байт.

   0x08 graphic
   Пример:

   0x08 graphic
   0x08 graphic

   0x08 graphic
   
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   
   #include<unistd.h>

   #include<stdio.h>

   main()

   {

   const int MSGSIZE 16

   char* msg "Hello world #0";

   char inbuf[MSGSIZE];

   int p[2], j;

   pid_t pid;

   if (pipe(p) == -1) exit(1);

   0x08 graphic
   0x08 graphic
   if (pid=fork())

   {

   close(p[0]);

   write(p[1], msg, MSGSIZE);

   break;

   }

   0x08 graphic
   0x08 graphic
   else

   {

   close(p[1]);

   read(p[0], inbuf, MSGSIZE);

   printf("%s\n", inbuf);

   wait(NULL);

   };

   exit(0);

   }

   Замечание: при вызове fork() дескрипторы наследуются дочерними
   процессами от родителя, поэтому каналы используются для связи только
   между родственными процессами.

   Минимальный размер буфера по POSIX - 512 байт. Верхнего предела нет,
   то есть буфер может быть бесконечного размера. Для небанальных
   применений важно знать максимальный размер буфера для канала.

                   Связь чтения/записи с размером канала.

   Если write вызывается для канала, в котором есть место, то данные
   посылаются и немедленно происходит возврат.

   Если при write возникает переполнение, то обычно он ждет до тех пор,
   пока не освободится место.

   Если write пишет больше байт, чем поместиться даже в пустой канал, то
   записывается максимальное число данных, а затем останавливается до
   освобождения места для дальнейшей записи.

   Обычно write пишет неделимыми порциями (атомарно), и данные передаются
   за одну непрерывную операцию. Но при большом объеме данных запись
   происходит поэтапно.

   Следствие: если несколько процессов пишут в канал, то могут быть
   беспорядочно перепутаны.

   При read проверяется, пустой ли канал. Если он пуст, то read
   блокируется до тех пор, пока в канале не появятся данные. Если данные
   есть, происходит возврат из read, даже если было прочитано меньше
   данных, чем требовалось.

                             Закрытие каналов.

   2 случая:

    1. дескриптор на запись:

   если существуют другие процессы, в которых канал открыт на запись, то
   ничего не происходит. Если таких процессов не существует, и канал при
   этом пуст, то любой читатель получит нулевой блок данных.

   Приостановленные и ожидающие процессы продолжат работу и выйдут из
   read с нулевым значением.

    2. дескриптор на чтение:

   если есть другие читатели, то ничего не происходит. Если читателей
   больше нет, то посылается сигнал SIGPIPE всем процессам, ожидающим
   записи в канал. Если процесс не перехватывает его, то он прекращает
   свою работу, если же этот сигналом процессом обрабатывается, то после
   обработчика write вернет значение -1 и переменной errno будет
   присвоено значение EPIPE.

                     Запись и чтение без блокирования.

   При использовании read и write иногда может возникнуть блокирование,
   которое может быть нежелательно. Например, для процедуры обработки
   ошибки или опроса нескольких каналов до тех пор, пока в одном из них
   не появятся данные.

   Существует два подхода: fstat и fcntl. Второй лучше.

   1) fstat - в одном из возвращаемых полей сообщается текущее количество
   символов в канале, но это может измениться мгновенно.

    2. системный вызов fcntl - введен для управления уже открытыми

   файлами, может выполнять разные функции.

   #include<sys/types.h>

   #include<unistd.h>

   #include<fcntl.h>

   int fcntl(int filedes, int cmd, ...);

   filedes - файловый дескриптор;

   cmd - выполняемая функция (задается из набора в файле <fcntl.h>);

   тип третьего параметра жестко не определен и зависит от cmd.

   Пример: снятие блокировки

   fcntl(filedes, F_SETFL, O_NONBLOCK);

                           Использование select.

   Этот системный вызов используется для работы с множеством каналов
   одновременно. Используется также для обычных файлов, терминалов, FIFO
   и сокетов.

   Пример: серверный процесс с множеством клиентов (дочерних). Он должен
   справиться с ситуацией, когда одновременно в нескольких в каналах есть
   информация, ждущая обработки, или ждать ее появления. Если информация
   поступает сразу в несколько каналов, то сервер должен знать обо всех
   таких каналах для обработки в правильном порядке (например, по
   приоритетам).

   Синтаксис:

   #include<sys/time.h>

   int select (int nfds, fd_set* readfds, fd_set* writefds, fd_set*
   errorfds, struct timeval * timeout);

   Параметры:

   nfds - фаловых дескриптров, которые представляют интерес для сервера.
   Например, если 0,1,2 - стандартные и открыты еще два файла с
   дескрипторами 3 и 4, то nfds=5. Этот параметр можно задать самому или
   взять константу FD_SETSIZE из <sys/time.h>. Она равна максимальному
   числу дескрипторов, которые может использовать select.

   readfds, writefds, errorfds - указатели на битовые маски, в которых
   каждый бит соответствует файловому дескриптору. Если бит включен, то
   это означает интерес select к этому дескриптору. Очень напоминают
   наборы сигналов.

   readfds - дескриптор, для которого сервер ожидает возможность записи;

   writefds - дескриптор, для которого сервер ожидает возможность чтения;

   errordfds - дескриптор, для которого сервер ожидает возможность
   появления ошибки или исключительной ситуации (например, внеочередные
   данные по сети).

   Существует абстрактный тип fd_set и макросы (или функции, в
   зависимости от реализации) для работы с масками.

   timeout - указатель на структуру timeval:

   #include<sys/time.h>

   struct timeval {

   long tv_sec; //секунды

   long tv_usec; //микросекунды

   };

    1. если указатель timeval равен NULL, то select будет заблокирован до
       появления интересующего события;
    2. если поля структуры нулевые, то select немедленно завершиться;
    3. если поля ненулевые, то возврат произойдет через заданное
       количество секунд и микросекунд.

   Макросы для работы с fd_set:

   #include<sys/time.h>

   void FD_ZERO (fd_set* fdset); - инициализация битовой маски

   void FD_SET (int fd, fd_set* fdset); - установка бита дескриптора

   void FD_IZSET (int fd, fd_set* fdset); - проверка, установлен ли бит

   void FD_CLR (int fd, fd_set* fdset); - сбросит бит дескриптора в маске

   select возвращает:

   -1 в случае ошибки;

   0, если истек временной интервал;

   целое - количество интересующих дескрипторов.

   Последствия: при возврате переустанавливает битовые маски readfds,
   writefds, errorfds и помещает туда же информацию о текущем состоянии
   файлового дескриптора. В некоторых реализациях изменяется также и
   величина timeout, так что эти параметры желательно где-то сохранять.

   Пример: на два дескриптора (не pipe)

   #include<sys/types.h>

   #include<unistd.h>

   #include<fcntl.h>

   int fd1, fd2, fd3;

   fdset readset;

   fd1 = open("file1", O_RDONLY);

   fd2 = open("file2", O_RDONLY);

   FD_ZERO(&readset);

   FD_SET(fd1, &readset);

   FD_SET(fd2, &readset);

   int res = select (5, &readset, NULL, NULL, NULL);

   if (res > 0)

   {

   if FD_ISSET(fd1, &readset) printf("читаем fd1");

   if FD_ISSET(fd2, &readset) printf("читаем fd2");

   };

                        Каналы и exec (толкование).

   who | wc -l

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

                         FIFO (именованные каналы).

   В отличие от обычны - постоянны и им имя присвоено имя файловой
   системы UNIX. FIFO имеет размер, владельца, права доступа.
   Открывается, закрывается, удаляется, как обычный файл.

   read и write ведут себя как и для неименованных каналов.

   В shell для создания канала: mknod channel p, где channel - любое имя
   файловой системы, р - признак канала (mknod используется и для
   dev-файлов).

   Размер файла равен количеству данных, лежащих на данный момент в FIFO.

   Пример:

   а) eat < channel & #на фоне, так как если в канале нет данных, то
   программа ждет их поступления

   б) ls -l > channel; wait #вывод в канал и ожидание, пока отработает
   cat

   Для создания FIFO в Си:

   #include<sys/types.h>

   #include<sys/stat.h>

   int mkfifo (const char* pathname, mode_t mode);

   mode - права доступа, на которые потом приложат umask и присвоят
   результат каналу.

   Пример:

   mkfifo ("/tmp/fifo", 0644);

   int fd = open ("/tmp/fifo", O_RDONLY);

   int fd = open ("/tmp/fifo", O_RDONLY | O_NONBLOCK); - неблокируемый

   В остальном FIFO похожи на неименованные каналы.

   межпроцессный

   дочерний

                                  write()

                                   read()

   родительский

   p[1]

   p[0]

   Дочерний процесс закрывает дескриптор на чтение и пишет сообщение.

   Родительский процесс закрывает дескриптор на запись и читает сообщение
   из буфера.

   sh

                                     sh

                                   fd[0]

                                   fd[1]

                                     sh

                                   fd[0]

                                   fd[1]

   fork()

   fork()

   exec()

                                    who

                                   fd[0]

                                   fd[1]

                                   exec()

                                   pipe()

                                     wc

                                   fd[0]

                                   fd[1]

   wc

   fd[0]

   pipe()

   who

   fd[1]
