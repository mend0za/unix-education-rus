
               Лекция No.7. Подсистема управления процессами.

   Процессы неразрывно связаны с двумя важнейшими ресурсами: CPU и
   оперативной памятью.

   Рассмотрим состояния и переключение контекста.

                       Основы управления процессами.

   Процесс представляет собой исполняемый образ программы, включающий
   отображение в памяти исполняемого файла, полученного в результате
   компиляции, стек, код и данные библиотек, а также ряд структур данных
   ядра, необходимых для выполнения программы.

   ОС обеспечивает иллюзию одновременного выполнения нескольких
   процессов, эффективно распределяя системные ресурсы между активными
   процессами и не позволяя ни одному из них монополизировать
   использование этих ресурсов.

   Истинная многозадачность реализована в UNIX, начиная с 1973 года.

   Выполнение процесса осуществляется в двух режимах: режиме ядра (kernel
   mode) и режиме задачи (user mode).

   В режиме задачи процесс выполняет инструкции прикладной программы,
   допустимые на непривилегированном уровне защиты процесса. При этом
   процессу недоступны системные структуры данных.

   В режиме ядра выполняются системные вызовы, сделанные процессом.
   Несмотря на то, что выполняются структуры ядра, это происходит от
   имени процесса.

   Ядро системы защищает собственное адресное пространство от доступа
   прикладного процесса, который может нарушить целостность структуры
   ядра и привести к разрушению ОС.

   Примечание: часть процессорных инструкций (например, изменение
   регистров, связанных с управлением памятью) могут выполнятся только в
   режиме ядра.

   Образ процесса состоит из двух частей: данных режима ядра и режима
   задачи (Рис.1).

   Образ процесса в режиме задачи состоит из сегментов кода, данных,
   стека и других структур данных, к которым он может получить
   непосредственный доступ.

   Образ процесса в режиме ядра состоит из структур данных, которые
   используются ядром для управления процессом. К ним относятся,
   например, состояние регистров, таблицы отображения памяти.

   Замечание: в режиме ядра процесс имеет доступ к любой области памяти.

   Любой процесс представлен в системе двумя основными структурами
   данных: proc и user (<sys/proc.h> и <sys/user.h>). Их содержимое
   различно для разных систем. Например, proc может содержать состояние
   процесса, текущий приоритет, UID, EUID, список областей памяти, код
   возврата, время выполнения и т.д.

   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   Рис.1. Инфраструктура процесса.

   В любой момент времени данные структуры proc для всех процессов должны
   присутствовать в памяти, хотя остальные структуры данных могут быть
   перемещены во вторичную память (swap). Это позволяет ядру иметь
   минимальную информацию, необходимую для определения местоположения
   остальных данных, даже если они отсутствуют в оперативной памяти.

   Структура proc - это запись системной таблицы процессов (всегда в
   памяти). Запись выполняющегося в данный момент процесса определяет
   указатель curproc.

   Структура user (u-area, u-block) содержит дополнительные данные,
   необходимые ядру только во время выполнения процесса. Эта структура
   отображается в виртуальную память, содержит информацию об открытых
   файловых дескрипторах, статистику выполнения, сохраненные значения
   регистров. Процесс не должен иметь возможность модифицировать эти
   значения, поэтому u-area - в данных режима ядра.

   На Рис.1 показан системный стек в режиме ядра. Он образуется вместо
   обычного стека процесса.

                            Состояние процесса.

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   Рис.2. Состояние процесса.

   Примечание:

   4. например, ожидание ввода/вывода.

   5. при возвращении процесса из режима ядра в режим задачи ядро
   прерывает его и производит переключение для запуска более приоритетной
   задачи.

   6. процесс только что создан и находится в переходном состоянии:
   существует, но не готов к запуску и не находится в состоянии сна.

   3. не выполняется, но в любой момент готов к выполнение, как только
   планировщик выберет его (runnable).

   7. как таковой процесс уже не существует, но остались записи,
   содержащие код возврата и временную статистику выполнения, доступную
   для родительского процесса. Это состояние является конечным в
   жизненном цикле процесса.

   При предоставлении процессу вычислительных ресурсов происходит
   переключение контекста (context switch), в результате которого
   сохраняется образ, или контекст, текущего процесса, и управление
   передается новому.

   При выполнении процесса в режиме ядра контекст не переключается, а
   планировщик дожидается выхода в режим задачи, когда все системные
   операции завершены и структуры данных ядра в нормальном состоянии.

                        Принципы управления памятью.

   Данные, которые не могут быть размещены в оперативной памяти,
   располагаются во вторичной (обычно дисковые накопители).

   Подсистема управления памятью отвечает за эффективное распределение
   оперативной памяти как разделяемого ресурса между процессами и за
   обмен данными между оперативной и вторичной памятью.

   Часть операций производится аппаратно устройством управления памятью
   (MMU) процессора под управлением ОС.

   Возможности подсистемы управления памятью:

    1. Выполнение задач, размер которых больше размера оперативной
       памяти.
    2. Выполнение частично загруженных в память задач (для минимизации
       времени запуска).
    3. Размещение нескольких задач в памяти одновременно (для повышения
       производительности).
    4. Размещение задачи в произвольном месте оперативной памяти.
    5. Размещение задачи в нескольких различных местах оперативной
       памяти.
    6. Совместное использование несколькими задачами одних и тех же
       областей памяти (например, несколько запущенных экземпляров одной
       программы могут совместно использовать один сегмент кода).

   Эти возможности реализуются через механизм виртуальной памяти. Влечет
   высокие расходы ресурсов, так как около 70% процессорного времени
   тратится на управление памятью.

                      Виртуальная и физическая память.

   Оперативная память - это последовательность байт, каждый из которых
   имеет свой уникальный адрес, называемый физическим адресом.

   Адреса, используемые приложением и самим ядром, не обязаны
   соответствовать физическим адресам.

   Виртуальные адреса отображаются, или транслируются, в физические на
   аппаратном уровни при активном участии ядра ОС с помощью MMU. Каждый
   процесс выполняется в собственном виртуальном адресном пространстве.
   Процессы изолированы друг от друга (не могут получать доступ к чужому
   адресному пространству).

   Сегмент - область переменного размера в адресном пространстве.

   Страница - область фиксированного размера в адресном пространстве.

   Принцип работы: если при обращении к виртуальному адресу страница
   присутствует в ОП, то все в порядке. Если она отсутствует (находится в
   swap-памяти), то процессор генерирует аппаратное прерывание (page
   fault), в ответ на которое ядро положение нужной страницы в swap,
   считывает ее оттуда в ОП, устанавливает параметры отображения
   виртуальных адресов в физические и сообщает процессору о необходимости
   повторить операцию. Все эти действия невидимы для приложения.

   Замечание: механизм отображения существенно зависит от аппаратной
   архитектуры.

   Существует два способа организации памяти: сегментный и страничный.

   Сегментный - классический (адрес = сегмент + смещение). Между ОП и
   swap идет перемещение целиком сегментов. Этот механизм сильно устарел.
   Напоминает организацию памяти реального времени в DOS. Неэффективен.

   Страничный - все виртуальное адресное пространство (в
   Intel-архитектуре это 4 Гб) разбивается на блоки одинакового размера,
   называемые страницами. В большинстве Intel-систем их размер - 4 Кб.

   Как и для сегментов, страница находится либо в ОП, либо в swap. Этот
   механизм допускает, чтобы часть сегмента находилась в ОП, а часть в
   swap или в исполняемом файле процесса.

   Основное преимущество - система управления памятью оперирует блоками
   достаточно малого размера, может размещать их в произвольном порядке и
   месте, держит в памяти только то, что используется в данный момент.

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   Рис.2. Трансляция адреса с использованием

   страничного механизма.

   LDT, GDT - таблицы дескрипторов.

   LDT - трансляция для сегментов процесса.

   GDT - трансляция адресного пространства ядра.

   TI - бит-идентификатор LDT(1) и GDT(0).

   PDE - Page Directory Entry.

   PTE - Page Table Entry.

                      Адресное пространство процесса.

   Адресное пространство ядра обычно совпадает с адресным пространством
   выполняющегося в данный момент процесса. В этом случае говорят, что
   ядро расположено в том же контексте, что и процесс.

   Каждый раз, когда процессу передаются вычислительные ресурсы, система
   восстанавливает контекст задачи этого процесса.

   Для процесса - контекст - значение регистров общего назначения,
   сегментных регистров, указатели на таблицы страниц отображения
   виртуальной памяти в режиме задачи.

   0x08 graphic
   Системный контекст неизменный для всех процессов.

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   0x08 graphic

   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic

   Ядро (его код и данные) являются выполняющегося процесса. Таблицы
   страниц, отображающие старший Гб виртуальной памяти, который
   принадлежит ядру, не изменяются при переключении между процессами
   (переключении контекста). Отображение ядра - старшие 256 элементов
   каталога.

   При переключении между процессами изменяется адресное пространство
   режима задачи, что вызывает необходимость изменения 768 элементов
   каталога (они отображают 3Гб). Формат виртуальной памяти процесса в
   режиме задачи зависит от типа исполняемого файла (см. формат
   исполняемых файлов).

                             Замещение страниц.

   Старые методы - свопинг процессов целиком.

   0x08 graphic
   Новый - страничное замещение по требованию (впервые 1978 VAX-11/780,
   32-разрядная архитектура).

   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic
   0x08 graphic
   0x08 graphic

   0x08 graphic

   4. адресуемая страница отсутствует в памяти (нет ни в swap, ни в
   файле). Например, неинициализированные данные. При обращении к ней
   размещается новая страница, заполненная нулями.

                     Планирование выполнения процесса.

   Процессор, как и оперативная память, является разделяемым ресурсом.

   Планировщик процессов - подсистема ядра, которая обеспечивает
   предоставление процессам процессорных ресурсов.

   UNIX - система разделения времени, то есть каждому процессу ресурсы
   предоставляются на ограниченный промежуток времени.

   Максимальный временной интервал, на который процессор может занимать
   процессор, называется временным квантом.

   Различные приложения предъявляют различные требования к
   производительности и планированию:

    1. Интерактивные приложения. Допустимая задержка - 100-200 мс.
    2. Фоновые приложения (не требуют вмешательства пользователя). Важно
       минимальное суммарное время выполнения в загруженной системе.
    3. Приложения реального времени. Требуют гарантированного времени
       совершения операций и отклика.

   Планирование построено на определенном наборе правил. Желательным
   является удовлетворение нескольким требованиям, но чаще всего ищется
   <<золотая середина>>.

                       Обработка прерываний таймера.

   Любой компьютер имеет аппаратный таймер (системные часы), который
   генерирует аппаратные прерывания через фиксированный интервал времени.

   Временной интервал между соседними прерываниями таймера называется
   тиком процессора, или просто тиком.

   В большинстве систем находится в константе HZ в <param.h> (HZ=100 для
   тика в 10 мс).

   Приоритет обработчика прерываний таймера самый высокий.

   Задачи обработчика:

    1. Обновление статистики использования процессора для текущего
       процесса.
    2. Планирование - пересчет приоритетов и проверка истечения
       временного кванта текущего процесса.
    3. Проверка превышения процессорной квоты для данного процесса
       (отправляется SIGXCPU в случае превышения).
    4. Обновление системного времени и других таймеров.
    5. Обработка отложенных вызовов (callout).
    6. Обработка алармов.
    7. Пробуждение, если надо, системных процессов, например, диспетчера
       страниц и свопинга.

   Главный тик происходит каждые n тиков (делает пересчет приоритетов,
   обработка алармов, пробуждение системных процессов).

                             Системные вызовы.

   Отложенный вызов определяет функцию, вызов которой будет произведен
   ядром системы через некоторое время.

   Функции отложенных вызовов выполняются в системном контексте (а не в
   контексте задачи или прерывания), таким образом, она не должна
   обращаться к адресному пространству текущего процесса (так как она к
   нему не относится) и не должна переходить в режим сна.

   Регистрация отложенных вызовов - через функцию timeout.

   Применение: функции планировщика и подсистемы управления памятью,
   функции драйверов устройств ( в TCP повторная передача пакетов по
   таймауту), опрос устройств, не поддерживающих прерывания.

   Специальный обработчик отложенных вызовов - вызывается после обработки
   прерывания таймера.

                       Алармы (будильники, таймеры).

   Процесс может запросить ядро отправить сигнал по прошествии
   определенного интервала времени.

   Существует три типа алармов, с каждым из которых связан таймер
   интервала itimer (interval timer):

    1. реального времени (real-time) - SIGALRM - отсчет реального
       времени.
    2. профилирования (profiling) - SIGPROF- когда процесс выполняется в
       режиме ядра или задачи.
    3. виртуального времени (virtual time) - SIGVTALRM- процесс
       выполняется в режиме задачи.

   itimer уменьшается на единицу при каждом тике. Когда itimer=0, то
   процессу отправляется сответствующий сигнал.

                                   Данные

                                    Код

                                    Стек

                              Данные библиотек

                               Код библиотек

                                   u-area

                             Карты отображения

                               Системный стек

   Виртуальное адресное пространство процесса

                                 Заголовок

                                   Данные

                                    Код

                              Данные библиотек

                               Код библиотек

   Исполняемый файл

                                 Режим ядра

                                Режим задачи

   Создан

   Режим задачи

   Режим ядра

   Зомби

   Готов к запуску

                    Сон (ожидание недоступного ресурса)

   1

   2

   3

   4

   6

   7

   5

                                   fork()

                                   fork()

                                  wakeup()

                                  sleep()

                                   exit()

                                   wait()

                   Системный вызов, аппаратное прерывание

                           Планирование процесса

   селектор

   :

   смещение

   Виртуальный адрес

   LDT

   GDT

   TI=1

   TI=0

                                     +

                                    PDE

                                    PTE

   смещение

   Линейный адрес

                           Каталог таблиц страниц

   Таблица страниц

   страница

                             Физическая память

                              Физический адрес

   1024 x 1024 x 4096 = 4 Гб

                                    Ядро

                                    256

                                    768

   Каталог таблиц страниц

                   Виртуальное адресное пространство ядра

                 Виртуальное адресное пространство процесса

   0xFFFFFFFF

   1Гб

   0xC0000000

   3Гб

   0x00000000

                                     1

                             Физическая память

   Область свопинга

   2

   0

   4

   Виртуальное адресное пространство

                                    Файл

   3
