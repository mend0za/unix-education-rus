План практических занятий. Весна 2007.

1). Ознакомительное.
Теория: Unix-way. Система как единая компонентная IDE. Инструментарий разработчика. 
Практика: 
0. $EDITOR
1. Hello_world.c: gcc, a.out. 
2. Подключение и использование библиотек на примере -lm и log(3). 
3. Как читать маны из 2 и 3 раздела (#include, прототипы функций, линкуемые библиотеки, возвращаемые значения) на примере log(3)
4. Передача параметров
5. make, переменные, цели, $(CC), $(CFLAGS)
6. Отладка. gdb, -g, -Wall, strace, ltrace. На примере неинициализированного указателя и segfault.

2) Сигналы и демоны
Вызовы sleep(2), sigaction(2), fprintf
0. Написать простейшего демона с помощью функции daemon(3).
1. Демон с установкой игнорирования сигнала
2. sigaction + обработка произвольного сигнала с записью в лог
3. Конфиг вида "<номер сигнала> = [ignore|default|custom]\n", его перечитывание при SIGHUP

3) Неименованные трубы (pipe)
Вызовы fork(), pipe(), dup2, popen(), exec, strchr(), close.
Два вида файлового ввода/вывода: stdio (fopen,fclose, printf,...) и unistd(open,close, read, write). Строки как массивы символов.
0. Hello world на каналах. Создать канал, запустить новый процесс. Родительский читает строки с клавы и передаёт их дочернему, дочерний их пишет на экран.
1. Создать pipe. Считать команду с клавиатуры и создать дочерний процесс. передать ему строчку на выполнение через pipe. Выполнить команду в дочернем через exec().
2. Аналогично 1., только выполнить команду через popen() и вывести результаты на экран.
3. При вводе с клавы команды - находить >. Если оно есть - запускать процес, переопределять его ввод (1, out) через dup2 
( open(fd); dup2(fd, 1); fork+exec, родительский ждёт)
4. Находить |. Если есть - запускать канал, два процесса, переопределять у них fd 0,1 и делать 2 exec, родительский ждёт на wait

